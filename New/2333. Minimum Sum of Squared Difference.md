Link: [2333. Minimum Sum of Squared Difference](https://leetcode.com/problems/minimum-sum-of-squared-difference/description/) <br>
Tag : **Medium**<br>
Lock: **Normal**

You are given two positive **0-indexed** integer arrays `nums1` and `nums2`, both of length `n`.

The **sum of squared difference** of arrays `nums1` and `nums2` is defined as the **sum** of `(nums1[i] - nums2[i])2` for each `0 <= i < n`.

You are also given two positive integers `k1` and `k2`. You can modify any of the elements of `nums1` by `+1` or `-1` at most `k1` times. Similarly, you can modify any of the elements of `nums2` by `+1` or `-1` at most `k2` times.

Return _the minimum **sum of squared difference** after modifying array_ `nums1` _at most_ `k1` _times and modifying array_ `nums2` _at most_ `k2` _times_.

**Note**: You are allowed to modify the array elements to become **negative** integers.

**Example 1:**

```
Input: nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0
Output: 579
Explanation: The elements in nums1 and nums2 cannot be modified because k1 = 0 and k2 = 0. 
The sum of square difference will be: (1 - 2)2 + (2 - 10)2 + (3 - 20)2 + (4 - 19)2 = 579.
```

**Example 2:**

```
Input: nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1
Output: 43
Explanation: One way to obtain the minimum sum of square difference is: 
- Increase nums1[0] once.
- Increase nums2[2] once.
The minimum of the sum of square difference will be: 
(2 - 5)2 + (4 - 8)2 + (10 - 7)2 + (12 - 9)2 = 43.
Note that, there are other ways to obtain the minimum of the sum of square difference, but there is no way to obtain a sum smaller than 43.
```

**Constraints:**

- `n == nums1.length == nums2.length`
- `1 <= n <= 105`
- `0 <= nums1[i], nums2[i] <= 105`
- `0 <= k1, k2 <= 109`

**Solution:**

- [x] [[Greedy]] + [[Heap]]

## Detailed Intuition

1. Count the differences between each nums1[i] and nums2[i] and store them into an int[100_001], as nums is between 0 and 100_000.
2. Let's look at the example of [1,4,10,12], [4,8,6,7]. k1= 1, k2 =1
    Looking at the pairs of abs diff we have 3,4,4,5.
    So a total of 16 diff points with k = 2.
    As we observe, if we use the k operations on the first pair, we can decrease 3 to 1.
    but this would only help with 3^2 (9) -> 1. So we decrease the totam sum diff by 8.
    However, if we operate on the diff of 5, this would have much more impact.
    5 - 1 => (4^2)25 - 16 . so we save 9 points by using 1 k
    5 - 2 => (3^2) 25 - 9. So we save 16 points.
3. As we can see, we need to operate on the highest diff, lowering them.
4. As we have counted them on step #1, we would have an array like this
    [0,0,0,1,2,1] : 1 diff of 3, 2 of 4 and 1 of 5.
5. While k is > 0 (k1 + k2), start from the back (highest) and decrease it one group at a time.
    So make all 5 diffs into 4 diff, only if their cardinal is <= k. If it's greater than k, we can only
    lower k diff to diff -1.
    So [0,0,0,1,2,1] and k = 2 => [0,0,0,1,3,0] and k =1
    We have 3 diff of 4 and just k =1 so we can turn one 4 into a 3.
    => [0,0,0,2,2,0]. Thus. the diff becomes 2 of 3 and 2 of 4.

**Time Complexity** : O(n*log(n))<br>
**Space Complexity** : O(n)

```java
    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {

        int len = nums1.length;
        int dec = k1 + k2;
        TreeMap<Integer, Integer> freqMap = new TreeMap<>(Collections.reverseOrder());
        for (int i = 0; i < len; i++)
            freqMap.merge(Math.abs(nums1[i] - nums2[i]), 1, Integer::sum);

        freqMap.remove(0);
        while (!freqMap.isEmpty() && dec != 0) {
            Integer diff = freqMap.firstKey();
            Integer freq = freqMap.remove(diff);

            if (freq > dec) {
                Integer otherFreq = freq - dec;
                freq = freq - otherFreq;
                freqMap.merge(diff, otherFreq, Integer::sum);
            }

            diff--;
            dec = dec - freq;
            freqMap.merge(diff, freq, Integer::sum);
            freqMap.remove(0);
        }

        long sum = 0;
        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
            sum = sum + (long) Math.pow(entry.getKey(), 2) * (long) entry.getValue();
        }
        return sum;
    }
```

