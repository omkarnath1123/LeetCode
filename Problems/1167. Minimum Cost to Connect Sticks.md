Link: [1167.Â Minimum Cost to Connect Sticks](https://leetcode.com/problems/minimum-cost-to-connect-sticks/) <br>
Tag : **Medium**<br>
Lock: **Premium**

You have some number of sticks with positive integer lengths. These lengths are given as an arrayÂ `sticks`, whereÂ `sticks[i]`Â is the length of theÂ `ith`Â stick.

You can connect any two sticks of lengthsÂ `x`Â andÂ `y`Â into one stickÂ by paying a cost ofÂ `x + y`. You must connectÂ all the sticks until there is only one stick remaining.

ReturnÂ _the minimum cost of connecting all the given sticks into one stick in this way_.

**Example 1:**
```
Input: sticks = [2,4,3]
Output: 14
Explanation: You start with sticks = [2,4,3].
1. Combine sticks 2 and 3 for a cost of 2 + 3 = 5. Now you have sticks = [5,4].
2. Combine sticks 5 and 4 for a cost of 5 + 4 = 9. Now you have sticks = [9].
There is only one stick left, so you are done. The total cost is 5 + 9 = 14.
```

**Example 2:**
```
Input: sticks = [1,8,3,5]
Output: 30
Explanation: You start with sticks = [1,8,3,5].
1. Combine sticks 1 and 3 for a cost of 1 + 3 = 4. Now you have sticks = [4,8,5].
2. Combine sticks 4 and 5 for a cost of 4 + 5 = 9. Now you have sticks = [9,8].
3. Combine sticks 9 and 8 for a cost of 9 + 8 = 17. Now you have sticks = [17].
There is only one stick left, so you are done. The total cost is 4 + 9 + 17 = 30.
```

**Example 3:**
```
Input: sticks = [5]
Output: 0
Explanation: There is only one stick, so you don't need to do anything. The total cost is 0.
```

**Constraints:**
-   `1 <= sticks.length <= 104`
-   `1 <= sticks[i] <= 104`

## Detailed Intuition

### ğŸ’¡ How to Think About the Solution

1. **Greedy Selection Concept:**
   - Combined sticks get reused in future combinations
   - Earlier combinations affect total cost more
   - Always want to combine shortest sticks first
   - Need quick access to smallest elements

2. **Key Insights:**
   - Each combination creates new stick
   - Cost of each stick gets added multiple times
   - Priority queue (min-heap) perfect for getting minimum
   - Process continues until single stick remains

### ğŸ” Edge Cases to Consider
- Single stick (cost = 0)
- Two sticks (single combination)
- All sticks same length
- Very different stick lengths
- Maximum array length (10^4)
- Maximum stick length (10^4)
- Minimum stick length (1)
- Even vs odd number of sticks

### ğŸ¯ Solution Approaches

1. **Min Heap Approach**
   ```pseudo
   function connectSticks(sticks):
       if len(sticks) < 2:
           return 0
           
       minHeap = new MinHeap(sticks)
       totalCost = 0
       
       while minHeap.size() > 1:
           # Get two shortest sticks
           stick1 = minHeap.pop()
           stick2 = minHeap.pop()
           
           # Combine them
           cost = stick1 + stick2
           totalCost += cost
           
           # Add combined stick back
           minHeap.push(cost)
       
       return totalCost
   ```
   Time: O(n log n), Space: O(n)

### ğŸ“ˆ Visual Explanation
```
Example: sticks = [2,4,3]

Step 1: Initial heap
     2
    / \
   4   3

Step 2: Combine 2 and 3
   4
   |
   5   Cost: 5

Step 3: Combine 4 and 5
   9   Cost: 5 + 9 = 14

Total Cost = 14
```

### ğŸ› ï¸ Implementation Tips
1. Use built-in priority queue/heap
2. Initialize heap with all sticks
3. Keep combining until one stick left
4. Track running cost sum
5. Handle base cases first

### ğŸ“Š Complexity Analysis
- Time Complexity: O(n log n)
  - Heap initialization: O(n)
  - n-1 combinations: O(n log n)
  - Each heap operation: O(log n)
- Space Complexity: O(n)
  - Heap stores at most n elements

### ğŸ”— Related Patterns
- Priority Queue/Heap
- Greedy Algorithms
- Similar Problems:
  - Merge K Sorted Lists
  - Kth Largest Element
  - Last Stone Weight

### ğŸ“ Example Processing Flow
```
Input: [1,8,3,5]

Step-by-step processing:
1. Heap: [1,8,3,5]
   Combine 1,3 â†’ 4
   Heap: [4,8,5]
   Cost: 4

2. Heap: [4,8,5]
   Combine 4,5 â†’ 9
   Heap: [9,8]
   Cost: 4 + 9 = 13

3. Heap: [9,8]
   Combine 8,9 â†’ 17
   Heap: [17]
   Cost: 13 + 17 = 30

Final cost: 30
```

### âš ï¸ Common Mistakes to Avoid
1. Not using priority queue/heap
2. Wrong heap type (max instead of min)
3. Incorrect cost accumulation
4. Not handling single stick case
5. Inefficient stick combination tracking
**Time Complexity** : O(n log(n))<br>
**Space Complexity** : O(n)

```java
    public int connectSticks(int[] sticks) {
        
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (int stick : sticks) minHeap.add(stick);
        
        int cost = 0;
        while (minHeap.size() > 1) {
            int min = minHeap.poll(),
                secMin = minHeap.poll(),
                nextStick = min + secMin;
            cost += nextStick;
            minHeap.add(nextStick);
        }
        return cost;
    }
```
