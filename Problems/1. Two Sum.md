Link: [1. Two Sum](https://leetcode.com/problems/two-sum/description/) <br>
Tag : **Easy**<br>
Lock: **Normal**

Given an array of integersÂ `nums`Â and an integerÂ `target`, returnÂ _indices of the two numbers such that they add up toÂ `target`_.

You may assume that each input would haveÂ **_exactly_Â one solution**, and you may not use theÂ _same_Â element twice.

You can return the answer in any order.

**Example 1:**

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

**Example 2:**

```
Input: nums = [3,2,4], target = 6
Output: [1,2]
```

**Example 3:**

```
Input: nums = [3,3], target = 6
Output: [0,1]
```

**Constraints:**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **Only one valid answer exists.**

**Follow-up:**Â Can you come up with an algorithm that is less thanÂ `O(n2)`Â time complexity?

**Solution:**

- [x] [[Hash Table]]

## Detailed Intuition

### ğŸ’¡ How to Think About the Solution

1. **Complementary Pairs Concept:**
   - For any target sum T and a number X, we're looking for another number Y where X + Y = T
   - This means Y = T - X (the complement)
   - Example: If target = 9 and we see number 2, we're looking for 7

2. **Key Insights:**
   - We only need to scan the array once if we keep track of numbers we've seen
   - For each number, we can check if its complement exists in our "memory"
   - Hash table provides O(1) lookups, perfect for this use case

### ğŸ” Edge Cases to Consider
- Duplicate numbers in the array
- Negative numbers
- Zero as one of the numbers
- Array with exactly two elements
- Large numbers close to the constraints (-10^9 to 10^9)

### ğŸ¯ Solution Approaches

1. **Brute Force Approach (Not Optimal)**
   ```pseudo
   for i from 0 to n-1:
       for j from i+1 to n-1:
           if nums[i] + nums[j] == target:
               return [i, j]
   ```
   Time: O(nÂ²), Space: O(1)

2. **Optimal Hash Table Approach**
   ```pseudo
   create empty hash map
   for i from 0 to n-1:
       complement = target - nums[i]
       if complement exists in hash map:
           return [hash_map[complement], i]
       store nums[i] and its index in hash map
   ```
   Time: O(n), Space: O(n)

### ğŸ“ˆ Visual Explanation
Consider array [2, 7, 11, 15] with target = 9

```
Step 1: num = 2
        complement needed = 9 - 2 = 7
        Hash Map: {2: 0}

Step 2: num = 7
        complement needed = 9 - 7 = 2
        Found 2 in hash map! Return [0, 1]
```

### ğŸ› ï¸ Implementation Tips
1. Use HashMap/Dictionary to store number:index pairs
2. Check for complement before adding current number to prevent using same element twice
3. Make sure to handle integer overflow cases in languages where it matters

### ğŸ”— Related Patterns
- Two Pointer Technique (if array is sorted)
- Hash Table for O(1) lookups
- Similar Problems:
  - Two Sum II (sorted array)
  - Two Sum III (data structure design)
  - 3Sum
  - 4Sum

### Approach:
1. **Hash Table Strategy**:
   - As we iterate through the array, for each number x:
   - Check if (target - x) exists in our hash table
   - If yes, we found our pair!
   - If no, store x and its index in the hash table for future lookups

### Edge Cases to Consider:
- Array with just two elements
- Negative numbers in the array
- Same numbers that sum to target (like [3,3] with target=6)
- Very large numbers (check the constraints)

### Visual Explanation:
```
nums = [2, 7, 11, 15], target = 9

Step 1: num = 2
HashMap: {2: 0}
Looking for: (9-2) = 7 âŒ not found

Step 2: num = 7
HashMap: {2: 0}
Looking for: (9-7) = 2 âœ… found at index 0
Return [0, 1]
```

### Time and Space Complexity:
- Time: O(n) - single pass through the array
- Space: O(n) - storing at most n elements in the hash table

### Common Pitfalls:
1. Don't use the same element twice
2. Make sure to check if complement exists before adding current number
3. Remember to handle negative numbers

### Useful Resources:
- [Hash Table Visualization](https://www.cs.usfca.edu/~galles/visualization/OpenHash.html)
- [Two Sum Problem Pattern](https://leetcode.com/discuss/study-guide/1688903/Solved-all-two-sum-problems-in-100-days)

**Time Complexity** : O(n)<br>
**Space Complexity** : O(n)

```java
    public int[] twoSum(int[] nums, int target) {
        
        int length = nums.length;
        Map<Integer, Integer> indexMap = new HashMap<>();

        for (int i = 0 ; i < length; i++) {
            if (indexMap.containsKey(target - nums[i])) {
                return new int[]{indexMap.get(target - nums[i]), i};
            }
            indexMap.put(nums[i], i);
        }
        return new int[]{0, 0};
    }
```

