Link: [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/description/) <br>
Tag : **Medium**<br>
Lock: **Normal**

You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return _the maximum amount of water a container can store_.

**Notice** that you may not slant the container.

**Example 1:**

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)

```
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
```

**Example 2:**

```
Input: height = [1,1]
Output: 1
```

**Constraints:**

- `n == height.length`
- `2 <= n <= 105`
- `0 <= height[i] <= 104`

**Solution:**

- [x] [[Greedy]] + [[Two Pointer]]

## Detailed Intuition

Goal: find two indices i < j that maximize area = min(height[i], height[j]) * (j - i) while using O(1) extra space and scanning the array in linear time.

High-level idea (two-pointer, greedy):
- Start with two pointers at the ends: left = 0 and right = n - 1. This gives the maximum possible width initially.
- The area is limited by the shorter of the two heights, so the current area is min(height[left], height[right]) * (right - left).
- To possibly find a larger area, we need either a larger height for the limiting side or a larger width. Since width will only decrease as the pointers move inward, the only hope is to find a taller line that increases the min(height[left], height[right]).
- Therefore, move the pointer that points to the shorter height inward (if height[left] < height[right], increment left; otherwise decrement right). This is the greedy step.

Why moving the shorter pointer is safe (intuition + invariant):
- Suppose height[left] < height[right]. For any k with left < k < right, the width (k - right) is smaller than (right - left). The height of the container using left and any k is at most height[left] (since min(height[left], height[k]) <= height[left]). Thus area(left,k) <= height[left] * (k - left) < = height[left] * (right - left) if k < right. In other words, keeping left fixed and moving the right pointer inward cannot produce a better area than the current one because width shrinks and the limiting height cannot exceed height[left]. So left cannot be part of an optimal pair with any inner index — it's safe to advance left.
- The same symmetric argument applies if height[right] <= height[left], so we move right inward.
- Invariant: before each iteration, the maximal area using any pair with indices fully outside the current [left,right] window has already been considered; all candidate pairs that could beat the current max must include at least one pointer inside the current range, so moving the shorter pointer preserves correctness.

Concrete step-by-step example (height = [1,8,6,2,5,4,8,3,7]):
1. left=0 (1), right=8 (7) => area = min(1,7)*8 = 8. Move left (1 < 7).
2. left=1 (8), right=8 (7) => area = min(8,7)*7 = 49. Move right (7 < 8).
3. left=1 (8), right=7 (3) => area = min(8,3)*6 = 18. Move right (3 < 8).
4. left=1 (8), right=6 (8) => area = min(8,8)*5 = 40. Move right (8 <= 8 so right--).
5. left=1 (8), right=5 (4) => area = min(8,4)*4 = 16. Move right (4 < 8).
6. left=1 (8), right=4 (5) => area = min(8,5)*3 = 15. Move right (5 < 8).
7. left=1 (8), right=3 (2) => area = min(8,2)*2 = 4. Move right (2 < 8).
8. left=1 (8), right=2 (6) => area = min(8,6)*1 = 6. Move right (6 < 8).
Loop ends. Maximum encountered area = 49.

Edge cases and how to think about them:
- Minimum size (n == 2): there's only one possible container; algorithm returns min(h[0], h[1]) * 1.
- Repeated equal heights: when heights are equal, you can move either pointer (common implementation moves right when height[left] <= height[right]); both choices are safe and algorithm still explores all necessary candidates.
- Zero heights and lines of height 0: they contribute zero area; pointers will skip past them as necessary. If many zeros exist, algorithm still runs in linear time.
- Monotonic arrays (strictly increasing or decreasing heights): the two-pointer method still correctly finds the optimal pair; mentally simulate how the shorter-pointer movement prunes dominated pairs.
- Large arrays and constraints: n up to 1e5 — the O(n) two-pointer solution is necessary. Brute force O(n^2) will time out.
- Very wide but shallow vs narrow but tall tradeoffs: the greedy pointer movement balances width and limiting height by always trying to find a taller limiting side while the width shrinks; that tradeoff is handled by the greedy rule.

Alternative approaches (for thought):
- Brute force: check all pairs i < j and compute area — O(n^2) time, too slow for n up to 1e5.
- Divide-and-conquer or segment-tree based strategies: possible but more complex than needed — two-pointer greedy is simplest and optimal here.

Complexity recap:
- Time: O(n) — each pointer moves at most n steps total.
- Space: O(1) — only a few integer variables are used.

Testing checklist (small manual tests to validate reasoning):
- height = [1,1] -> area = 1
- height = [0,2,0] -> area = 0 (best is between 2 and either 0)
- height = [1,2,4,3] -> area = 4 (between 2 and 4 or 1 and 4 depending)
- height = [1,8,6,2,5,4,8,3,7] -> area = 49 (example)
- height = [10000, 0, 10000] -> area = max is min(10000,10000)*2 = 20000

```java
    public int maxArea(int[] height) {
        
        int len = height.length;
        int start = 0, end = len - 1;
        int maxWater = 0;

        while (start < end) {
            maxWater = Math.max(maxWater, Math.min(height[start], height[end]) * (end - start));
            if (height[start] < height[end]) start++;
            else end--;
        }
        return maxWater;
    }
```
