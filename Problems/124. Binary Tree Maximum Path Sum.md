Link: [87. Scramble String](https://leetcode.com/problems/scramble-string/) <br>
Tag : **Hard**<br>
Lock: **Normal**

A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.

The **path sum** of a path is the sum of the node's values in the path.

Given the `root` of a binary tree, return _the maximum **path sum** of any **non-empty** path_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

```
Input: root = [1,2,3]
Output: 6
Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

```
Input: root = [-10,9,20,null,null,15,7]
Output: 42
Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.
```

**Constraints:**

-   The number of nodes in the tree is in the range `[1, 3 * 104]`.
-   `-1000 <= Node.val <= 1000`


**Solution:**

- [x] [[Depth First Search]]

## Detailed Intuition

### How to Think About the Solution:
1. Think of paths as having a "highest" point
2. Each node can be the peak of a path
3. Need to consider both through-paths and end-paths
4. Use divide-and-conquer to build solutions

### Key Insights:
1. Path must be continuous but needn't use root
2. Once path goes down, can't go back up
3. Each node presents two choices:
   - Continue path through node
   - Start new path from node

### Step-by-Step Approach:
1. **For Each Node**:
   - Calculate max path ending at node
   - Calculate max path using node as peak
   - Update global maximum if needed

2. **Recursive Structure**:
   - Get max paths from children
   - Combine with current node
   - Return best extendable path

### Visual Guide:
```
Example: [-10,9,20,null,null,15,7]

        -10
        /  \
       9    20
           /  \
          15   7

At node 20:
Left path: 15
Right path: 7
Through path: 15 -> 20 -> 7 = 42
Return path: max(20+15, 20+7) = 35

At root -10:
Left path: 9
Right path: 35
Through path: 9 -> -10 -> 35 = 34
Global max remains 42
```

### Edge Cases to Consider:
- Single node tree
- All negative values
- Only one good path
- Alternating positive/negative
- Deep unbalanced trees

### Common Pitfalls:
1. Not handling negative values
2. Incorrect path combination
3. Missing global maximum update
4. Wrong recursive return value

### Optimization Techniques:
1. **Path Building**:
   - Only extend positive paths
   - Early termination for negatives
   - Track global max efficiently

2. **Memory Usage**:
   - Constant extra space
   - No path storage needed
   - In-place calculation

### Time and Space Analysis:
- Time Complexity: O(n)
  - Visit each node once
  - Constant work per node
- Space Complexity: O(h)
  - h = height of tree
  - Recursion stack space

### Similar Problems:
- Binary Tree Maximum Path Sum II
- Diameter of Binary Tree
- Longest Univalue Path

### Implementation Tips:
1. Use global variable for max
2. Return extendable path value
3. Handle negative values properly
4. Consider all possible paths

### Useful Resources:
- [Tree Traversal Patterns](https://leetcode.com/articles/a-recursive-approach-to-segment-trees-range-sum-queries-lazy-propagation/)
- [Divide and Conquer in Trees](https://www.geeksforgeeks.org/divide-and-conquer-introduction/)
**Time Complexity** : O(n)<br>
**Space Complexity** : O(1)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
     int maxSum;
    public int maxPathSum(TreeNode root) {
        maxSum = Integer.MIN_VALUE;
        traverse(root);
        return maxSum;
    }
    private int traverse(TreeNode node) {
        if (node == null) return 0;
        
        int leftSum = traverse(node.left);
        int rightSum = traverse(node.right);
        maxSum = Math.max(node.val + leftSum + rightSum, maxSum);
        maxSum = Math.max(node.val + leftSum, maxSum);
        maxSum = Math.max(node.val + rightSum, maxSum);
        maxSum = Math.max(node.val, maxSum);
        return Math.max(0, node.val + Math.max(leftSum, rightSum));
    }
```


