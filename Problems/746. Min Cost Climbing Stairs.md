Link: [746. Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/description/) <br>
Tag : **Easy**<br>
Lock: **Normal**

You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.

You can either start from the step with index 0, or the step with index 1.

Return the minimum cost to reach the top of the floor.

 

Example 1:

```
Input: cost = [10,15,20]
Output: 15
Explanation: You will start at index 1.
- Pay 15 and climb two steps to reach the top.
The total cost is 15.
```
Example 2:

```
Input: cost = [1,100,1,1,1,100,1,1,100,1]
Output: 6
Explanation: You will start at index 0.
- Pay 1 and climb two steps to reach index 2.
- Pay 1 and climb two steps to reach index 4.
- Pay 1 and climb two steps to reach index 6.
- Pay 1 and climb one step to reach index 7.
- Pay 1 and climb two steps to reach index 9.
- Pay 1 and climb one step to reach the top.
The total cost is 6.
```
 

Constraints:

2 <= cost.length <= 1000
0 <= cost[i] <= 999

**Solution:**

- [x] [[Dynamic Programming]]

## Detailed Intuition

Think of this as a shortest-path / dynamic programming problem on a 1D line of stairs where each step i has a "cost" to stand on it. Let dp[i] represent the minimum total cost to reach step i (i is an index into the cost array). The key observation is that to arrive at step i you must have come from either step i-1 (a one-step move) or step i-2 (a two-step move). Since you always pay the cost of the step you land on, the optimal cost to reach i is the cost of i plus the cheaper of the two ways to get to i:

    dp[i] = cost[i] + min(dp[i-1], dp[i-2])

Base cases encode the fact you may start at step 0 or step 1 without paying anything before that: dp[0] = cost[0], dp[1] = cost[1]. The top of the floor is one step past the last index (index n), so the answer is the cheaper way to reach the last step or the second-last step (and then step to the top):

    answer = min(dp[n-1], dp[n-2])

How to think about the solution (strategy and intuition):
- Local decisions depend only on the previous two states, so this is a classic DP with a small fixed-state dependency (window of size 2).
- Greedy choices (like always taking the cheaper immediate step) can fail because a slightly more expensive immediate step may allow skipping a very expensive step later. The second example in the problem demonstrates this pattern.
- It helps to visualize the cost array with arrows showing legal moves (1 or 2 steps) and label each step with the best cost so far; you'll see each dp[i] is just the min from the two incoming arrows plus cost[i].
- You can optimize space from O(n) to O(1) by keeping only the last two dp values (prev2, prev1) and rolling forward.

Edge cases and things to watch for:
- Small n: when n == 2 the answer is simply min(cost[0], cost[1]) — handled by returning min(dp[1], dp[0]). (Constraints guarantee n >= 2, but it's good to reason this out.)
- Off-by-one / interpretation of "top": remember the top is after the last index (index n). You don't pay any cost for the top itself — you only pay for steps you land on.
- Zeros and equal values: arrays containing zeros or many equal small values still work with the recurrence; tie choices don't affect the minimal cost but might change the path.
- Large values: costs up to 999 don't change the algorithm; ensure sums fit in an int for the language used (Java int is fine here because n <= 1000 and cost[i] <= 999, so max sum < 1e6).
- Invalid input: the problem constraints rule out negative costs and lengths < 2; if you generalize, validate n >= 1 and handle n == 1 as a special case.
- Off-by-one bugs when implementing: double-check indices in the loop (start from i = 2) and the final return (min of last two dp entries).

Quick implementation tips and debugging checklist:
- Initialize dp[0] and dp[1] explicitly.
- Iterate i from 2 to n-1 updating dp[i] using the recurrence.
- Return min(dp[n-1], dp[n-2]).
- To reduce memory, use two variables prev and curr: at each step compute next = cost[i] + min(curr, prev); then shift prev = curr; curr = next.
- If you get a wrong answer, print the dp array for a small test to verify base cases and transitions.

Small example walkthrough (intuition): for cost = [1,100,1,1]
- dp[0]=1, dp[1]=100
- dp[2]=1 + min(100,1) = 2
- dp[3]=1 + min(2,100) = 3
- answer = min(dp[3], dp[2]) = min(3,2) = 2 (start at 0, jump to 2, then to top)

This reasoning explains the recurrence, common pitfalls, and why the O(1) space optimization is correct.

```java
    public int minCostClimbingStairs(int[] cost) {
        int length = cost.length;
        int[] res = new int[length];
        res[0] = cost[0];
        res[1] = cost[1];

        for (int i = 2; i < length; i++)
            res[i] = Math.min(res[i - 1] + cost[i], res[i - 2] + cost[i]);
        return Math.min(res[length - 1], res[length - 2]);
    }
```
