Link: [1144.Â Decrease Elements To Make Array Zigzag](https://leetcode.com/problems/decrease-elements-to-make-array-zigzag/) <br>
Tag : **Medium**<br>
Lock: **Normal**

Given an arrayÂ `nums`Â of integers, aÂ _move_Â consists of choosing any element andÂ **decreasing it by 1**.

An arrayÂ `A`Â is aÂ _zigzag array_Â if either:

- Every even-indexed element is greater than adjacent elements, ie.Â `A[0] > A[1] < A[2] > A[3] < A[4] > ...`
- OR, every odd-indexed element is greater than adjacent elements, ie.Â `A[0] < A[1] > A[2] < A[3] > A[4] < ...`

Return the minimum number of moves to transform the given arrayÂ `nums`Â into a zigzag array.

**Example 1:**

```
Input: nums = [1,2,3]
Output: 2
Explanation: We can decrease 2 to 0 or 3 to 1.
```

**Example 2:**

```
Input: nums = [9,6,1,6,2]
Output: 4
```

**Constraints:**

- `1 <= nums.length <= 1000`
- `1 <= nums[i] <= 1000`

## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **Zigzag Pattern Concept:**
   - Two possible valid patterns:
     a) Peak at even indices: âˆ§âˆ§âˆ§ (up-down-up-down)
     b) Peak at odd indices: âˆ¨âˆ¨âˆ¨ (down-up-down-up)
   - Can only decrease elements
   - Need to find minimum moves for each pattern

2. **Key Insights:**
   - Only need to try two patterns
   - Can process each element independently
   - Elements can only decrease, never increase
   - Compare with adjacent elements

### ðŸ” Edge Cases to Consider
- Single element array
- Two elements array
- Array already in zigzag form
- All elements same value
- Strictly increasing array
- Strictly decreasing array
- Maximum array length (1000)
- Maximum element value (1000)
- Alternating large/small values

### ðŸŽ¯ Solution Approaches

1. **Two-Pattern Greedy**
   ```pseudo
   function minMoves(nums):
       n = nums.length
       evenPeaks = 0  # Cost for making even indices peaks
       oddPeaks = 0   # Cost for making odd indices peaks
       
       for i in range(n):
           left = nums[i-1] if i > 0 else float('-inf')
           right = nums[i+1] if i < n-1 else float('-inf')
           
           if i % 2 == 0:  # Even index
               # For even peaks pattern
               evenPeaks += max(0, -(nums[i] - max(left, right) - 1))
               # For odd peaks pattern
               oddPeaks += max(0, nums[i] - min(left, right) + 1)
           else:  # Odd index
               # For even peaks pattern
               evenPeaks += max(0, nums[i] - min(left, right) + 1)
               # For odd peaks pattern
               oddPeaks += max(0, -(nums[i] - max(left, right) - 1))
       
       return min(evenPeaks, oddPeaks)
   ```
   Time: O(n), Space: O(1)

### ðŸ“ˆ Visual Explanation
```
Example: nums = [1,2,3]

Pattern 1 (Even Peaks):
Original:  1 2 3
Target:    1 0 3
           âˆ§ âˆ¨ âˆ§
Moves: Decrease 2 by 2
Cost: 2

Pattern 2 (Odd Peaks):
Original:  1 2 3
Target:    0 2 1
           âˆ¨ âˆ§ âˆ¨
Moves: Decrease 1 by 1, 3 by 2
Cost: 3

Choose Pattern 1 (minimum cost = 2)
```

### ðŸ› ï¸ Implementation Tips
1. Process each index independently
2. Track costs for both patterns
3. Handle array boundaries
4. Use infinity for boundary comparisons
5. Calculate moves needed efficiently

### ðŸ“Š Complexity Analysis
- Time Complexity: O(n)
  - Single pass through array
  - Constant work per element
- Space Complexity: O(1)
  - Only need few variables

### ðŸ”— Related Patterns
- Array Manipulation
- Greedy Algorithms
- Two-Pattern Comparison
- Similar Problems:
  - Wiggle Sort
  - Wiggle Subsequence
  - Valid Mountain Array

### ðŸ“ Example Processing Flow
```
Input: [9,6,1,6,2]

Even Peaks Pattern:
9 6 1 6 2  (Original)
9 4 1 4 2  (After moves)
âˆ§ âˆ¨ âˆ§ âˆ¨ âˆ§
Moves: 2 at index 1, 2 at index 3
Total: 4 moves

Odd Peaks Pattern:
9 6 1 6 2  (Original)
5 6 0 6 1  (After moves)
âˆ¨ âˆ§ âˆ¨ âˆ§ âˆ¨
Moves: 4+1+1+1 = 7 moves

Choose Even Peaks (4 moves)
```

### âš ï¸ Common Mistakes to Avoid
1. Not considering both patterns
2. Incorrect boundary handling
3. Wrong move calculation
4. Not handling equal adjacent values
5. Forgetting that only decreases allowed
**Space Complexity** : O(1)

```java
    public int movesToMakeZigzag(int[] nums) {
        if (nums.length == 1) return 0;

        return Math.min(moves(0, nums), moves(1, nums));
    }
    private int moves(int start, int[] nums) {
        
        int moves = 0, len = nums.length;
        for (int i = start; i < len; i += 2)
            if (i == 0)
                moves += Math.max(0, nums[i] - nums[i + 1] + 1);
            else if (i == len - 1)
                moves += Math.max(0, nums[i] - nums[i - 1] + 1);
            else
                moves += Math.max(0, 
                                  Math.max(nums[i] - nums[i + 1],
                                           nums[i] - nums[i - 1]) + 1);
        
        return moves;
    }
```
