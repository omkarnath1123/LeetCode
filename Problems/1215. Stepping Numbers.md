Link: [1215. Stepping Numbers](https://leetcode.com/problems/stepping-numbers/) <br>
Tag : **Medium**<br>
Lock: **Premium**

A **stepping number** is an integer such that all of its adjacent digits have an absolute difference of exactly `1`.

-   For example, `321` is a **stepping number** while `421` is not.

Given two integers `low` and `high`, return _a sorted list of all the **stepping numbers** in the inclusive range_ `[low, high]`.

**Example 1:**
```
Input: low = 0, high = 21
Output: [0,1,2,3,4,5,6,7,8,9,10,12,21]
```

**Example 2:**
```
Input: low = 10, high = 15
Output: [10,12]
```

**Constraints:**
-   `0 <= low <= high <= 2 * 109`

## Detailed Intuition

### üí° How to Think About the Solution

1. **Number Graph Concept:**
   - Each digit connects to ¬±1 digits
   - Numbers form paths in digit graph
   - BFS/DFS can explore all possibilities
   - Need to stay within range bounds

2. **Key Insights:**
   - Start with single digits
   - Build numbers by appending digits
   - Each position has at most 2 choices
   - Can prune paths outside range

### üîç Edge Cases to Consider
- Range includes 0
- Single digit numbers
- Large numbers (2√ó10^9)
- Equal low and high
- No valid numbers in range
- All digits as stepping numbers
- Maximum possible length
- Range boundaries
- Numbers with leading zeros
- Adjacent equal digits

### üéØ Solution Approaches

1. **BFS Number Generation**
   ```pseudo
   function steppingNumbers(low, high):
       result = []
       if low == 0:
           result.add(0)
       
       queue = [1,2,3,4,5,6,7,8,9]
       while queue not empty:
           num = queue.poll()
           if num > high:
               continue
           
           if num >= low:
               result.add(num)
           
           lastDigit = num % 10
           # Try appending lastDigit ¬± 1
           if lastDigit > 0:
               next = num * 10 + (lastDigit - 1)
               if next <= high:
                   queue.add(next)
           if lastDigit < 9:
               next = num * 10 + (lastDigit + 1)
               if next <= high:
                   queue.add(next)
       
       return sort(result)
   ```
   Time: O(2^n), Space: O(2^n)
   where n is max number length

### üìà Visual Explanation
```
Example: low=10, high=15

Number Generation Tree:
        1       2 ... 9
       / \
     10  12    (11 invalid)
         /
       121     (too large)

Valid Numbers:
10: Valid (1‚Üí0 is step of 1)
12: Valid (1‚Üí2 is step of 1)
```

### üõ†Ô∏è Implementation Tips
1. Handle zero separately
2. Process numbers in order
3. Check range bounds early
4. Use efficient number building
5. Prune invalid branches

### üìä Complexity Analysis
- Time Complexity: O(2^n)
  - Each digit has 2 choices
  - n is number of digits
- Space Complexity: O(2^n)
  - Store all valid numbers
  - Queue/recursion stack

### üîó Related Patterns
- Graph Traversal
- BFS/DFS
- Number Construction
- Similar Problems:
  - Numbers With Same Consecutive Differences
  - Sequential Digits
  - Monotonic Array

### üìù Example Processing Flow
```
Input: low=10, high=21

1. Start with single digits:
   Queue: [1,2,3,4,5,6,7,8,9]

2. Process 1:
   Generate: 10,12
   10: Add to result
   12: Add to result

3. Process 2:
   Generate: 21,23
   21: Add to result
   23: Skip (> high)

Result: [10,12,21]
```

### ‚ö†Ô∏è Common Mistakes to Avoid
1. Missing zero case
2. Wrong range checks
3. Invalid number construction
4. Missing stepping validation
5. Inefficient generation

```java
class Solution {
    public List<Integer> steppingNumbers(int low, int high) {
        List<Integer> result = new ArrayList<>();
        if (low == 0) {
            result.add(0);
        }
        
        Queue<Long> queue = new LinkedList<>();
        for (long i = 1; i <= 9; i++) {
            queue.offer(i);
        }
        
        while (!queue.isEmpty()) {
            long curr = queue.poll();
            if (curr > high) {
                continue;
            }
            
            if (curr >= low) {
                result.add((int)curr);
            }
            
            long lastDigit = curr % 10;
            // Try appending lastDigit ¬± 1
            if (lastDigit > 0) {
                long next = curr * 10 + (lastDigit - 1);
                if (next <= high) {
                    queue.offer(next);
                }
            }
            if (lastDigit < 9) {
                long next = curr * 10 + (lastDigit + 1);
                if (next <= high) {
                    queue.offer(next);
                }
            }
        }
        
        Collections.sort(result);
        return result;
    }
}

### Visual Guide:
```
Example: low=10, high=21

Number Tree:
     1       2       3 ...
    / \     / \     / \
  10  12   21 23   32 34
     /  \
   121  123

Valid numbers in range:
- 10 (from path 1‚Üí0)
- 12 (from path 1‚Üí2)
- 21 (from path 2‚Üí1)
```

### Edge Cases to Consider:
- Single digit numbers
- Zero handling
- Range boundaries
- Maximum possible value
- All digits different by 1

### Common Pitfalls:
1. Missing valid numbers
2. Wrong range checks
3. Inefficient generation
4. Integer overflow

### Optimization Techniques:
1. **Number Generation**:
   - Prune invalid paths early
   - Skip numbers outside range
   - Use efficient number building

2. **State Management**:
   - Track current digit
   - Maintain running number
   - Optimize memory usage

### Time and Space Analysis:
- Time Complexity: O(2¬π‚Å∞)
  - Each digit has 2 choices
  - Maximum 10 digits possible
- Space Complexity: O(2¬π‚Å∞)
  - Store all valid numbers
  - Recursion stack depth

### Similar Problems:
- Numbers With Same Consecutive Differences
- Sequential Digits
- Count Numbers with Unique Digits

### Implementation Tips:
1. Use StringBuilder for number building
2. Check bounds before adding numbers
3. Handle zero specially
4. Sort result if required

### Useful Resources:
- [Graph Traversal Patterns](https://leetcode.com/explore/learn/card/graph/)
- [Backtracking Techniques](https://leetcode.com/explore/learn/card/recursion-ii/)

**Solution:**

- [x] [[Backtracking]]

**Intuition** :
start node = 0  
From 0, we can move to 1 2 3 4 5 6 7 8 9 [ Add these to queue. ]  
now from 1, we can move to 12 and 10  
from 2, we can move to 23 and 21  
from 3,, we can move to 34 and 32  
.  
.  
and so on

**Time Complexity** : O(2<sup>10</sup>)<br>
**Space Complexity** : O(2<sup>10</sup>)

```java
    List<Integer> comb;
    public List<Integer> countSteppingNumbers(int low, int high) {
        
        comb = new LinkedList<>();
        if (low <= 0 && 0 <= high) comb.add(0);
        for (int i = 1; i <= 9; i++)
            backTrack(low, high, new StringBuilder(Integer.toString(i)), i);
        
        Collections.sort(comb);
        return comb;
    }
    private void backTrack(long low, long high, StringBuilder num, int prevNo) {
        long val = Long.parseLong(num.toString());
        if (high < val) return;
        if (low <= val) comb.add(Integer.parseInt(num.toString()));
        
        int before = prevNo - 1,
            after = prevNo + 1;
        if (0 <= before) {
            num.append(before);
            backTrack(low, high, num, before);
            num.deleteCharAt(num.length() - 1);
        }
        if (after <= 9) {
            num.append(after);
            backTrack(low, high, num, after);
            num.deleteCharAt(num.length() - 1);
        }
    }
```
