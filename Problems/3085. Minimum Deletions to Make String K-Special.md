Link: [3085. Minimum Deletions to Make String K-Special](https://leetcode.com/problems/minimum-deletions-to-make-string-k-special/description/?envType=daily-question&envId=2025-10-19) <br>
Tag : **Medium**<br>
Lock: **Normal**

You are given a string `word` and an integer `k`.

We consider `word` to be **k-special** if `|freq(word[i]) - freq(word[j])| <= k` for all indices `i` and `j` in the string.

Here, `freq(x)` denotes the frequency of the character `x` in `word`, and `|y|` denotes the absolute value of `y`.

Return _the **minimum** number of characters you need to delete to make_ `word` **_k-special_**.

**Example 1:**

```
Input: word = "aabcaba", k = 0

Output: 3

Explanation: We can make word 0-special by deleting 2 occurrences of "a" and 1 occurrence of "c". Therefore, word becomes equal to "baba" where freq('a') == freq('b') == 2.
```

**Example 2:**

```
Input: word = "dabdcbdcdcd", k = 2

Output: 2

Explanation: We can make word 2-special by deleting 1 occurrence of "a" and 1 occurrence of "d". Therefore, word becomes equal to "bdcbdcdcd" where freq('b') == 2, freq('c') == 3, and freq('d') == 4.
```

**Example 3:**

```
Input: word = "aaabaaa", k = 2

Output: 1

Explanation: We can make word 2-special by deleting 1 occurrence of "b". Therefore, word becomes equal to "aaaaaa" where each letter's frequency is now uniformly 6.
```

**Constraints:**

- `1 <= word.length <= 105`
- `0 <= k <= 105`
- `word` consists only of lowercase English letters.

**Solution:**

- [x] [[Greedy]]

## Detailed Intuition

The task requires us to delete certain characters from the given string so that the difference in the frequency of any two types of characters does not exceed\u00a0k.

To do this, we first use a hash table to count the number of occurrences of each character, where\u00a0cnt[c]\u00a0represents the number of times the character\u00a0c\u00a0appears. Since there are only\u00a026\u00a0character types, we can enumerate one of them as the "character with the lowest frequency after the deletion operation" and set it as\u00a0c. Then, all characters with frequencies less than\u00a0cnt[c]\u00a0will be entirely deleted, and all characters with frequencies greater than\u00a0cnt[c]+k\u00a0will be reduced to exactly\u00a0cnt[c]+k\u00a0instances.

Among all such enumeration schemes, we select the one that results in the smallest total number of deletions.


**Time Complexity** : O(n<sup>2</sup>)<br>
**Space Complexity** : O(1)

```java
    public int minimumDeletions(String word, int k) {
        
        Map<Character, Integer> freq = new HashMap<>();
        for (char ch : word.toCharArray())
            freq.merge(ch, 1, Integer::sum);
        
        List<Integer> count = new LinkedList<>();
        count.addAll(freq.values());
        Collections.sort(count);
        int minDel = Integer.MAX_VALUE;

        for (int num : count) {
            int del = 0;
            for (int iter : count) {
                if (iter < num)
                    del = del + iter;
                else if (iter - k > num) {
                    del = del + iter - num - k;
                }
            }
            minDel = Math.min(del, minDel);
        }
        return minDel;
    }
```

### Edge cases and how to think about the solution

Edge cases to watch for:

- Single character string: when the word contains only one distinct character (for example "aaaa"), the answer is 0 because all frequencies are already equal and within any k.
- k is very large: if k >= (max_freq - min_freq) for the existing character frequencies, the string is already k-special and no deletions are required.
- k == 0: this reduces to requiring all remaining characters to have equal frequency. The optimal result often requires deleting entire character types or trimming larger counts down to a common value.
- Extremely small counts vs very large counts: when some characters appear only once (or a few times) while others appear many times, it may be optimal to delete the small-frequency characters entirely rather than trimming the large ones; the enumeration of possible minimum target frequencies captures this trade-off.
- Considering "delete all of a character type" (target minimum 0): in some cases the optimal minimum frequency after deletions can be 0 (i.e., delete every occurrence of some characters). When implementing the enumeration of candidate "minimum frequencies", include 0 as a candidate or ensure your enumeration of existing counts implicitly covers the delete-all case by choosing the smallest existing count and deleting the small group entirely.
- Constraints edge: word length is at least 1 per problem constraints, so you don't need to handle an empty input, but defensive code can still check for it.

How to think about the solution (step-by-step mental model):

- Key observation: after deletions, the remaining non-zero character frequencies must all lie in a contiguous interval [t, t + k] for some integer t >= 0. If we knew t, we could compute the minimum deletions needed to make every character's frequency fall into that interval.
- Therefore the optimization reduces to trying all plausible t values and taking the minimum deletions across them.
- Practical candidate set for t: any integer from 0 up to max_freq (the maximum frequency in the original word). In practice, because there are at most 26 distinct lowercase letters, you can enumerate t as 0 and/or the distinct current frequency values (or simply 0..max_freq) without affecting performance significantly.
- For a fixed candidate t:
  - If a character's frequency f < t, it's cheaper (or necessary) to delete all f occurrences of that character (because increasing frequency is not allowed, only deletions).
  - If f is between t and t + k (inclusive), we can keep all f occurrences and need 0 deletions for that character.
  - If f > t + k, we must delete (f - (t + k)) occurrences to bring it down to t + k.
  - Sum these deletions across all characters to get the cost for this t.
- Take the minimum cost across all tried t.

Why enumeration is sufficient and correct:

- Any feasible final multiset of frequencies that satisfies the k-special property must be contained in some interval [t, t + k]. Deletions only decrease frequencies, so starting frequencies determine the only feasible outcomes. Enumerating t explores all possible intervals where the final frequencies can lie, so it finds the optimal interval.

Implementation tips and small optimizations:

- Count frequencies in O(n) by scanning the string once. There are at most 26 distinct characters, so subsequent operations over the distinct frequencies are constant-time relative to n.
- You can enumerate t by iterating either over 0..max_freq or over the sorted set of distinct frequencies plus 0. Both are fine because max_freq <= n but distinct letters <= 26, so using distinct frequencies is faster in practice and simpler to reason about.
- If you want to be explicit and safe, include 0 as a candidate t to allow the algorithm to consider deleting entire character types.
- Keep the implementation simple: build an array/list of frequencies, sort it (optional), then compute deletions for each candidate t and track the minimum.

Quick correctness/complexity note:

- Correctness: enumerating t and computing deletions as described is exhaustive and yields the optimal answer because the final frequencies must lie within some [t, t + k].
- Time: counting frequencies is O(n). The number of distinct characters is at most 26, so iterating over candidate t values and summing costs is effectively O(1) beyond the O(n) counting step; overall this is O(n) time. For implementations that loop t from 0..max_freq, worst-case time could be O(n + max_freq * 26), but max_freq <= n, and with only 26 characters the inner work is small.
