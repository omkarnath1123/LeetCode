Link: [1993. Operations on Tree](https://leetcode.com/problems/operations-on-tree/) <br>
Tag : **Medium**<br>
Lock: **Normal**

You are given a tree with `n` nodes numbered from `0` to `n - 1` in the form of a parent array `parent` where `parent[i]` is the parent of the `ith` node. The root of the tree is node `0`, so `parent[0] = -1` since it has no parent. You want to design a data structure that allows users to lock, unlock, and upgrade nodes in the tree.

The data structure should support the following functions:

-   **Lock:** **Locks** the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked.
-   **Unlock: Unlocks** the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user.
-   **Upgrade****: Locks** the given node for the given user and **unlocks** all of its descendants **regardless** of who locked it. You may only upgrade a node if **all** 3 conditions are true:
    -   The node is unlocked,
    -   It has at least one locked descendant (by **any** user), and
    -   It does not have any locked ancestors.

Implement the `LockingTree` class:

-   `LockingTree(int[] parent)` initializes the data structure with the parent array.
-   `lock(int num, int user)` returns `true` if it is possible for the user with id `user` to lock the node `num`, or `false` otherwise. If it is possible, the node `num` will become **locked** by the user with id `user`.
-   `unlock(int num, int user)` returns `true` if it is possible for the user with id `user` to unlock the node `num`, or `false` otherwise. If it is possible, the node `num` will become **unlocked**.
-   `upgrade(int num, int user)` returns `true` if it is possible for the user with id `user` to upgrade the node `num`, or `false` otherwise. If it is possible, the node `num` will be **upgraded**.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/07/29/untitled.png)
```
Input
["LockingTree", "lock", "unlock", "unlock", "lock", "upgrade", "lock"]
[[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]
Output
[null, true, false, true, true, true, false]

Explanation
LockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);
lockingTree.lock(2, 2);    // return true because node 2 is unlocked.
                           // Node 2 will now be locked by user 2.
lockingTree.unlock(2, 3);  // return false because user 3 cannot unlock a node locked by user 2.
lockingTree.unlock(2, 2);  // return true because node 2 was previously locked by user 2.
                           // Node 2 will now be unlocked.
lockingTree.lock(4, 5);    // return true because node 4 is unlocked.
                           // Node 4 will now be locked by user 5.
lockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4).
                           // Node 0 will now be locked by user 1 and node 4 will now be unlocked.
lockingTree.lock(0, 1);    // return false because node 0 is already locked.
```

**Constraints:**
-   `n == parent.length`
-   `2 <= n <= 2000`
-   `0 <= parent[i] <= n - 1` for `i != 0`
-   `parent[0] == -1`
-   `0 <= num <= n - 1`
-   `1 <= user <= 104`
-   `parent` represents a valid tree.
-   At most `2000` calls **in total** will be made to `lock`, `unlock`, and `upgrade`.

**Solution:**

- [x] [[Design]] + [[Depth First Search]]

**Intuition** :
Our `Node` data structure holds children, and id of the user who locked the node (`-1` if unlocked). We use `parent` to build the tree structure.
**Up:** we still need `parent` so we can easily go up and check if any ancestors is locked.
**Down:** use tree traverse to first check if any child node is locked, and another round to clear all locks.

```
n = is the nodes in the tree
```
**Time Complexity** : O(n)<br>
**Space Complexity** : O(n)

```java
class LockingTree {

    class TreeNode {
        int val;
        List<TreeNode> children = new LinkedList<>();
        TreeNode parent = null;
        TreeNode (int val) {
            this.val = val;
        }
    }
    Map<Integer, TreeNode> indexes = new HashMap<>();
    TreeNode root;
    
    public LockingTree(int[] parent) {
        root = new TreeNode(0);
        indexes.put(0, root);
        for (int i = 1; i < parent.length; i++) {
            indexes.putIfAbsent(parent[i], new TreeNode(parent[i]));
            indexes.putIfAbsent(i,  new TreeNode(i));
            
            TreeNode above = indexes.get(parent[i]),
                     below = indexes.get(i);
            above.children.add(below);
            below.parent = above;
        }
    }
    
    Map<Integer, Integer> locked = new HashMap<>();
    public boolean lock(int num, int user) {
        if (locked.containsKey(num)) return false;
        locked.put(num, user);
        return true;
    }
    
    public boolean unlock(int num, int user) {
        if (!locked.containsKey(num)) return false;
        if (locked.get(num) != user) return false;
        locked.remove(num);
        return true;
    }
    
    public boolean upgrade(int num, int user) {
        TreeNode node = indexes.get(num);
        TreeNode ancestor = node;
        
        while (ancestor != null) {
            if (locked.containsKey(ancestor.val)) return false;
            ancestor = ancestor.parent;
        }
        if (!hasLockedChild(node)) return false;
        if (!lock(num, user)) return false;
        
        for (TreeNode child : node.children)
            unlockChilds(child);
        return true;
    }
    private boolean hasLockedChild(TreeNode node) {
        if (node == null) return false;
        if (locked.containsKey(node.val)) return true;
        
        for (TreeNode child : node.children)
            if (hasLockedChild(child))
                return true;
        
        return false;
    }
    private void unlockChilds(TreeNode node) {
        if (node == null) return;
        
        locked.remove(node.val);
        for (TreeNode child : node.children)
             unlockChilds(child);
    }
}

/**
 * Your LockingTree object will be instantiated and called as such:
 * LockingTree obj = new LockingTree(parent);
 * boolean param_1 = obj.lock(num,user);
 * boolean param_2 = obj.unlock(num,user);
 * boolean param_3 = obj.upgrade(num,user);
 */
```
