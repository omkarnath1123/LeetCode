Link: [1029.Â Two City Scheduling](https://leetcode.com/problems/two-city-scheduling/) <br>
Tag : **Medium**<br>
Lock: **Normal**

A company is planning to interviewÂ `2n`Â people. Given the arrayÂ `costs`Â whereÂ `costs[i] = [aCosti, bCosti]`,Â the cost of flying theÂ `ith`Â person to cityÂ `a`Â isÂ `aCosti`, and the cost of flying theÂ `ith`Â person to cityÂ `b`Â isÂ `bCosti`.

ReturnÂ _the minimum cost to fly every person to a city_Â such that exactlyÂ `n`Â people arrive in each city.

**Example 1:**

```
Input: costs = [[10,20],[30,200],[400,50],[30,20]]
Output: 110
Explanation: 
The first person goes to city A for a cost of 10.
The second person goes to city A for a cost of 30.
The third person goes to city B for a cost of 50.
The fourth person goes to city B for a cost of 20.

The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.
```

**Example 2:**

```
Input: costs = [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]]
Output: 1859
```

**Example 3:**

```
Input: costs = [[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]]
Output: 3086
```

**Constraints:**
-   `2 * n == costs.length`
-   `2 <= costs.length <= 100`
-   `costs.length`Â is even.
-   `1 <= aCosti, bCostiÂ <= 1000`


## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **Cost Difference Concept:**
   - Each person must go to either city A or B
   - Difference in costs determines optimal choice
   - Need exactly n people in each city
   - Total cost minimization problem

2. **Key Insights:**
   - Sort by cost difference (A-B)
   - Negative difference favors city A
   - Positive difference favors city B
   - First n people should go to city A

### ðŸ” Edge Cases to Consider
- Minimum size (2 people)
- Maximum size (100 people)
- Equal costs for both cities
- Large cost differences
- All costs same for one city
- Maximum cost (1000)
- Alternating better choices
- Same cost differences
- Minimum cost 1

### ðŸŽ¯ Solution Approaches

1. **Greedy with Sorting**
   ```pseudo
   function twoCitySchedCost(costs):
       n = costs.length / 2
       
       # Sort by difference in costs
       sort costs by (a - b)
       
       totalCost = 0
       # First n people to city A
       for i in 0..n-1:
           totalCost += costs[i][0]
       
       # Last n people to city B
       for i in n..2n-1:
           totalCost += costs[i][1]
       
       return totalCost
   ```
   Time: O(n log n), Space: O(1)

### ðŸ“ˆ Visual Explanation
```
Example: costs = [[10,20], [30,200], [400,50], [30,20]]

Sort by A-B difference:
[30,200]   â†’ -170  (Favor A)
[10,20]    â†’ -10   (Favor A)
[30,20]    â†’ 10    (Favor B)
[400,50]   â†’ 350   (Favor B)

Assignments:
City A: [30,200], [10,20]  â†’ Cost: 40
City B: [30,20], [400,50]  â†’ Cost: 70
Total: 110
```

### ðŸ› ï¸ Implementation Tips
1. Calculate differences once
2. Handle sorting efficiently
3. Keep track of assignments
4. Use appropriate data types
5. Optimize memory usage

### ðŸ“Š Complexity Analysis
- Time Complexity: O(n log n)
  - Sorting is dominant operation
  - Rest is linear scanning
- Space Complexity: O(1)
  - In-place sorting possible
  - Only constant extra space

### ðŸ”— Related Patterns
- Greedy Algorithms
- Sorting
- Cost Minimization
- Similar Problems:
  - Task Assignment
  - Optimal Assignment
  - Minimum Cost to Hire K Workers

### ðŸ“ Example Processing Flow
```
Input: [[10,20],[30,200],[400,50],[30,20]]

1. Calculate differences:
   [10,20]   â†’ -10
   [30,200]  â†’ -170
   [400,50]  â†’ 350
   [30,20]   â†’ 10

2. Sort by difference:
   [30,200]  (-170)
   [10,20]   (-10)
   [30,20]   (10)
   [400,50]  (350)

3. Assign first half to A, second to B:
   A: 30 + 10 = 40
   B: 20 + 50 = 70

Result: 110
```

### âš ï¸ Common Mistakes to Avoid
1. Wrong sorting criteria
2. Not handling equal costs
3. Incorrect city assignment
4. Wrong difference calculation
5. Not maintaining equal distribution

```java
class Solution {
    public int twoCitySchedCost(int[][] costs) {
        // Sort by difference in costs
        Arrays.sort(costs, (a, b) -> 
            (a[0] - a[1]) - (b[0] - b[1]));
        
        int totalCost = 0;
        int n = costs.length / 2;
        
        // First n people to city A
        for (int i = 0; i < n; i++) {
            totalCost += costs[i][0];
        }
        
        // Last n people to city B
        for (int i = n; i < 2*n; i++) {
            totalCost += costs[i][1];
        }
        
        return totalCost;
    }
}
3. The difference between costs indicates preference
4. Need to balance total people in each city

### Key Insights:
1. Cost difference determines optimal assignment
2. Sort by difference to make greedy choices
3. Must maintain equal distribution
4. Early decisions affect later options

### Step-by-Step Approach:
1. **Calculate Differences**:
   - For each person: diff = cost_A - cost_B
   - Positive diff means B is cheaper
   - Negative diff means A is cheaper

2. **Sort and Assign**:
   - Sort by cost difference
   - First n people (smallest diff) go to A
   - Last n people (largest diff) go to B

### Visual Guide:
```
Example: costs = [[10,20],[30,200],[400,50],[30,20]]

Step 1: Calculate differences
[10,20]   â†’ -10 (prefers A)
[30,200]  â†’ -170 (strongly prefers A)
[400,50]  â†’ 350 (strongly prefers B)
[30,20]   â†’ 10 (prefers B)

Sort by difference:
-170: [30,200]  â†’ A (big savings)
-10:  [10,20]   â†’ A (small savings)
10:   [30,20]   â†’ B (small loss)
350:  [400,50]  â†’ B (big savings)

Result: Total = 30 + 10 + 20 + 50 = 110
```

### Edge Cases to Consider:
- Equal costs for both cities
- All prefer same city
- Extreme cost differences
- Minimum possible input (2 people)
- Maximum input size (100 people)

### Common Pitfalls:
1. Not considering cost differences
2. Wrong sorting direction
3. Unbalanced city assignments
4. Not handling equal differences

### Optimization Techniques:
1. **Sorting Optimization**:
   - Only need to track differences
   - Can use partial sort

2. **Memory Usage**:
   - In-place difference calculation
   - Avoid extra storage

### Time and Space Analysis:
- Time Complexity: O(n log n)
  - Dominated by sorting
- Space Complexity: O(1)
  - Sort in place possible

### Similar Problems:
- Task Assignment
- Minimum Cost to Hire K Workers
- Optimal Account Balancing

### Implementation Tips:
1. Sort by cost difference
2. Track assignments carefully
3. Validate equal distribution
4. Consider using custom comparator

### Useful Resources:
- [Greedy Algorithms](https://www.geeksforgeeks.org/greedy-algorithms/)
- [Sorting with Custom Comparators](https://www.baeldung.com/java-8-comparator-comparing)

Obviously, first person should fly to A, and the last - to B.

```
n = length of costs

**Time Complexity** : O(n log(n))<br>
**Space Complexity** : O(n)

```java
    public int twoCitySchedCost(int[][] costs) {
        
        PriorityQueue<Node> distance = new PriorityQueue<>();
        for (int[] cost : costs)
            distance.add(new Node(cost[0], cost[1], cost[1] - cost[0]));
        
        int min = 0, count = costs.length / 2;
        for (int i = 0; i < count; i++)
            min += distance.remove().cityTwo;
        for (int i = 0; i < count; i++)
            min += distance.remove().cityOne;
        
        return min;
    }
    class Node implements Comparable<Node> {
        int cityOne, cityTwo, diff;
        
        public Node(int cityOne, int cityTwo, int diff) {
            this.cityOne = cityOne;
            this.cityTwo = cityTwo;
            this.diff = diff;
        }
        
        @Override
        public int compareTo(Node that) {
            return Integer.compare(this.diff, that.diff);
        }
    }
```

