Link: [3218. Minimum Cost for Cutting Cake I](https://leetcode.com/problems/minimum-cost-for-cutting-cake-i/description/) <br>
Tag : **Medium**<br>
Lock: **Normal**

There is an m x n cake that needs to be cut into 1 x 1 pieces.

You are given integers m, n, and two arrays:

horizontalCut of size m - 1, where horizontalCut[i] represents the cost to cut along the horizontal line i.
verticalCut of size n - 1, where verticalCut[j] represents the cost to cut along the vertical line j.
In one operation, you can choose any piece of cake that is not yet a 1 x 1 square and perform one of the following cuts:

Cut along a horizontal line i at a cost of horizontalCut[i].
Cut along a vertical line j at a cost of verticalCut[j].
After the cut, the piece of cake is divided into two distinct pieces.

The cost of a cut depends only on the initial cost of the line and does not change.

Return the minimum total cost to cut the entire cake into 1 x 1 pieces.

 

Example 1:

```
Input: m = 3, n = 2, horizontalCut = [1,3], verticalCut = [5]

Output: 13

Explanation:
```



```
Perform a cut on the vertical line 0 with cost 5, current total cost is 5.
Perform a cut on the horizontal line 0 on 3 x 1 subgrid with cost 1.
Perform a cut on the horizontal line 0 on 3 x 1 subgrid with cost 1.
Perform a cut on the horizontal line 1 on 2 x 1 subgrid with cost 3.
Perform a cut on the horizontal line 1 on 2 x 1 subgrid with cost 3.
The total cost is 5 + 1 + 1 + 3 + 3 = 13.
```

Example 2:

```
Input: m = 2, n = 2, horizontalCut = [7], verticalCut = [4]

Output: 15

Explanation:

Perform a cut on the horizontal line 0 with cost 7.
Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost 4.
Perform a cut on the vertical line 0 on 1 x 2 subgrid with cost 4.
The total cost is 7 + 4 + 4 = 15.
```

 

Constraints:

1 <= m, n <= 20
horizontalCut.length == m - 1
verticalCut.length == n - 1
1 <= horizontalCut[i], verticalCut[i] <= 103

**Solution:**

- [x] [[Greedy]] + [[Heap]]

## Detailed Intuition

The key observation is that each time you perform a cut along one direction (horizontal or vertical), the actual cost contributed to the total is the base cost of that line multiplied by how many segments already exist in the perpendicular direction. For example, doing a horizontal cut when there are v vertical segments splits every one of those vertical strips, so the horizontal cut's base cost is paid v times.

This multiplicative effect is why a greedy strategy works: you want to perform the most expensive cuts as early as possible so they are multiplied by the smallest possible number of perpendicular segments. Concretely:

- Sort the horizontal cuts in descending order and the vertical cuts in descending order (or use two max-heaps).
- Maintain two counters: hSegments = 1 (current number of horizontal pieces) and vSegments = 1 (current number of vertical pieces).
- Always take the largest remaining cut (compare the next largest horizontal vs vertical). If it's horizontal, add cost * vSegments to the answer and increment hSegments. If it's vertical, add cost * hSegments and increment vSegments.
- Repeat until you exhaust all cuts.

Why the greedy order is optimal (sketch): consider two adjacent cuts in the execution order of different types. Suppose a larger-cost cut is placed after a smaller-cost cut of the other type. Swapping their order reduces the total cost because the larger cost will be multiplied by a smaller perpendicular-segment count after the swap, while the smaller cost will be multiplied by a larger count â€” the net change is favourable because the larger coefficient multiplies the smaller base and the larger base gets the smaller coefficient. This exchange argument shows there's no benefit to delaying a larger-cost cut of any type.

How to think about the solution (mental model): imagine the cake as a grid. Each horizontal line you cut replicates its base cost across all current vertical strips; each vertical line you cut replicates its base cost across all current horizontal strips. So the effective cost of a cut at the moment you apply it is (base cost) * (# segments perpendicular). To minimize the sum of these products, apply lines with larger base cost earlier when the perpendicular segment count is smaller.

Edge cases and practical notes:

- m = 1 and n = 1: no cuts are required; answer is 0.
- If m = 1 (so horizontalCut is empty) you only have vertical cuts; treat hSegments = 1 and process vertical cuts normally (each vertical cut cost is multiplied by hSegments = 1 at the time of application). Symmetrically if n = 1.
- Duplicate or equal costs: ties can be broken arbitrarily. If two cuts have equal base cost, processing either first gives the same final result.
- Input arrays are not guaranteed sorted, so sort them (or use priority queues) before greedy processing.
- Integer overflow: with constraints here (m,n <= 20 and costs <= 10^3) a 32-bit int is safe, but in languages or variants with larger constraints you should use a 64-bit integer (long) to accumulate the answer.
- Modulo variants: some similar problems require answers modulo 1e9+7; this problem statement does not, but check the problem specifics before applying a modulo.

Complexity notes (accurate):

- Time complexity: O(k log k) where k = (m - 1) + (n - 1) = O(m + n) due to sorting the cuts (or O(k log k) with heaps). The greedy pass after sorting is O(k).
- Space complexity: O(k) for storing and sorting the cut lists (or O(1) extra if you can sort in-place and ignore the input modification). The working counters use O(1) extra space.

Small worked example (how to reason step-by-step): take horizontal = [1,3], vertical = [5]. Sort descending -> horizontal [3,1], vertical [5]. Start hSeg = 1, vSeg = 1:
- Compare 3 vs 5: pick 5 (vertical). cost += 5 * hSeg(=1) -> 5, vSeg -> 2
- Compare 3 vs (no more vertical): pick 3 (horizontal). cost += 3 * vSeg(=2) -> +6 -> 11, hSeg -> 2
- Next pick 1 (horizontal). cost += 1 * vSeg(=2) -> +2 -> 13, done.

This matches the optimal answer and illustrates why the greedy choice of the largest remaining cut is the right decision.

```java
    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {
        
        PriorityQueue<Cut> maxHeap = new PriorityQueue<>();
        for (int cut : horizontalCut) maxHeap.add(new Cut(cut, CutType.HORIZONTAL));
        for (int cut : verticalCut) maxHeap.add(new Cut(cut, CutType.VERTICAL));

        int minCost = 0,
            verCut = 1,
            horCut = 1;
        while (!maxHeap.isEmpty()) {
            Cut top = maxHeap.remove();

            if (top.cutType == CutType.HORIZONTAL) {
                minCost = minCost + verCut * top.cost;
                horCut++;
            } else {
                minCost = minCost + horCut * top.cost;
                verCut++;
            }
        }
        return minCost;
    }
    class Cut implements Comparable<Cut> {
        int cost;
        CutType cutType;
        public Cut(int cost, CutType cutType) {
            this.cost = cost;
            this.cutType = cutType;
        }
        @Override
        public int compareTo(Cut that) {
            return -1 * Integer.compare(this.cost, that.cost);
        }
    }
    enum CutType {
        HORIZONTAL, VERTICAL;
    }
```

