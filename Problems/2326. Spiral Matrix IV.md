Link: [2326. Spiral Matrix IV](https://leetcode.com/problems/spiral-matrix-iv/description/) <br>
Tag : **Medium**<br>Lock: **Normal**

You are given two integers `m` and `n`, which represent the dimensions of a matrix.

You are also given the `head` of a linked list of integers.

Generate an `m x n` matrix that contains the integers in the linked list presented in **spiral** order **(clockwise)**, starting from the **top-left** of the matrix. If there are remaining empty spaces, fill them with `-1`.

Return _the generated matrix_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2022/05/09/ex1new.jpg)

```
Input: m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]
Output: [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]
Explanation: The diagram above shows how the values are printed in the matrix.
Note that the remaining spaces in the matrix are filled with -1.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2022/05/11/ex2.jpg)

```
Input: m = 1, n = 4, head = [0,1,2]
Output: [[0,1,2,-1]]
Explanation: The diagram above shows how the values are printed from left to right in the matrix.
The last space in the matrix is set to -1.
```

**Constraints:**

- `1 <= m, n <= 105`
- `1 <= m * n <= 105`
- The number of nodes in the list is in the range `[1, m * n]`.
- `0 <= Node.val <= 1000`

**Solution:**

- [x] [[Array]] + [[Linked-List]]

## Detailed Intuition

Goal/contract
- Input: integers m, n (dimensions) and the head of a singly-linked list of values.
- Output: an m x n matrix filled in clockwise spiral order from top-left using values from the list; any remaining cells set to -1.
- Error modes: none expected (constraints guarantee at least 1 node); but the list may be shorter than m*n.

High-level idea
- Visualize walking the perimeter (top row left->right, right column top->bottom, bottom row right->left, left column bottom->top) and progressively shrinking the active rectangle by moving the four boundaries (top, bottom, left, right) inward after you finish a side.
- Keep a pointer into the linked list. At each cell visited in spiral order, if the pointer is non-null write its value and advance; otherwise leave the cell as -1.
- Pre-filling the result matrix with -1 is convenient: it lets you avoid extra conditional fills after the loop.

Why boundary variables
- top, bottom, left, right capture the current unfilled rectangle. They prevent revisiting cells and are easy to update after finishing a side.
- After writing the top row, increment top; after writing the right column, decrement right; after writing the bottom row, decrement bottom; after writing the left column, increment left.

Termination and loop condition — the subtle bit
- The naive loop condition is while (top <= bottom && left <= right) which ensures the rectangle is non-empty. However you must also check the linked-list pointer (head) inside the inner loops to stop filling when values run out.
- Some implementations use while (top <= bottom || left <= right) together with pointer checks inside each directional loop. That works too but is more permissive; the inner bounds checks ensure you don't write out of range. Either approach is fine as long as each directional loop both checks the current boundary range (e.g., i <= right) and whether head != null before writing.
- Always check head != null at the start of each directional traversal and inside the loop so you stop immediately when values are exhausted — this prevents unnecessary boundary updates that could make later traversals invalid.

Edge cases and how to think about them
- m == 1 (single row): You only traverse the top row left->right once. The right/left boundary updates should quickly make further directional loops skip. Pre-filling with -1 gives correct remaining cells.
- n == 1 (single column): You only traverse top->bottom once (right column in general code). Similar reasoning as single row.
- m * n == 1 (1x1): The matrix has exactly one cell — fill it with the first list node or -1 if the list were empty (not allowed here by constraints but good to consider if generalizing).
- list length == m*n: The algorithm should fill every cell and stop with head == null exactly as boundaries meet; ensure no extra writes are attempted after head becomes null.
- list length < m*n: Remaining cells must stay -1 — pre-filling handles this automatically. Key is never to overwrite -1 unless head has a value.
- list length == 1: Only the first visited cell receives the node's value. Confirm directional loops check head before writing further cells.
- When the list runs out in the middle of a side: You must stop filling immediately and not continue to update boundaries in a way that causes invalid reads/writes later. For example, if you stop during filling the top row because head becomes null, still increment top (because that top row is considered processed); this is safe because you won't write more without checking head. An alternative is to only update the corresponding boundary if you actually completed that side; either choice is correct if implemented consistently with the head checks.
- Very long single dimension (e.g., m=1, n large): Performance is still O(m*n) and memory is O(m*n) for the output matrix; ensure loops iterate the expected number of times and you don't do expensive per-cell operations beyond constant-time writes.

How to reason step-by-step when designing the code
1. Create result array m x n and initialize every cell to -1. This simplifies handling of leftover cells.
2. Set four pointers: top = 0, bottom = m-1, left = 0, right = n-1.
3. While the list still has values and the active rectangle is non-empty, traverse the four sides in order, always checking both the boundary condition and whether the list pointer is non-null before writing a cell.
4. After finishing each side, move the corresponding boundary inward. Be mindful that after updating boundaries you must not run the next side if the rectangle has collapsed; hence always check the loop condition and head truthiness before each side.
5. Return the result.

Complexity
- Time: O(m * n) in the worst case — each cell is written at most once.
- Space: O(m * n) for the output matrix; extra space O(1) besides the output (just a few pointers and the list iterator).

Quality gates / testing
- Build simple tests that exercise the edge cases above (single row, single column, single cell, list shorter than matrix, exact fill). These confirm the loop/termination logic and that leftover cells remain -1.

```java
    public int[][] spiralMatrix(int m, int n, ListNode head) {
        
        int[][] res = new int[m][n];
        int top = 0,
            bottom = m - 1,
            left = 0,
            right = n - 1;
        
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                res[i][j] = -1;
        ListNode iter = head;

        while (top <= bottom || left <= right) {
            
            for (int i = left; iter != null && i <= right; i++) {
                res[top][i] = iter.val;
                iter = iter.next;
            }
            top++;

            for (int i = top; iter != null && i <= bottom; i++) {
                res[i][right] = iter.val;
                iter = iter.next;
            }
            right--;

            for (int i = right; iter != null && i >= left; i--) {
                res[bottom][i] = iter.val;
                iter = iter.next;
            }
            bottom--;

            for (int i = bottom; iter != null && i >= top; i--) {
                res[i][left] = iter.val;
                iter = iter.next;
            }
            left++;
        }
        return res;
    }
```
