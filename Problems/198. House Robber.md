Link: [198. House Robber](https://leetcode.com/problems/house-robber/description/) <br>
Tag : **Medium**<br>
Lock: **Normal**

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

**Example 2:**

```
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
```

**Constraints:**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

**Solution:**

- [x] [[Dynamic Programming]]

## Detailed Intuition

Think of each house as a binary choice: either you rob it or you skip it. Robbing a house prevents you from robbing its immediate neighbor, so the decision for house i depends only on decisions made up to i-1 and i-2. This gives a simple dynamic programming recurrence.

Define dp[i] as the maximum amount of money you can rob from the first (i + 1) houses (i.e., houses indexed 0..i) when considering house i as the rightmost house in that prefix. The recurrence is:

- Base cases:
  - dp[0] = nums[0]
  - dp[1] = max(nums[0], nums[1])
- For i >= 2:
  - dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])

Intuition behind the recurrence:
- If you skip house i, the best you can do is dp[i - 1].
- If you rob house i, you cannot rob house i - 1, so the best is dp[i - 2] + nums[i].
- The optimal solution for dp[i] is the better of these two choices.

How to think about solving the problem:
- Work left-to-right, computing the best result for each prefix using only previously computed values. That ensures optimal substructure and avoids repeated work (overlapping subproblems).
- This is not a greedy problem: locally choosing the larger of two adjacent houses can fail because it ignores how that choice affects future houses. DP captures the global effect.
- You can implement dp directly with an array (O(n) space) or keep just two variables (prev and prev2) and update them in a loop to achieve O(1) space.

Walk-through example (nums = [2, 7, 9, 3, 1]):
- dp[0] = 2
- dp[1] = max(2, 7) = 7
- dp[2] = max(dp[1], dp[0] + 9) = max(7, 11) = 11
- dp[3] = max(dp[2], dp[1] + 3) = max(11, 10) = 11
- dp[4] = max(dp[3], dp[2] + 1) = max(11, 12) = 12
So the answer is 12 (rob houses with amounts 2, 9, and 1).

Space optimization tip:
- Instead of storing the whole dp array you can store two integers: prev (dp[i - 1]) and prev2 (dp[i - 2]). For each i compute curr = max(prev, prev2 + nums[i]); then set prev2 = prev; prev = curr. This yields O(1) extra space.

Reconstructing which houses were robbed:
- If you need the actual indices chosen, you can keep an extra boolean/choice array or store predecessors while computing dp and backtrack from the last house.

Edge cases and how to think about them:
- Single house (length == 1): return nums[0]. This is handled by the dp base case.
- Two houses (length == 2): return max(nums[0], nums[1]). Handled by dp base cases.
- All zeros: result should be 0; the recurrence handles this naturally.
- Equal values and alternating choices: DP correctly chooses the optimal alternating subset.
- Very large values / overflow: given constraints here ints are safe, but in other contexts use a larger type (long) if values or counts can overflow 32-bit.
- Input constraints: the problem guarantees at least one house (no empty array). If the input could be empty in other contexts, return 0.
- Requiring the actual choice set: maintain extra metadata to reconstruct selections; the standard dp only returns the total value.

Why this is optimal:
- The recurrence compares the only two valid alternatives at each house (rob or skip) and uses previously computed optimal results for smaller prefixes. That satisfies optimal substructure and ensures a global optimum.

This description complements the code below (which implements the dp array version). If you prefer a constant-space implementation, replace the dp array with two integer variables as described above.

```java
    public int rob(int[] nums) {
        
        int length = nums.length;
        if (length == 1) return nums[0];
        int[] money = new int[length];
        money[0] = nums[0];
        money[1] = Math.max(nums[0], nums[1]);

        for (int i = 2; i < length; i++)
            money[i] = Math.max(money[i - 1], money[i - 2] + nums[i]);
        return money[length - 1];
    }
```
