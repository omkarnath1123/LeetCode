Link: [27. Remove Element](https://leetcode.com/problems/remove-element/description/) <br>
Tag : **Easy**<br>
Lock: **Normal**

Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm). The order of the elements may be changed. Then return _the number of elements in_ `nums` _which are not equal to_ `val`.

Consider the number of elements in `nums` which are not equal to `val` be `k`, to get accepted, you need to do the following things:

- Change the array `nums` such that the first `k` elements of `nums` contain the elements which are not equal to `val`. The remaining elements of `nums` are not important as well as the size of `nums`.
- Return `k`.

**Custom Judge:**

The judge will test your solution with the following code:

```
int[] nums = [...]; // Input array
int val = ...; // Value to remove
int[] expectedNums = [...]; // The expected answer with correct length.
                            // It is sorted with no values equaling val.

int k = removeElement(nums, val); // Calls your implementation

assert k == expectedNums.length;
sort(nums, 0, k); // Sort the first k elements of nums
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```

If all assertions pass, then your solution will be **accepted**.

**Example 1:**

```
Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2,_,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

**Example 2:**

```
Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5, nums = [0,1,4,0,3,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

**Constraints:**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

**Solution:**

- [x] [[Two Pointer]]

## Detailed Intuition

Goal: remove all occurrences of val from nums in-place and return k, the count of elements not equal to val, while using only O(1) extra space and O(n) time.

High-level idea (two-pointer / slow-fast):
- Use a "write" pointer (slow) starting at index 0 to mark the next position where a kept value should go, and a "read" pointer (fast) that scans the array from left to right.
- Maintain the invariant: before processing index fast, all elements at indices [0 .. slow-1] are values we want to keep (they are != val).
- For each element nums[fast]: if nums[fast] != val, write it into nums[slow] (nums[slow] = nums[fast]) and increment slow. If nums[fast] == val, just skip it.
- After the loop finishes, slow equals k (the number of kept elements) and the first k elements of nums are the elements != val.

Why this works (correctness and invariants):
- We never lose a keepable element because we only write to nums[slow] when we've already inspected nums[fast] and decided to keep it.
- Each element is inspected exactly once by the fast pointer. Every kept element causes exactly one write to the slow position, so the algorithm is linear time.
- The order among the kept elements is preserved when using overwrite (nums[slow] = nums[fast]); using swaps may change order but the problem doesn't require order to be preserved.

Implementation notes (overwrite vs swap):
- Overwrite variant (recommended and simple):
  if (nums[fast] != val) nums[slow++] = nums[fast];
  This avoids an unnecessary temporary variable and minimizes writes to only kept elements.
- Swap variant (works but unnecessary here): swapping nums[slow] and nums[fast] keeps original values in the tail, but the judge ignores elements beyond the first k, so swapping gives no benefit and uses an extra temporary variable.

Step-by-step example (nums = [3,2,2,3], val = 3):
1. slow=0, fast=0: nums[0] == 3 -> skip.
2. fast=1: nums[1] == 2 -> nums[0] = 2, slow -> 1. Array becomes [2,2,2,3].
3. fast=2: nums[2] == 2 -> nums[1] = 2, slow -> 2.
4. fast=3: nums[3] == 3 -> skip.
End: return slow == 2; first two elements are the kept values.

Edge cases to consider and how to think about them:
- Empty array (nums.length == 0): loop body never runs, return 0.
- All elements equal to val: slow remains 0; return 0. The array contents beyond the first k are irrelevant.
- No elements equal to val: slow increments for each element, return nums.length; the array's first k elements are the original values.
- Single-element array: works for both cases (equal to val -> 0, different -> 1).
- val appears at the start, middle, or end: the algorithm treats all positions uniformly.
- Duplicates and repeated values: algorithm doesn't depend on uniqueness; duplicates are kept or removed correctly.
- Small vs large k: performance is always O(n); only the number of writes equals k in the overwrite approach.

When to consider alternative two-pointer variants:
- If you want to minimize writes when val is rare, you could use a left pointer scanning forward and a right pointer from the end, swapping val elements to the tail. This reduces writes but doesn't preserve order and is more complex. For this problem, the overwrite slow-fast is the simplest and fastest in practice.

Complexity recap:
- Time: O(n) — each element is visited once by the fast pointer.
- Space: O(1) extra space — only a couple of integer variables are used; the input array is modified in-place.

Quick testing checklist (manual cases to validate your implementation):
- nums = [], val = 0 -> expected k = 0
- nums = [1,1,1], val = 1 -> expected k = 0
- nums = [1,2,3], val = 4 -> expected k = 3
- nums = [2,2,3,2], val = 2 -> expected k = 1 (kept element 3)
- nums = [3,2,2,3], val = 3 -> expected k = 2 (kept values [2,2])

```java
    public int removeElement(int[] nums, int val) {
        
        int one = 0,
            length = nums.length,
            temp;
        for (int two = 0; two < length; two++) {
            if (nums[two] != val) {
                temp = nums[one];
                nums[one] = nums[two];
                nums[two] = temp;
                one++;
            }
        }
        return one;
    }
```