Link: [1259. Handshakes That Don't Cross](https://leetcode.com/problems/handshakes-that-dont-cross/) <br>
Tag : **Hard**<br>
Lock: **Premium**

You are given an **even** number of people `numPeople` that stand around a circle and each person shakes hands with someone else so that there are `numPeople / 2` handshakes total.

Return _the number of ways these handshakes could occur such that none of the handshakes cross_.

Since the answer could be very large, return it **modulo** `109 + 7`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/07/11/5125_example_2.png)
```
Input: numPeople = 4
Output: 2
Explanation: There are two ways to do it, the first way is [(1,2),(3,4)] and the second one is [(2,3),(4,1)].
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2019/07/11/5125_example_3.png)
```
Input: numPeople = 6
Output: 5
```

**Constraints:**
-   `2 <= numPeople <= 1000`
-   `numPeople` is even.

## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **Catalan Number Pattern:**
   - Non-crossing matchings follow Catalan numbers
   - Break down into smaller subproblems
   - Each valid state leads to more valid states
   - Similar to balanced parentheses

2. **Key Insights:**
   - Focus on one person's handshake first
   - This splits problem into two subproblems
   - Number of ways multiplies (independent choices)
   - Solutions build up recursively

### ðŸ” Edge Cases to Consider
- Minimum case (2 people)
- Maximum case (1000 people)
- Powers of 2
- Large numbers (modulo needed)
- Even numbers only
- Perfect squares
- Numbers divisible by 4
- Large factorials

### ðŸŽ¯ Solution Approaches

1. **Dynamic Programming with Catalan Numbers**
   ```pseudo
   function numberOfWays(numPeople):
       n = numPeople / 2  # number of pairs
       MOD = 1000000007
       dp = new long[n + 1]
       dp[0] = 1
       
       for i in range(1, n + 1):
           for j in range(i):
               dp[i] = (dp[i] + dp[j] * dp[i-1-j]) % MOD
       
       return dp[n]
   ```
   Time: O(nÂ²), Space: O(n)

2. **Direct Catalan Formula** (less practical due to large numbers)
   ```pseudo
   function catalanNumber(n):
       # C(n) = (2n)! / (n+1)!n!
       # But need modulo arithmetic
       return combination(2*n, n) / (n + 1)
   ```

### ðŸ“ˆ Visual Explanation
```
Example: numPeople = 4 (n = 2 pairs)

Person 1 can shake hands with:
   1---2    3---4
   1   2    3   4
    \ /      \ /
     X        X
    / \      / \
   4   3    2   1

Base cases:
dp[0] = 1 (empty circle)
dp[1] = 1 (one pair)

Building dp[2]:
- Left pairs Ã— Right pairs
- dp[0]Ã—dp[1] + dp[1]Ã—dp[0] = 1Ã—1 + 1Ã—1 = 2
```

### ðŸ› ï¸ Implementation Tips
1. Use long for calculations
2. Apply modulo at each step
3. Handle pairs not individuals
4. Initialize base cases properly
5. Use efficient modular arithmetic

### ðŸ“Š Complexity Analysis
- Time Complexity: O(nÂ²)
  - Nested loops for DP solution
  - Each state needs all previous states
- Space Complexity: O(n)
  - Single array for DP states
  - Can optimize to O(1) for just last result

### ðŸ”— Related Patterns
- Catalan Numbers
- Dynamic Programming
- Combinatorics
- Similar Problems:
  - Unique Binary Search Trees
  - Valid Parentheses
  - Different Ways to Add Parentheses

### ðŸ“ Example Processing Flow
```
Input: numPeople = 6 (n = 3 pairs)

DP Table Building:
dp[0] = 1 (base case)
dp[1] = 1 (one pair)
dp[2] = dp[0]Ã—dp[1] + dp[1]Ã—dp[0] = 2
dp[3] = dp[0]Ã—dp[2] + dp[1]Ã—dp[1] + dp[2]Ã—dp[0] = 5

Final Ways:
1. [(1,2),(3,4),(5,6)]
2. [(1,6),(2,3),(4,5)]
3. [(1,4),(2,3),(5,6)]
4. [(1,6),(2,5),(3,4)]
5. [(1,2),(3,6),(4,5)]
```

### âš ï¸ Common Mistakes to Avoid
1. Not using modulo arithmetic
2. Integer overflow in calculations
3. Wrong base cases
4. Not considering pairs properly
5. Inefficient combinatorial calculations

```java
public int numberOfWays(int numPeople) {
    int n = numPeople / 2;  // number of pairs
    long[] dp = new long[n + 1];
    int MOD = 1_000_000_007;
    
    dp[0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            dp[i] = (dp[i] + dp[j] * dp[i-1-j]) % MOD;
        }
    }
    
    return (int)dp[n];
}
```

![Non-crossing Handshakes](https://assets.leetcode.com/uploads/2019/07/11/5125_example_2.png)
    int mod = (int) Math.pow(10, 9) + 7;
    Map<Integer, Integer> cache;
    public int numberOfWays(int numPeople) {
        if (numPeople == 0 || numPeople % 2 == 1)
            return 0;
        
        cache = new HashMap<>();
        return backTrack(numPeople / 2);
    }
    private int backTrack(int pairs) {
        if (pairs == 1 || pairs == 0) return 1;
        if (cache.containsKey(pairs)) return cache.get(pairs);
        
        long comb = 0;
        for (int i = 0; i < pairs; i++)
            comb = (comb + ((long)(backTrack(i)) * backTrack(pairs - i - 1)) % mod) % mod;
        
        cache.put(pairs, (int) comb);
        return (int) comb;
    }
```


- [ ] [[Utils/Dynamic Programming]] + [[Bottom-Up Solution]]
