Link: [1166.Â Design File System](https://leetcode.com/problems/design-file-system/) <br>
Tag : **Medium**<br>
Lock: **Premium**

You are asked to design a file systemÂ that allows you to create new paths and associate them with different values.

The format of a path isÂ one or more concatenated strings of the form:Â `/`Â followed by one or more lowercase English letters. For example, "`/leetcode"`Â and "`/leetcode/problems"`Â are valid paths while an emptyÂ stringÂ `""`Â andÂ `"/"`Â are not.

Implement theÂ `FileSystem`Â class:

-   `bool createPath(string path, int value)`Â Creates a newÂ `path`Â and associates aÂ `value`Â to it if possible and returnsÂ `true`.Â ReturnsÂ `false`Â if the pathÂ **already exists**Â or its parent pathÂ **doesn't exist**.
-   `int get(string path)`Â Returns the value associated withÂ `path`Â or returnsÂ `-1`Â if the path doesn't exist.

**Example 1:**
```
Input: 
["FileSystem","createPath","get"]
[[],["/a",1],["/a"]]
Output: 
[null,true,1]
Explanation: 
FileSystem fileSystem = new FileSystem();

fileSystem.createPath("/a", 1); // return true
fileSystem.get("/a"); // return 1
```

**Example 2:**
```
Input: 
["FileSystem","createPath","createPath","get","createPath","get"]
[[],["/leet",1],["/leet/code",2],["/leet/code"],["/c/d",1],["/c"]]
Output: 
[null,true,true,2,false,-1]
Explanation: 
FileSystem fileSystem = new FileSystem();

fileSystem.createPath("/leet", 1); // return true
fileSystem.createPath("/leet/code", 2); // return true
fileSystem.get("/leet/code"); // return 2
fileSystem.createPath("/c/d", 1); // return false because the parent path "/c" doesn't exist.
fileSystem.get("/c"); // return -1 because this path doesn't exist.
```

**Constraints:**
-   The number ofÂ calls to the two functionsÂ is less than or equal toÂ `104`Â in total.
-   `2 <= path.length <= 100`
-   `1 <= value <= 109`

## Detailed Intuition

### ğŸ’¡ How to Think About the Solution

1. **File System Structure Concept:**
   - Paths form a tree-like structure
   - Each path has a value associated
   - Need to validate parent paths
   - Similar to actual file system design

2. **Key Insights:**
   - Use Trie/Tree structure for paths
   - Store values at nodes
   - Must check parent existence
   - Path validation is crucial

### ğŸ” Edge Cases to Consider
- Empty path
- Single character path
- Long nested paths
- Non-existent parent
- Duplicate paths
- Root path "/"
- Maximum path length (100)
- Maximum value (10^9)
- Invalid path format
- Concurrent path creation

### ğŸ¯ Solution Approaches

1. **HashMap with Path Validation**
   ```pseudo
   class FileSystem:
       def __init__(self):
           self.paths = {}  # path -> value
       
       def createPath(self, path, value):
           # Invalid path checks
           if not path or path == "/" or path in self.paths:
               return false
           
           # Get parent path
           parent = path[:path.rindex("/")]
           if parent and parent not in self.paths:
               return false
           
           self.paths[path] = value
           return true
       
       def get(self, path):
           return self.paths.get(path, -1)
   ```
   Time: O(L) for operations, Space: O(NÃ—L)
   where L = path length, N = number of paths

2. **Trie-based Approach**
   ```pseudo
   class TrieNode:
       def __init__(self):
           self.children = {}
           self.value = -1
           self.isFile = false
   
   class FileSystem:
       def __init__(self):
           self.root = TrieNode()
       
       def createPath(self, path, value):
           components = path.split("/")[1:]
           node = self.root
           
           # Check parent path exists
           for i in range(len(components)-1):
               if components[i] not in node.children:
                   return false
               node = node.children[components[i]]
           
           # Create new path
           last = components[-1]
           if last in node.children:
               return false
               
           node.children[last] = TrieNode()
           node.children[last].value = value
           node.children[last].isFile = true
           return true
   ```
   Time: O(L), Space: O(NÃ—L)

### ğŸ“ˆ Visual Explanation
```
Example File System:
/
â”œâ”€â”€ leet (1)
â”‚   â””â”€â”€ code (2)
â””â”€â”€ a (1)

Operations:
1. createPath("/leet", 1)
   - Check parent "/" exists âœ“
   - Create "leet" with value 1

2. createPath("/leet/code", 2)
   - Check parent "/leet" exists âœ“
   - Create "code" with value 2

3. createPath("/c/d", 1)
   - Check parent "/c" exists âœ—
   - Return false
```

### ğŸ› ï¸ Implementation Tips
1. Validate path format
2. Split path components efficiently
3. Cache parent paths
4. Use proper data structures
5. Handle concurrent access (if needed)

### ğŸ“Š Complexity Analysis
- Time Complexity:
  - createPath: O(L) to validate path
  - get: O(1) for HashMap, O(L) for Trie
- Space Complexity: O(NÃ—L)
  - N = number of paths
  - L = average path length

### ğŸ”— Related Patterns
- Tree/Trie Data Structure
- Path Processing
- System Design
- Similar Problems:
  - Design In-Memory File System
  - Design Add and Search Words
  - Implement Trie

### ğŸ“ Example Processing Flow
```
Input: ["FileSystem","createPath","createPath","get"]
       [[],["/leet",1],["/leet/code",2],["/leet/code"]]

1. Initialize:
   paths = {}
   
2. createPath("/leet", 1):
   - Validate path format âœ“
   - Check parent exists âœ“
   - Add to paths âœ“
   Return: true

3. createPath("/leet/code", 2):
   - Validate path âœ“
   - Check parent "/leet" exists âœ“
   - Add to paths âœ“
   Return: true

4. get("/leet/code"):
   - Return value 2
```

### âš ï¸ Common Mistakes to Avoid
1. Not validating path format
2. Missing parent path check
3. Incorrect path splitting
4. Memory leaks in tree structure
5. Inefficient path traversal
- [x] [[Trie]]

**Intuition** :
1.  The basic data structure that is used for representing a Trie is a dictionary. The dictionary and other potential flags/data values can be a part of a customÂ `TreeNode`Â data structure. For this problem, we will have aÂ `TrieNode`Â data structure that will contain three things 1. The string representing the path name. 2. The value corresponding to this path. 3. And finally, a dictionary representing the outgoing connections to otherÂ `TrieNodes`.
2.  The root of our trie will be aÂ `TrieNode`Â containing the empty string.
    
3.  _Create()_Â ~
    
    1.  First, we will split the given path into various components usingÂ `/`Â as the delimiter. So for the pathÂ `/a/b/c`, we will have four components namelyÂ ,Â `a`,Â `b`, andÂ `c`.
        
        ![HashMap](https://leetcode.com/problems/design-file-system/Figures/1166/img3.png)
        _Figure 3. Let's consider an example Trie._
        
    2.  Initialize aÂ `TrieNode`Â calledÂ `curr`Â which will be equal to the root node of the trie. Note that we always start at the root node and then go down based on the various path components.
        
        ![HashMap](https://leetcode.com/problems/design-file-system/Figures/1166/img4.png)
        _Figure 4. Initialize the "curr" node._
        
    3.  We will iterate over all of these components and for each of them, we will do the following:
        1.  Check if the component exists inÂ `curr`'s dictionary . If it doesn't we return false unless it is the last component of the path in which case we add it to the current dictionary.
        2.  If the current component exists in theÂ `curr`Â node, we obtain the value which will be anotherÂ `TrieNode`Â and updateÂ `curr`Â to be equal to that node.            
        3.  Eventually, we will process the last component of the path. If that exists in the trie as well, we returnÂ `false`Â in accordance with the problem statement. Else, we add it to the trie by creating a new node with path asÂ `path`Â and value asÂ `value`Â i.e. the input parameters.
            
            ![HashMap](https://leetcode.com/problems/design-file-system/Figures/1166/img5.png)
            _Figure 5. Add the last component to the Trie._
            
4.  _Get()_Â ~
    
    1.  To check if a path exists in the trie, we need to verify if all its components, along with the proper connections exist in the trie.
    2.  Split the given path into various components usingÂ `/`Â as the delimiter.
    3.  Initialize aÂ `TrieNode`Â calledÂ `curr`Â which will be equal to the root node of the trie.
    4.  We will iterate over all of these components and for each of them, we will do the following:
        1.  Check if the component exists inÂ `curr`'s dictionary .
        2.  If the current component exists in theÂ `curr`Â node, we obtain the value which will be anotherÂ `TrieNode`Â and updateÂ `curr`Â to be equal to that node.
        3.  If it doesn't exist, we returnÂ `false`.
    5.  ReturnÂ `true`.

```
n = is length of path

**Time Complexity** : O(n) for each query<br>
**Space Complexity** : O(n)

```java
class FileSystem {

    class TrieNode {
        Map<String, TrieNode> path = new HashMap<>();
        Integer val = null;
        TrieNode () {}
        TrieNode (Integer val) {
            this.val = val;
        }
    }
    TrieNode root;
    public FileSystem() {
        root = new TrieNode();
    }
    
    public boolean createPath(String path, int value) {
        String[] dirs = path.split("/");
        int len = dirs.length;
        
        TrieNode iter = root;
        for (int i = 1; i < len - 1; i++) {
            String dir = dirs[i];
            iter = iter.path.get(dir);
            if (iter == null) return false;
        }
        if (iter.path.containsKey(dirs[len - 1])) return false;
        iter.path.put(dirs[len - 1], new TrieNode(value));
        return true;
    }
    
    public int get(String path) {
        TrieNode iter = root;
        String[] dirs = path.split("/");
        int len = dirs.length;
        for (int i = 1; i < len; i++) {
            iter = iter.path.get(dirs[i]);
            if (iter == null) return -1;
        }
        return iter.val;
    }
}

/**
 * Your FileSystem object will be instantiated and called as such:
 * FileSystem obj = new FileSystem();
 * boolean param_1 = obj.createPath(path,value);
 * int param_2 = obj.get(path);
 */
```
