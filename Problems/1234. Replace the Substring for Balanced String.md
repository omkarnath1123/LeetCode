Link: [1234. Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/) <br>
Tag : **Medium**<br>
Lock: **Normal**

You are given a string s of length `n` containing only four kinds of characters: `'Q'`, `'W'`, `'E'`, and `'R'`.

A string is said to be **balanced** if each of its characters appears `n / 4` times where `n` is the length of the string.

Return _the minimum length of the substring that can be replaced with **any** other string of the same length to make_ `s` _**balanced**_. If s is already **balanced**, return `0`.

**Example 1:**
```
Input: s = "QWER"
Output: 0
Explanation: s is already balanced.
```

**Example 2:**
```
Input: s = "QQWE"
Output: 1
Explanation: We need to replace a 'Q' to 'R', so that "RQWE" (or "QRWE") is balanced.
```

**Example 3:**
```
Input: s = "QQQW"
Output: 2
Explanation: We can replace the first "QQ" to "ER". 
```

**Constraints:**
-   `n == s.length`
-   `4 <= n <= 105`
-   `n` is a multiple of `4`.
-   `s` contains only `'Q'`, `'W'`, `'E'`, and `'R'`.


## Detailed Intuition

### üí° How to Think About the Solution

1. **Balanced String Concept:**
   - String length n is multiple of 4
   - Each character should appear exactly n/4 times
   - Can replace any substring with same length
   - Need minimum length replacement

2. **Key Insights:**
   - Focus on characters outside window
   - Window represents replacement substring
   - Valid if remaining chars ‚â§ n/4 each
   - Minimize window size while maintaining validity

### üîç Edge Cases to Consider
- Already balanced string
- Minimum length (4)
- Maximum length (10^5)
- All same character
- Alternating characters
- Exactly n/4 of each
- One character dominant
- Equal distribution
- Multiple valid solutions
- Minimum possible window

### üéØ Solution Approaches

1. **Sliding Window with Count Tracking**
   ```pseudo
   function balancedString(s):
       n = s.length
       target = n/4
       count = Counter(s)  # frequency of each char
       
       if all counts == target:
           return 0
           
       result = n
       left = 0
       
       for right in 0..n-1:
           count[s[right]]--
           
           while left <= right and 
                 all counts[c] <= target for c in 'QWER':
               result = min(result, right - left + 1)
               count[s[left]]++
               left++
       
       return result
   ```
   Time: O(n), Space: O(1)

### üìà Visual Explanation
```
Example: s = "QQQW" (n=4, target=1)
Initial counts: Q=3, W=1, E=0, R=0

Window progression:
[Q]QQW   counts: Q=2,W=1,E=0,R=0  (invalid)
[QQ]QW   counts: Q=1,W=1,E=0,R=0  (invalid)
[QQQ]W   counts: Q=0,W=1,E=0,R=0  (valid)
[QQ]QW   counts: Q=1,W=1,E=0,R=0  (invalid)

Minimum valid window: 2
Can replace "QQ" with "ER"
```

### üõ†Ô∏è Implementation Tips
1. Use array for character counts
2. Check all characters for validity
3. Handle window boundaries carefully
4. Pre-calculate target frequency
5. Update counts efficiently

### üìä Complexity Analysis
- Time Complexity: O(n)
  - Single pass through string
  - Constant work per character
- Space Complexity: O(1)
  - Fixed size count array (4 chars)
  - Independent of input size

### üîó Related Patterns
- Sliding Window
- Frequency Counting
- Two Pointers
- Similar Problems:
  - Minimum Window Substring
  - Permutation in String
  - Longest Repeating Character Replacement

### üìù Example Processing Flow
```
Input: s = "QQWE"
Target frequency = 1 (4/4)

1. Initial counts:
   Q=2, W=1, E=1, R=0

2. Window movement:
   [Q]QWE: Q>1 outside (invalid)
   [QQ]WE: Q=0 outside (valid)
   Stop - found minimum window

Result: 1 (replace 'Q' with 'R')
```

### ‚ö†Ô∏è Common Mistakes to Avoid
1. Wrong target frequency calculation
2. Incorrect window validation
3. Missing character updates
4. Wrong boundary conditions
5. Inefficient count checking

```java
class Solution {
    public int balancedString(String s) {
        int[] count = new int[128];
        int n = s.length();
        int target = n / 4;
        
        // Count initial frequencies
        for (char c : s.toCharArray()) {
            count[c]++;
        }
        
        // Check if already balanced
        if (count['Q'] == target && count['W'] == target &&
            count['E'] == target && count['R'] == target) {
            return 0;
        }
        
        int left = 0, result = n;
        
        // Slide window
        for (int right = 0; right < n; right++) {
            count[s.charAt(right)]--;
            
            while (left <= right && 
                   count['Q'] <= target && count['W'] <= target &&
                   count['E'] <= target && count['R'] <= target) {
                result = Math.min(result, right - left + 1);
                count[s.charAt(left)]++;
                left++;
            }
        }
        
        return result;
    }
}
2. The substring we replace can fix multiple imbalances at once
3. Characters outside our window must be ‚â§ n/4 for each type

### Step-by-Step Approach:
1. **Count Initial Frequencies**:
   - Count occurrences of each character
   - Calculate target frequency (n/4)
   - Identify excess characters

2. **Sliding Window Strategy**:
   - Window represents substring to replace
   - Check if counts outside window are valid
   - Minimize window size while maintaining validity

### Visual Guide:
```
Example: s = "QQQW", n = 4, target = n/4 = 1

Initial counts:
Q: 3 (excess: 2)
W: 1 (balanced)
E: 0 (deficit: 1)
R: 0 (deficit: 1)

Window sliding:
Q[QQ]W
   ‚Üë
Can replace with "ER" to balance

Valid solution because:
- Q outside window = 1 (‚â§ target)
- Other chars can be added in window
```

### Edge Cases to Consider:
- Already balanced string
- All same characters
- Minimum possible length (4)
- Very large strings
- Multiple valid solutions

### Common Pitfalls:
1. Focusing on window contents instead of outside
2. Not considering all characters simultaneously
3. Wrong calculation of target frequency
4. Not minimizing window size properly

### Optimization Techniques:
1. **Early Termination**:
   - Return 0 if already balanced
   - Skip windows that can't be valid

2. **Efficient Counting**:
   - Use array/map for O(1) lookups
   - Update counts while sliding

### Time and Space Analysis:
- Time Complexity: O(n) where n is string length
- Space Complexity: O(1) - fixed size array for QWER

### Similar Problems:
- Minimum Window Substring
- Longest Substring Without Repeating Characters
- Permutation in String

### Useful Resources:
- [Sliding Window Pattern](https://leetcode.com/discuss/general-discussion/657507/sliding-window-for-beginners-problems)
- [String Manipulation Techniques](https://www.geeksforgeeks.org/string-data-structure/)
Then slide the windon in the string `s`.

Imagine that we erase all character inside the window,  
as we can modyfy it whatever we want,  
and it will always increase the count outside the window.

So we can make the whole string balanced,  
as long as `max(count[Q],count[W],count[E],count[R]) <= n / 4`.

```
n = is the length of stations

**Time Complexity** : O(n)<br>
**Space Complexity** : O(n)

```java
    public int balancedString(String s) {
        
        int len = s.length(),
            balance = len / 4,
            start = 0,
            minLen = len;
        int[] freq = new int[26];
        
        for (char ch : s.toCharArray())
            freq[ch - 'A']++;
        
        for (int end = 0; end < len; end++) {
            int index = s.charAt(end) - 'A';
            freq[index]--;
            
            while (start < len && 
                   freq['Q' - 'A'] <= balance && 
                   freq['W' - 'A'] <= balance && 
                   freq['E' - 'A'] <= balance && 
                   freq['R' - 'A'] <= balance) {
                index = s.charAt(start) - 'A';
                minLen = Math.min(minLen, end - start + 1);
                freq[index]++;
                start++;
            }
        }
        return minLen;
    }
```
