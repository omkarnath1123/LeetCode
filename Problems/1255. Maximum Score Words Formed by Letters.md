Link: [1255. Maximum Score Words Formed by Letters](https://leetcode.com/problems/maximum-score-words-formed-by-letters/) <br>
Tag : **Hard**<br>
Lock: **Normal**

Given a list of `words`, list ofÂ  singleÂ `letters` (might be repeating)Â and `score`Â of every character.

Return the maximum score of **any** valid set of words formed by using the given letters (`words[i]` cannot be used twoÂ or more times).

It is not necessary to use all characters in `letters` and each letter can only be used once. Score of lettersÂ `'a'`, `'b'`, `'c'`, ... ,`'z'` is given byÂ `score[0]`, `score[1]`, ... , `score[25]` respectively.

**Example 1:**
```
Input: words = ["dog","cat","dad","good"], letters = ["a","a","c","d","d","d","g","o","o"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]
Output: 23
Explanation:
Score  a=1, c=9, d=5, g=3, o=2
Given letters, we can form the words "dad" (5+1+5) and "good" (3+2+2+5) with a score of 23.
Words "dad" and "dog" only get a score of 21.
```

**Example 2:**
```
Input: words = ["xxxz","ax","bx","cx"], letters = ["z","a","b","c","x","x","x"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]
Output: 27
Explanation:
Score  a=4, b=4, c=4, x=5, z=10
Given letters, we can form the words "ax" (4+5), "bx" (4+5) and "cx" (4+5) with a score of 27.
Word "xxxz" only get a score of 25.
```

**Example 3:**
```
Input: words = ["leetcode"], letters = ["l","e","t","c","o","d"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]
Output: 0
Explanation:
Letter "e" can only be used once.
```

**Constraints:**
-   `1 <= words.length <= 14`
-   `1 <= words[i].length <= 15`
-   `1 <= letters.length <= 100`
-   `letters[i].length == 1`
-   `score.length ==Â 26`
-   `0 <= score[i] <= 10`
-   `words[i]`, `letters[i]`Â contains only lower case English letters.

## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **Bitmask DP Concept:**
   - Each word can be either used or not used
   - Total 2^n possible combinations of words
   - Need to track letter availability
   - State can be represented as a bitmask

2. **Key Insights:**
   - Use bits to represent word selection
   - Pre-compute word scores and requirements
   - Check letter frequency constraints
   - Build solution from smaller subsets

### ðŸ” Edge Cases to Consider
- No valid word combinations
- Single letter available
- All words possible
- Maximum words (14)
- Maximum word length (15)
- Repeated letters
- Zero-score letters
- Single-letter words
- All letters different
- Maximum letter frequency

### ðŸŽ¯ Solution Approaches

1. **Bitmask Dynamic Programming**
   ```pseudo
   function maxScoreWords(words, letters, score):
       n = words.length
       letterFreq = count_frequencies(letters)
       wordScores = []
       wordFreqs = []
       
       # Precompute word scores and frequencies
       for word in words:
           freq = new int[26]
           wordScore = 0
           for c in word:
               freq[c-'a']++
               wordScore += score[c-'a']
           wordFreqs.add(freq)
           wordScores.add(wordScore)
       
       # Try all possible combinations
       function dp(mask, letterFreq):
           if mask == (1<<n): return 0
           
           maxScore = 0
           for i in 0..n-1:
               if (mask & (1<<i)) continue
               
               # Check if we can use this word
               canUse = true
               newFreq = letterFreq.clone()
               for j in 0..25:
                   newFreq[j] -= wordFreqs[i][j]
                   if newFreq[j] < 0:
                       canUse = false
                       break
               
               if canUse:
                   score = wordScores[i] + 
                          dp(mask | (1<<i), newFreq)
                   maxScore = max(maxScore, score)
           
           return maxScore
       
       return dp(0, letterFreq)
   ```
   Time: O(2^n Ã— 26), Space: O(2^n)

### ðŸ“ˆ Visual Explanation
```
Example: words=["dog","cat"], letters=[d,o,g,c,a,t]
score=[1,0,1,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,1,0,0,0,0,0,0]

Bitmask states:
00 - No words selected
01 - "dog" selected
10 - "cat" selected
11 - Both words selected

For mask=00:
Try "dog": Check if d,o,g available â†’ Yes
Try "cat": Check if c,a,t available â†’ Yes

Tree of states:
     00
   /    \
  01    10
  |      |
  11    11
```

### ðŸ› ï¸ Implementation Tips
1. Pre-compute word requirements
2. Use arrays for letter counting
3. Clone frequency arrays carefully
4. Check letter availability early
5. Use bit manipulation efficiently

### ðŸ“Š Complexity Analysis
- Time Complexity: O(2^n Ã— L)
  - 2^n possible states
  - L = total letters to check
- Space Complexity: O(2^n)
  - Memoization storage
  - Letter frequency arrays

### ðŸ”— Related Patterns
- Bitmask DP
- Subset Generation
- Frequency Counting
- Similar Problems:
  - Maximum Students Taking Exam
  - Campus Bikes II
  - Partition to K Equal Sum Subsets

### ðŸ“ Example Processing Flow
```
Input: words=["dog","cat"]
letters=[d,o,g,c,a,t]
score=[1(d),0,1(c),5,0,0,3(g),...]

1. Precompute:
   dog: score=9 (1+2+3)
   cat: score=7 (1+1+1)

2. Try combinations:
   State 00: Try dog â†’ State 01
   State 01: Try cat â†’ Invalid
   State 00: Try cat â†’ State 10
   State 10: Try dog â†’ Invalid

Result: max(9, 7) = 9
```

### âš ï¸ Common Mistakes to Avoid
1. Not checking letter availability
2. Wrong frequency counting
3. Missing letter constraints
4. Incorrect state transitions
5. Integer overflow in scoring

```java
class Solution {
    private int[] score;
    private int[][] wordFreq;
    private int[] wordScores;
    private int n;
    
    public int maxScoreWords(String[] words, char[] letters, int[] score) {
        this.score = score;
        this.n = words.length;
        
        // Count available letters
        int[] letterFreq = new int[26];
        for (char c : letters) {
            letterFreq[c - 'a']++;
        }
        
        // Precompute word frequencies and scores
        wordFreq = new int[n][26];
        wordScores = new int[n];
        for (int i = 0; i < n; i++) {
            int wordScore = 0;
            for (char c : words[i].toCharArray()) {
                wordFreq[i][c - 'a']++;
                wordScore += score[c - 'a'];
            }
            wordScores[i] = wordScore;
        }
        
        return dp(0, letterFreq);
    }
    
    private int dp(int mask, int[] freq) {
        if (mask == (1 << n)) return 0;
        
        int maxScore = 0;
        for (int i = 0; i < n; i++) {
            if ((mask & (1 << i)) != 0) continue;
            
            // Check if we can use this word
            boolean canUse = true;
            int[] newFreq = freq.clone();
            for (int j = 0; j < 26; j++) {
                newFreq[j] -= wordFreq[i][j];
                if (newFreq[j] < 0) {
                    canUse = false;
                    break;
                }
            }
            
            if (canUse) {
                maxScore = Math.max(maxScore, 
                    wordScores[i] + dp(mask | (1 << i), newFreq));
            }
        }
        
        return maxScore;
    }
}

### How to Think About the Solution:
1. Think of this as selecting subset of words
2. Each word can either be used or not used
3. Total possible combinations is 2^n (n = words.length)
4. Can use bitmask to represent word selections

### Key Insights:
1. Letters can only be used once
2. Not all letters need to be used
3. Need to track letter frequency
4. Can use bits to represent word choices

### Step-by-Step Approach:
1. **Preprocess**:
   - Count available letters
   - Calculate score for each word
   - Create word frequency maps

2. **State Representation**:
   - Use bitmask where bit i represents word[i]
   - 1 = word is used, 0 = not used
   - Total states = 2^(words.length)

### Visual Guide:
```
Example: words = ["dog","cat","dad","good"]
letters = ["a","a","c","d","d","d","g","o","o"]

Bitmask representation:
0000 = no words selected
0001 = "dog" selected
0010 = "cat" selected
0011 = "dog" and "cat" selected
...and so on

For mask = 1001 (dog + good):
Check if we have enough letters:
d: need 2, have 3 âœ“
o: need 2, have 2 âœ“
g: need 2, have 1 âœ— (invalid combination)
```

### Edge Cases to Consider:
- Single word
- No valid combinations
- All words valid
- Words sharing all letters
- Maximum possible words (14)

### Common Pitfalls:
1. Not tracking letter frequency correctly
2. Missing letter reuse cases
3. Integer overflow in scoring
4. Inefficient state exploration

### Optimization Techniques:
1. **Letter Counting**:
   - Use array instead of map
   - Precompute word frequencies

2. **State Exploration**:
   - Use bitmask for efficient state tracking
   - Prune invalid combinations early

### Time and Space Analysis:
- Time Complexity: O(2^n * k) where:
  - n = number of words
  - k = average word length
- Space Complexity: O(n * k)

### Similar Problems:
- Maximum Score after Applying Operations
- Partition to K Equal Sum Subsets
- Subset Sum

### Implementation Tips:
1. Use bit manipulation for state
2. Track letter counts efficiently
3. Validate combinations early
4. Cache word scores

### Useful Resources:
- [Bit Manipulation Tricks](https://graphics.stanford.edu/~seander/bithacks.html)
- [State Compression DP](https://cp-algorithms.com/dynamic_programming/profile-dynamics.html)
Similar to 78. Subsets, use backtrack to solve the problem.

```
n = words in the array
l = maximum length of word

**Time Complexity** : O(l * 2<sup>n</sup>)<br>
**Space Complexity** : O(2<sup>n</sup>)

```java
    public int maxScoreWords(String[] words, char[] letters, int[] score) {
        
        int[] freq = new int[26];
        for (char ch : letters) freq[ch - 'a']++;
        return backTrack(0, freq, words, score);
    }
    private int backTrack(int index, int[] freq, String[] words, int[] score) {
        
        int maxScore = 0;
        for (int i = index; i < words.length; i++) {
            String word = words[i];
            int sum = 0;
            boolean isValid = true;
            for (char ch : word.toCharArray()) {
                freq[ch - 'a']--;
                sum = sum + score[ch - 'a'];
                if (freq[ch - 'a'] < 0) isValid = false;
            }
            if (isValid) {
                sum = sum + backTrack(i + 1, freq, words, score);
                maxScore = Math.max(maxScore, sum);
            }
            for (char ch : word.toCharArray())
                freq[ch - 'a']++;
        }
        return maxScore;
    }
```
