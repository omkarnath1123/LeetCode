Link: [235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/) <br>
Tag : **Medium**<br>
Lock: **Normal**

Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.

According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).”

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png)

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png)

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
```

**Example 3:**

```
Input: root = [2,1], p = 2, q = 1
Output: 2
```

**Constraints:**

- The number of nodes in the tree is in the range `[2, 105]`.
- `-109 <= Node.val <= 109`
- All `Node.val` are **unique**.
- `p != q`
- `p` and `q` will exist in the BST.

**Solution:**

- [x] [[Math]]

## Detailed Intuition

The key observation for a Binary Search Tree (BST) is that for any node `curr`:
- All values in the left subtree are < `curr.val`.
- All values in the right subtree are > `curr.val`.

Use this property to find the Lowest Common Ancestor (LCA) directly by walking from the root:
- If both `p.val` and `q.val` are less than `curr.val`, then both target nodes lie in the left subtree, so move `curr = curr.left`.
- If both `p.val` and `q.val` are greater than `curr.val`, then both lie in the right subtree, so move `curr = curr.right`.
- Otherwise, the current node `curr` splits `p` and `q` (one is on the left, the other is on the right), or `curr` equals one of `p` or `q`. In any of these cases `curr` is the LCA.

Why this works (intuitively): once you find a node where `p` and `q` diverge into different subtrees (or one equals the node), that node is the deepest node that has both `p` and `q` as descendants. Any ancestor higher than that would have both nodes in the same subtree and therefore would not be the lowest.

How to think about the solution step-by-step:
1. Start at the root. Compare both target values to the current node value.
2. If both are smaller, go left; if both are larger, go right. This prunes half the tree each step (in a balanced BST).
3. If they are on different sides (or equal to current), stop — the current node is the LCA.

Iterative vs recursive:
- Iterative: preferred when you want O(1) extra space. Keep moving `curr` until you find the split point.
- Recursive: very clean to write; uses O(h) call stack where `h` is the tree height.

Complexity (BST-optimized):
- Time: O(h) where h is the height of the tree. In the average balanced case h = O(log n), worst-case (skewed tree) h = O(n).
- Space: O(1) for iterative, O(h) for recursive call stack.

Edge cases and how to reason about them:
- One node is ancestor of the other (e.g., `p` is the parent of `q` or `p` == `curr`): the algorithm handles this naturally because if `curr` equals `p` (or `q`) and the other node is in its subtree, the split condition is satisfied and `curr` is returned.
- `p` and `q` are the same node: the constraints say `p != q`, but if they were equal, the node itself would be the answer since a node is a descendant of itself.
- Nodes are on different sides of the root: the algorithm will detect the split at the root and return it.
- Skewed tree (all nodes to one side): the algorithm degrades to walking down the chain in O(n) time but still returns the correct node.
- Large value ranges or negative values: irrelevant as long as comparisons are correct because BST invariant depends only on ordering, not magnitude.
- Duplicate values: problem constraints guarantee unique values, so duplicates are not a concern. If duplicates existed, the BST definition and algorithm would need to be adapted to the chosen duplicate-handling convention.
- Nodes not present in the tree: the problem states `p` and `q` will exist in the BST. If that were not guaranteed you would first need to validate presence or modify the algorithm to handle null returns safely.

Common pitfalls to avoid:
- Using the generic binary-tree LCA algorithm (which searches both subtrees) instead of leveraging BST ordering — the generic algorithm works but is less efficient because it doesn't exploit the BST property.
- Mixing up `<=` vs `<` comparisons when the BST allows equal keys — for this problem keys are unique so strict comparisons are safe.

Quick pseudocode (iterative):

    curr = root
    while curr is not null:
        if p.val < curr.val and q.val < curr.val:
            curr = curr.left
        else if p.val > curr.val and q.val > curr.val:
            curr = curr.right
        else:
            return curr

This approach is simple, fast, and robust for the constraints of this problem.

```java
    public TreeNode lowestCommonAncestor(TreeNode node, TreeNode one, TreeNode two) {
        if (node == null) return node;
        if (node == one || node == two) return node;
        TreeNode left = lowestCommonAncestor(node.left, one, two);
        TreeNode right = lowestCommonAncestor(node.right, one, two);
        if (left != null && right != null) return node;
        if (left == null && right == null) return null;
        return left == null ? right : left;
    }
```
