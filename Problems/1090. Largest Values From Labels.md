Link: [1090.Â Largest Values From Labels](https://leetcode.com/problems/largest-values-from-labels/) <br>
Tag : **Medium**<br>
Lock: **Normal**

There is a set ofÂ `n`Â items. You are given two integer arraysÂ `values`Â andÂ `labels`Â where the value and the label of theÂ `ith`Â element areÂ `values[i]`Â andÂ `labels[i]`Â respectively. You are also given two integersÂ `numWanted`Â andÂ `useLimit`.

Choose a subsetÂ `s`Â of theÂ `n`Â elements such that:

-   The size of the subsetÂ `s`Â isÂ **less than or equal to**Â `numWanted`.
-   There areÂ **at most**Â `useLimit`Â items with the same label inÂ `s`.

TheÂ **score**Â of a subset is the sum of the values in the subset.

ReturnÂ _the maximumÂ **score**Â of a subset_Â `s`.

**Example 1:**

```
Input: values = [5,4,3,2,1], labels = [1,1,2,2,3], numWanted = 3, useLimit = 1
Output: 9
Explanation: The subset chosen is the first, third, and fifth items.
```

**Example 2:**

```
Input: values = [5,4,3,2,1], labels = [1,3,3,3,2], numWanted = 3, useLimit = 2
Output: 12
Explanation: The subset chosen is the first, second, and third items.
```

**Example 3:**

```
Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], numWanted = 3, useLimit = 1
Output: 16
Explanation: The subset chosen is the first and fourth items.
```

**Constraints:**

-   `n == values.length == labels.length`
-   `1 <= n <= 2 * 104`
-   `0 <= values[i], labels[i] <= 2 * 104`
-   `1 <= numWanted, useLimit <= n`


## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **Constrained Selection Concept:**
   - Need to maximize sum of values
   - Two types of constraints:
     a) Total items limit (numWanted)
     b) Per-label limit (useLimit)
   - Values can be selected greedily
   - Need to track label frequencies

2. **Key Insights:**
   - Sort by values in descending order
   - Track used count per label
   - Take items when both limits allow
   - Order only matters for values

### ðŸ” Edge Cases to Consider
- Single item
- All same label
- All different labels
- Maximum array length (2Ã—10^4)
- Maximum value/label (2Ã—10^4)
- useLimit = 1
- useLimit = numWanted
- No valid selection possible
- Equal values with different labels
- numWanted = array length

### ðŸŽ¯ Solution Approaches

1. **Greedy with Label Tracking**
   ```pseudo
   function largestValsFromLabels(values, labels, numWanted, useLimit):
       n = values.length
       pairs = []  # (value, label) pairs
       
       # Create value-label pairs
       for i in 0..n-1:
           pairs.add([values[i], labels[i]])
       
       # Sort by value descending
       sort pairs by -value
       
       result = 0
       used = map()  # label -> count
       count = 0
       
       for (value, label) in pairs:
           if count == numWanted:
               break
           
           if used[label] < useLimit:
               result += value
               used[label]++
               count++
       
       return result
   ```
   Time: O(n log n), Space: O(n)

### ðŸ“ˆ Visual Explanation
```
Example:
values = [5,4,3,2,1]
labels = [1,1,2,2,3]
numWanted = 3
useLimit = 1

Sort by value:
Value: 5 4 3 2 1
Label: 1 1 2 2 3

Selection process:
1. Take 5 (label 1) â†’ sum = 5
2. Skip 4 (label 1 at limit)
3. Take 3 (label 2) â†’ sum = 8
4. Skip 2 (label 2 at limit)
5. Take 1 (label 3) â†’ sum = 9

Result: 9
```

### ðŸ› ï¸ Implementation Tips
1. Use array or list for sorting
2. Track label frequencies efficiently
3. Break early when numWanted reached
4. Handle label limits carefully
5. Use appropriate data structures

### ðŸ“Š Complexity Analysis
- Time Complexity: O(n log n)
  - Sorting is dominant operation
  - Single pass through sorted array
- Space Complexity: O(n)
  - Storage for pairs
  - Label frequency map

### ðŸ”— Related Patterns
- Greedy Selection
- Frequency Counting
- Sorting
- Similar Problems:
  - Task Scheduler
  - Partition Labels
  - Top K Frequent Elements

### ðŸ“ Example Processing Flow
```
Input: 
values = [5,4,3,2,1]
labels = [1,3,3,3,2]
numWanted = 3
useLimit = 2

1. Create pairs and sort:
   [(5,1), (4,3), (3,3), (2,3), (1,2)]

2. Process pairs:
   Take 5 â†’ sum=5, used={1:1}
   Take 4 â†’ sum=9, used={1:1, 3:1}
   Take 3 â†’ sum=12, used={1:1, 3:2}
   Stop (numWanted reached)

Result: 12
```

### âš ï¸ Common Mistakes to Avoid
1. Not tracking label frequencies
2. Wrong sorting order
3. Missing constraint checks
4. Inefficient data structures
5. Not breaking early

```java
class Solution {
    public int largestValsFromLabels(int[] values, int[] labels, 
                                   int numWanted, int useLimit) {
        int n = values.length;
        int[][] pairs = new int[n][2];
        for (int i = 0; i < n; i++) {
            pairs[i] = new int[]{values[i], labels[i]};
        }
        
        // Sort by value in descending order
        Arrays.sort(pairs, (a, b) -> b[0] - a[0]);
        
        Map<Integer, Integer> used = new HashMap<>();
        int result = 0;
        int count = 0;
        
        for (int[] pair : pairs) {
            if (count == numWanted) break;
            
            int value = pair[0], label = pair[1];
            if (used.getOrDefault(label, 0) < useLimit) {
                result += value;
                used.put(label, used.getOrDefault(label, 0) + 1);
                count++;
            }
        }
        
        return result;
    }
}
Hash-map that will maintain the count of use of each label, where key will be label and value will be count of that label used.  
Taking 2D array to store value and its corresponding label, Sorting it based on values in descending order.  
Traversing each element of the array and adding to the subset and updating the label count for that element in the hash-map.

```
n = is the length of values

**Time Complexity** : O(n log(n))<br>
**Space Complexity** : O(n)

```java
    public int largestValsFromLabels(int[] values, int[] labels, int numWanted, int useLimit) {
        
        Map<Integer, Integer> limitCount = new HashMap<>();
        int len = values.length, score = 0;
        List<Node> nodes = new ArrayList<>();
        
        for (int i = 0; i < len; i++)
            nodes.add(new Node(values[i], labels[i]));
        
        Collections.sort(nodes);
        for (Node node : nodes)
            if (limitCount.getOrDefault(node.label, 0) < useLimit && numWanted > 0) {
                numWanted--;
                limitCount.merge(node.label, 1, Integer::sum);
                score += node.value;
            }
        
        return score;
    }
    class Node implements Comparable<Node> {
        int value, label;
        Node (int value, int label) {
            this.value = value;
            this.label = label;
        }
        @Override
        public int compareTo(Node that) {
            return -1 * Integer.compare(this.value, that.value);
        }
    }
```
