Link: [3461. Check If Digits Are Equal in String After Operations](https://leetcode.com/problems/check-if-digits-are-equal-in-string-after-operations-i/description/?envType=daily-question&envId=2025-10-23) <br>
Tag : **Easy**<br>
Lock: **Normal**

You are given a string `s` consisting of digits. Perform the following operation repeatedly until the string has **exactly** two digits:

- For each pair of consecutive digits in `s`, starting from the first digit, calculate a new digit as the sum of the two digits **modulo** 10.
- Replace `s` with the sequence of newly calculated digits, _maintaining the order_ in which they are computed.

Return `true` if the final two digits in `s` are the **same**; otherwise, return `false`.

**Example 1:**

```
Input: s = "3902"

Output: true

Explanation:

Initially, s = "3902"
First operation:
(s[0] + s[1]) % 10 = (3 + 9) % 10 = 2
(s[1] + s[2]) % 10 = (9 + 0) % 10 = 9
(s[2] + s[3]) % 10 = (0 + 2) % 10 = 2
s becomes "292"
Second operation:
(s[0] + s[1]) % 10 = (2 + 9) % 10 = 1
(s[1] + s[2]) % 10 = (9 + 2) % 10 = 1
s becomes "11"
Since the digits in "11" are the same, the output is true.
```

**Example 2:**

```
Input: s = "34789"

Output: false

Explanation:

Initially, s = "34789".
After the first operation, s = "7157".
After the second operation, s = "862".
After the third operation, s = "48".
Since '4' != '8', the output is false.
```

**Constraints:**

- `3 <= s.length <= 100`
- `s` consists of only digits.

**Solution:**

- [x] [[Queue]]

## Detailed Intuition

Think of the process as repeatedly sliding a window of size 2 over the current sequence of digits and replacing each adjacent pair by their sum modulo 10 to form the next sequence. The simplest and most intuitive way to simulate this is with a queue (or deque): keep the digits in order, repeatedly consume the first two digits, compute their sum % 10 and append the result to the back, then restore the second digit to the front so the next pair starts at the correct position. Repeat until only two digits remain and compare them.

Why this works (intuitively): each operation produces a new sequence whose i-th element is (old[i] + old[i+1]) % 10. Doing this repeatedly is equivalent to applying the same local linear transformation over the sequence until length becomes 2. The queue simulation mirrors the way the transformation slides across the sequence and naturally produces the digits in the required order.

How to think about designing the solution:
- Start from the process description and simulate it exactly: for every iteration generate the next sequence from left to right using adjacent pairs.
- A queue/deque is convenient because it preserves order and supports popping from the front and pushing at the back in O(1). That lets you build the next sequence while keeping the remaining old digits available for subsequent pairs.
- If you prefer a more direct simulation without a deque, you can build a new string/array each iteration from adjacent pairs, then replace the old array with the new one. That is simpler to reason about but uses extra arrays each iteration; both approaches are O(n^2) time in the worst case for n up to 100.
- For advanced readers: the final two digits are linear combinations of the original digits with binomial-like coefficients (like repeated application of a local linear operator). One could analyze those coefficients modulo 10 and compute the final two digits in O(n) using precomputed weights; however for the constraints (n <= 100) the straightforward O(n^2) simulation is simpler and perfectly fast.

Edge cases and how to reason about them:
- Minimum length (n = 3): the algorithm should perform exactly one operation to go from length 3 to length 2. Verify this by hand for a few examples (e.g., "123" -> "35" -> compare).
- All digits the same (e.g., "7777"): sums modulo 10 may change the digits (e.g., (7+7)%10 = 4), but the algorithm still applies normally; check that you do not short-circuit incorrectly just because the input digits are identical.
- Leading zeroes or zeros in general (e.g., "090"): zeros behave normally under addition modulo 10. Treat characters as digits 0-9 rather than numbers with special semantics.
- Wrap-around due to modulo 10: remember that (9 + 9) % 10 == 8, so don't try to track carries — the operation is purely digit-wise modulo 10.
- Odd/even intermediate lengths: each iteration reduces length by 1. For an initial length n, you will perform (n - 2) total iterations. Make sure the loop condition precisely stops when size == 2.
- Small mistakes in indexing or in-place updates: when generating the next sequence from the current one, ensure you don't overwrite digits needed for later pairs. Using a queue or constructing a new array per iteration avoids these bugs.

Quick mental tests to validate your implementation:
- s = "3902" -> iterations: "3902" -> "292" -> "11" -> true
- s = "34789" -> "7157" -> "862" -> "48" -> false
- s = "123" -> "35" -> false
- s = "909" -> "99" -> true (note modulo wrap: 9+0=9, 0+9=9)

Performance and correctness checks:
- Time complexity is O(n^2) in the straightforward simulation: each iteration is O(current_length) and there are O(n) iterations.
- Space complexity is O(n) to hold the current sequence (queue or array).
- For the problem constraints (n <= 100) this is sufficient and simple.

Implementation hint (mapping the intuition to code): push each character as an integer into a deque; while deque.size() > 2, pop two integers a and b, push (a + b) % 10 to the back, then push b back to the front to restore the sliding window. Stop when size == 2 and compare the two remaining values.

```java
    public boolean hasSameDigits(String s) {

        ArrayDeque<Integer> queue = new ArrayDeque<>();
        for (char ch : s.toCharArray())
            queue.offerLast(Integer.parseInt(ch + ""));

        int size = queue.size();
        while (queue.size() > 2) {
            size--;
            if (size == 0) {
                queue.pollFirst();
                size = queue.size();
                continue;
            }
            int removeOne = queue.pollFirst();
            int removeTwo = queue.pollFirst();
            queue.offerLast((removeOne + removeTwo) % 10);
            queue.offerFirst(removeTwo);
        }
        return queue.pollFirst() == queue.pollLast();
    }
```
