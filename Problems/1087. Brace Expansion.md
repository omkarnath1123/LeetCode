Link: [1087.Â Brace Expansion](https://leetcode.com/problems/brace-expansion/) <br>
Tag : **Medium**<br>
Lock: **Premium**

You are given a stringÂ `s`Â representing a list of words. Each letter in the word has one or more options.

-   If there is one option, the letter is represented as is.
-   If there is more than one option, then curly braces delimit the options. For example,Â `"{a,b,c}"`Â represents optionsÂ `["a", "b", "c"]`.

For example, ifÂ `s = "a{b,c}"`, the first character is alwaysÂ `'a'`, but the second character can beÂ `'b'`Â orÂ `'c'`. The original list isÂ `["ab", "ac"]`.

Return all words that can be formed in this manner,Â **sorted**Â in lexicographical order.

**Example 1:**
```
Input: s = "{a,b}c{d,e}f"
Output: ["acdf","acef","bcdf","bcef"]
```

**Example 2:**
```
Input: s = "abcd"
Output: ["abcd"]
```

**Constraints:**
-   `1 <= s.length <= 50`
-   `s`Â consists of curly bracketsÂ `'{}'`, commasÂ `','`, and lowercase English letters.
-   `s`Â is guaranteed to be a valid input.
-   There are no nested curly brackets.
-   All characters inside a pair of consecutive opening and ending curly brackets are different.

## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **String Expansion Concept:**
   - Each position can have single or multiple choices
   - Need to generate all possible combinations
   - Think of it as a tree of decisions
   - Each level represents one position in string

2. **Key Insights:**
   - Backtracking perfect for trying all combinations
   - No nested braces simplifies parsing
   - Can sort options at each position first
   - Final sorting not needed if we process in order

### ðŸ” Edge Cases to Consider
- Single character string
- No braces in string
- All characters in braces
- Empty options (not allowed by constraints)
- Maximum string length (50)
- Single character in braces
- Multiple consecutive brace groups
- Maximum number of options per brace

### ðŸŽ¯ Solution Approaches

1. **Backtracking with Character Options**
   ```pseudo
   function expand(s):
       # Parse string into list of options
       options = []
       i = 0
       while i < len(s):
           if s[i] == '{':
               end = s.indexOf('}', i)
               chars = s[i+1:end].split(',').sort()
               options.append(chars)
               i = end + 1
           else:
               options.append([s[i]])
               i += 1
       
       result = []
       
       def backtrack(pos, current):
           if pos == len(options):
               result.append(current)
               return
           
           for choice in options[pos]:
               backtrack(pos + 1, current + choice)
       
       backtrack(0, "")
       return result
   ```
   Time: O(nÃ—m^k), Space: O(nÃ—m^k)
   where n=string length, m=max options per brace, k=number of brace groups

### ðŸ“ˆ Visual Explanation
```
Example: "{a,b}c{d,e}f"

Decision Tree:
         {}
     /        \
    a          b
    |          |
    c          c
   / \        / \
  d   e      d   e
  |   |      |   |
  f   f      f   f

Results: [acdf, acef, bcdf, bcef]

Processing Steps:
1. Parse into options:
   [[a,b], [c], [d,e], [f]]
2. Backtrack through choices
3. Build strings incrementally
```

### ðŸ› ï¸ Implementation Tips
1. Sort options when parsing braces
2. Use StringBuilder for efficiency
3. Pre-allocate result list size if possible
4. Process characters in order
5. Avoid string concatenation in loop

### ðŸ“Š Complexity Analysis
- Time Complexity: O(nÃ—m^k)
  - n = string length
  - m = maximum options per brace
  - k = number of brace groups
- Space Complexity: O(nÃ—m^k)
  - For storing all possible combinations
  - Plus recursion stack depth O(n)

### ðŸ”— Related Patterns
- Backtracking
- String Manipulation
- Cartesian Product
- Similar Problems:
  - Letter Case Permutation
  - Generate Parentheses
  - Word Break II

### ðŸ“ Example Processing Flow
```
Input: "{a,b}c{d,e}f"

1. Parse options:
   Pos 0: [a,b]
   Pos 1: [c]
   Pos 2: [d,e]
   Pos 3: [f]

2. Backtrack through choices:
   "" â†’ "a" â†’ "ac" â†’ "acd" â†’ "acdf"
   â†“
   "" â†’ "a" â†’ "ac" â†’ "ace" â†’ "acef"
   â†“
   "" â†’ "b" â†’ "bc" â†’ "bcd" â†’ "bcdf"
   â†“
   "" â†’ "b" â†’ "bc" â†’ "bce" â†’ "bcef"
```

### âš ï¸ Common Mistakes to Avoid
1. Not sorting options within braces
2. Inefficient string concatenation
3. Unnecessary result sorting
4. Complex parsing logic
5. Not handling single character case efficiently
   - Parse brace contents into lists of options

2. **Generate Combinations**:
   - Use backtracking to build words
   - At each position, try each available option
   - Track current word being built
   - Add complete words to result list

### Visual Guide:
```
Example: s = "{a,b}c{d,e}f"

Position options:
Pos 0: [a,b]
Pos 1: [c]
Pos 2: [d,e]
Pos 3: [f]

Backtracking tree:
                root
        a               b
        |               |
        c               c
      /   \           /   \
     d     e         d     e
     |     |         |     |
     f     f         f     f
     |     |         |     |
   acdf  acef      bcdf  bcef
```

### Edge Cases to Consider:
- String with no braces
- Single character options in braces
- Maximum length string (50 chars)
- All positions having multiple options
- Same character in different option sets

### Common Pitfalls:
1. Not sorting options within braces
2. Incorrect parsing of brace contents
3. Not handling single characters properly
4. Forgetting to sort final result

### Optimization Techniques:
1. **Pre-processing**:
   - Parse all options beforehand
   - Sort options at each position once

2. **Memory Usage**:
   - Use StringBuilder for word building
   - Clear temporary structures after use

### Time and Space Analysis:
- Time Complexity: O(N * M^K) where:
  - N = length of string
  - M = max options at any position
  - K = positions with options
- Space Complexity: O(N * total combinations)

### Similar Problems:
- Letter Case Permutation
- Generate Parentheses
- Word Search II

### Useful Resources:
- [Backtracking Patterns](https://leetcode.com/explore/learn/card/recursion-ii/)
- [String Manipulation Techniques](https://www.geeksforgeeks.org/string-data-structure/)

**Solution:**

- [x] [[Backtracking]]

**Intuition** :

**Algorithm**
1.  Extract the character options for different indices and store them in the listÂ `allOptions`Â using the functionÂ `storeAllOptions`. Unlike the previous approaches, we find the options for all indices beforehand because if we find the options while backtracking, we will end up finding the options for the same index multiple times.
    
2.  Call the functionÂ `generateWords`Â with the given stringÂ ssÂ and an empty string as the current stringÂ `currString`.
    
3.  If the stringÂ `currString`Â is complete i.e., the length of theÂ `currString`Â becomes equal to the number of options inÂ `allOptions`Â add the string to the listÂ `expandedWords`Â and return.
    
4.  Fetch the character options for the current index inÂ `currOptions`. Iterate over the characters in the listÂ `currOptions`Â and for each character:
    
    -   Add the character toÂ `currString`.
    -   Recursively call the functionÂ `generateWords`Â with the updated stringÂ `currString`.
    -   Backtrack by removing the last added character.
5.  ReturnÂ `expandedWords`.

```
n = is the length of expression

**Time Complexity** : O(n)<br>
**Space Complexity** : O(n)

```java
    PriorityQueue<String> minHeap;
    public String[] expand(String s) {
        minHeap = new PriorityQueue<>();
        backTrack(" " + s, 0, new StringBuilder());
        
        int size = minHeap.size();
        String[] res = new String[size];
        for (int i = 0; i < size; i++)
            res[i] = minHeap.poll();
        return res;
    }
    private void backTrack(String s, int index, StringBuilder sb) {
        if (index == s.length()) {
            minHeap.add(sb.toString().substring(1));
            return;
        }
        
        if (s.charAt(index) == '{') {
            int i;
            for (i = index; i < s.length(); i++)
                if (s.charAt(i) == '}') break;
            
            String[] options = s.substring(index + 1, i).split(",");
            for (String option : options) {
                sb.append(option);
                backTrack(s, i + 1, sb);
                sb.deleteCharAt(sb.length() - 1);
            }
        } else {
            char ch = s.charAt(index);
            sb.append(ch);
            backTrack(s, index + 1, sb);
            sb.deleteCharAt(sb.length() - 1);
        }
    }
````
