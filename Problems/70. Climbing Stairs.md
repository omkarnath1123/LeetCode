Link: [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/description/) <br>
Tag : **Easy**<br>
Lock: **Normal**

You are climbing a staircase. It takes `n` steps to reach the top.

Each time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?

**Example 1:**

```
Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
```

**Example 2:**

```
Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
```

**Constraints:**

- `1 <= n <= 45`

**Solution:**

- [x] [[Dynamic Programming]] + [[Top-Down Solution]]

## Detailed Intuition

Think of the problem as counting distinct sequences of 1-step and 2-step moves that sum to n. The key observation is that any way to reach step n must have come from either step n-1 (followed by a 1-step) or step n-2 (followed by a 2-step). Therefore the number of ways to reach n is the sum of the ways to reach n-1 and n-2. This gives the recurrence:

f(n) = f(n-1) + f(n-2)

with small base cases that seed the recurrence. The standard base choices for this problem are:
- f(1) = 1 (only one way: a single 1-step)
- f(2) = 2 (either 1+1 or 2)

Why this works: the recurrence partitions all valid sequences by their final move. Sequences ending with a 1-step correspond 1-1 to all sequences that reached n-1; sequences ending with a 2-step correspond 1-1 to all sequences that reached n-2. There is no overlap between those two groups, so summing them counts every sequence exactly once.

How to think about solving it:
- Recursive (top-down) view: directly translate the recurrence into recursion with memoization to avoid exponential recomputation. This is conceptually simple and mirrors the mathematical definition.
- Iterative (bottom-up) DP: start from the base values and build up to n using a loop. This is usually the simplest and most efficient in practice.
- Space optimization: since f(n) depends only on the previous two values, you can keep just two variables rather than an array, reducing space from O(n) to O(1).

Edge cases and tricky points to consider:
- n = 1 -> return 1. n = 2 -> return 2. Make sure your base cases are set accordingly.
- The problem statement constrains n >= 1, so you typically don't need to handle n = 0; if you do consider n = 0, there are two common conventions: treat f(0) = 1 (one empty way) or define the problem only for n>=1. Stick to the convention used in your code/tests.
- Integer overflow: with these constraints (n <= 45) the values fit comfortably in a 32-bit signed integer; for larger n you might need 64-bit integers.
- Off-by-one errors: verify indexing if you use an array (e.g., arr[1] and arr[2] should map to f(1) and f(2)).
- Incorrect base initialization: double-check that base entries follow the chosen convention (f(1)=1, f(2)=2) so the recurrence produces correct values.

Suggested approaches and trade-offs:
- Top-down memoized recursion: easy to write, clear mapping to recurrence, O(n) time and O(n) recursion/memo space.
- Bottom-up iterative DP: minimal overhead and predictable performance, O(n) time and O(n) space (or O(1) if optimized).
- O(1) space iterative: keep two variables a and b for the last two values and iterate from 3..n, updating them; this is the most memory-efficient and clean for this problem.

Quick mental checks / tests to run:
- n = 1 -> 1
- n = 2 -> 2
- n = 3 -> 3 (1+1+1, 1+2, 2+1)
- n = 4 -> 5 (1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2)

The problem is essentially computing an offset Fibonacci sequence (f(n) equals the (n+1)-th Fibonacci number under the common Fibonacci indexing), so many familiar Fibonacci optimizations/insights apply.


```java
    int[] res = new int[46];
    public int climbStairs(int n) {
        if (res[n] != 0) return res[n];

        res[0] = 0;
        res[1] = 1;
        res[2] = 2;
        for (int i = 3; i < 46; i++)
            res[i] = res[i - 1] + res[i - 2];
        return res[n];
    }
```
