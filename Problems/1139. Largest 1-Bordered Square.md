Link: [1139.Â Largest 1-Bordered Square](https://leetcode.com/problems/largest-1-bordered-square/) <br>
Tag : **Medium**<br>
Lock: **Normal**

Given a 2DÂ `grid`Â ofÂ `0`s andÂ `1`s, return the number of elements inÂ the largestÂ **square**Â subgrid that has allÂ `1`s on itsÂ **border**, orÂ `0`Â if such a subgridÂ doesn't exist in theÂ `grid`.

**Example 1:**
```
Input: grid = [[1,1,1],[1,0,1],[1,1,1]]
Output: 9
```

**Example 2:**
```
Input: grid = [[1,1,0,0]]
Output: 1
```

**Constraints:**
-   `1 <= grid.length <= 100`
-   `1 <= grid[0].length <= 100`
-   `grid[i][j]`Â isÂ `0`Â orÂ `1`

## Detailed Intuition

### ğŸ’¡ How to Think About the Solution

1. **Border Square Concept:**
   - Need all 1s on square border
   - Inner elements don't matter
   - Square requires equal sides
   - Pre-compute consecutive counts

2. **Key Insights:**
   - Store consecutive 1s counts
   - Check both horizontal and vertical
   - Process squares from largest to smallest
   - Early termination possible

### ğŸ” Edge Cases to Consider
- 1Ã—1 grid
- All zeros grid
- All ones grid
- Single row/column
- Maximum grid size (100Ã—100)
- No valid square exists
- Multiple valid squares
- Square at grid edge
- Square at grid corner
- Sparse 1s distribution

### ğŸ¯ Solution Approaches

1. **Prefix Count Dynamic Programming**
   ```pseudo
   function largest1BorderedSquare(grid):
       m = grid.length, n = grid[0].length
       
       # Count consecutive 1s
       horizontal = new int[m+1][n+1]
       vertical = new int[m+1][n+1]
       
       # Build prefix counts
       for i in 0..m-1:
           for j in 0..n-1:
               if grid[i][j] == 1:
                   horizontal[i][j] = horizontal[i][j-1] + 1
                   vertical[i][j] = vertical[i-1][j] + 1
       
       # Check squares from largest to smallest
       maxSize = min(m, n)
       for size in maxSize..1:
           for i in 0..m-size:
               for j in 0..n-size:
                   if min(horizontal[i][j+size-1],
                         horizontal[i+size-1][j+size-1],
                         vertical[i+size-1][j],
                         vertical[i+size-1][j+size-1]) >= size:
                       return size * size
       
       return 0
   ```
   Time: O(min(m,n) Ã— m Ã— n), Space: O(m Ã— n)

### ğŸ“ˆ Visual Explanation
```
Example Grid:
1 1 1
1 0 1
1 1 1

Horizontal counts:
1 2 3
1 1 2
1 2 3

Vertical counts:
1 1 1
2 1 2
3 2 3

Check size 3:
Top: h[0][2] = 3 âœ“
Bottom: h[2][2] = 3 âœ“
Left: v[2][0] = 3 âœ“
Right: v[2][2] = 3 âœ“
Valid square found! Area = 9
```

### ğŸ› ï¸ Implementation Tips
1. Use 2D arrays for counts
2. Handle array boundaries
3. Process larger squares first
4. Check all four sides
5. Early exit on success

### ğŸ“Š Complexity Analysis
- Time Complexity: O(min(m,n) Ã— m Ã— n)
  - Build counts: O(m Ã— n)
  - Check squares: O(min(m,n) Ã— m Ã— n)
- Space Complexity: O(m Ã— n)
  - Store horizontal/vertical counts

### ğŸ”— Related Patterns
- Dynamic Programming
- Matrix Processing
- Prefix Sums
- Similar Problems:
  - Maximal Square
  - Count Square Submatrices
  - Largest Plus Sign

### ğŸ“ Example Processing Flow
```
Input:
1 1 1
1 0 1
1 1 1

1. Build count arrays:
   Horizontal:
   1 2 3
   1 1 2
   1 2 3
   
   Vertical:
   1 1 1
   2 1 2
   3 2 3

2. Check squares:
   Size 3: Found at (0,0) âœ“
   Return 9

Result: 9 (3Ã—3 square)
```

### âš ï¸ Common Mistakes to Avoid
1. Wrong count calculation
2. Missing border checks
3. Incorrect size iteration
4. Array bounds errors
5. Not checking all sides

```java
class Solution {
    public int largest1BorderedSquare(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int[][] horizontal = new int[m][n];
        int[][] vertical = new int[m][n];
        
        // Build consecutive counts
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    horizontal[i][j] = (j > 0 ? horizontal[i][j-1] : 0) + 1;
                    vertical[i][j] = (i > 0 ? vertical[i-1][j] : 0) + 1;
                }
            }
        }
        
        // Check squares from largest to smallest
        int maxSize = Math.min(m, n);
        for (int size = maxSize; size > 0; size--) {
            for (int i = 0; i <= m - size; i++) {
                for (int j = 0; j <= n - size; j++) {
                    if (horizontal[i][j+size-1] >= size && 
                        horizontal[i+size-1][j+size-1] >= size &&
                        vertical[i+size-1][j] >= size &&
                        vertical[i+size-1][j+size-1] >= size) {
                        return size * size;
                    }
                }
            }
        }
        
        return 0;
    }
}

```java
    public int largest1BorderedSquare(int[][] grid) {
        
        int len = grid.length,
            bre = grid[0].length;
        int[][] top = new int[len][bre],
                left = new int[len][bre];
        for (int i = 0; i < len; i++)
            for (int j = 0; j < bre; j++)
                if (grid[i][j] == 1) {
                    if (i == 0 && j == 0) {
                        top[i][j] = left[i][j] = 1;
                    } else if (i == 0) {
                        top[i][j] = 1;
                        left[i][j] = left[i][j - 1] + 1;
                    } else if (j == 0) {
                        left[i][j] = 1;
                        top[i][j] = top[i - 1][j] + 1;
                    } else {
                        top[i][j] = top[i - 1][j] + 1;
                        left[i][j] = left[i][j - 1] + 1;
                    }
                }
        
        for (int size = Math.min(len, bre); size > 0; size--)
            for (int i = 0; i < len - size + 1; i++)
                for (int j = 0; j < bre - size + 1; j++)
                    if (top[i + size - 1][j] >= size &&
                        top[i + size - 1][j + size - 1] >= size && 
                        left[i][j + size - 1] >= size &&
                        left[i + size - 1][j + size - 1] >= size)
                        return size * size;
        return 0;
    }
```
