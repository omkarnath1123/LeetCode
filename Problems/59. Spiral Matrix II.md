Link: [59. Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/description/) <br>
Tag : **Medium**<br>Lock: **Normal**

Given a positive integer `n`, generate an `n x n` `matrix` filled with elements from `1` to `n2` in spiral order.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)

```
Input: n = 3
Output: [[1,2,3],[8,9,4],[7,6,5]]
```

**Example 2:**

```
Input: n = 1
Output: [[1]]
```

**Constraints:**

- `1 <= n <= 20`

**Solution:**

- [x] [[Array]]

## Detailed Intuition

Think of the n x n matrix as a sequence of concentric layers (or rings) you fill from the outside in. For each layer you perform four straight passes in this order: top row (left -> right), right column (top -> bottom), bottom row (right -> left), and left column (bottom -> top). After completing those four passes you shrink the boundaries inward (top++, right--, bottom--, left++) and repeat for the next inner layer until every cell is filled. The integer variable `counter` simply increases from 1 to n*n and is written into the visited cells in this spiral order.

Why this works: each pass fills one side of the current layer without overlapping if you maintain the boundary indices correctly. The loop condition ensures you stop when there are no more valid rows or columns to fill. Conceptually you are mapping a 1D sequence (1..n*n) onto the 2D matrix by walking the matrix in a spiral path that visits each coordinate exactly once.

How to implement safely (thinking steps):
- Initialize four boundaries: top = 0, bottom = n-1, left = 0, right = n-1. These describe the current layer.
- Do the four directional fills in the fixed order and adjust the corresponding boundary immediately after finishing that side.
- Use for-loops that iterate only while the loop index is within the current boundaries — this prevents overwriting already-filled cells.
- Repeat until all numbers are written (or until boundaries cross). An alternative termination is to stop when counter > n*n.

Key edge cases and how to think about them:
- n = 1 (smallest case): the algorithm should write the single center cell and stop; the top/left/right/bottom adjustments happen, but the subsequent passes will have empty ranges and won't overwrite anything.
- Odd n (has a center cell): after filling full outer layers you will eventually reach a 1x1 center layer; only the first directional pass (top row) writes the last number. Ensure your loops handle single-row or single-column layers without duplicating writes.
- Even n (no single center): layers finish exactly when boundaries cross and no special center-handling is needed.
- Single remaining row or single remaining column: when the remaining layer is one row high or one column wide, some of the four passes become no-ops — ensure for-loop bounds prevent executing them (e.g., start index > end index). Many implementations check the loop condition (top <= bottom && left <= right) before each side or rely on for-loops that naturally skip when bounds are invalid.
- Off-by-one and double-fill bugs: these happen when you don't update boundaries at the right time or when you use incorrect loop conditions. Visualize indices for a small n (2..5) and walk through the algorithm to validate the sequence.

Alternative viewpoints:
- Direction-vector simulation: maintain a direction index (right, down, left, up) and move step by step, turning when the next cell is out-of-bounds or already filled. This is often simpler to reason about but uses an additional visited check or sentinel value.
- Layer-by-layer (the current approach) is efficient and maps cleanly to the four for-loops per layer.

Testing tips (quick mental tests):
- n = 1, n = 2, n = 3, n = 4 and manually verify the output.
- Check that the last number written is n*n and that every integer from 1..n*n appears exactly once.

These thoughts and edge-case checks will help you reason about correctness and avoid common pitfalls when implementing spiral-filling algorithms.

```java
    public int[][] generateMatrix(int n) {
        
        int[][] res = new int[n][n];
        int counter = 1, len = n, bre = n;
        int top = 0, bottom = len - 1, left = 0, right = len - 1;
        while (top <= bottom || left <= right) {

            for (int i = left; i <= right; i++) {
                res[top][i] = counter++;
            }
            top++;

            for (int i = top; i <= bottom; i++) {
                res[i][right] = counter++;
            }
            right--;

            for (int i = right; i >= left; i--) {
                res[bottom][i] = counter++;
            }
            bottom--;

            for (int i = bottom; i >= top; i--) {
                res[i][left] = counter++;
            }
            left++;
        }
        return res;
    }
```
