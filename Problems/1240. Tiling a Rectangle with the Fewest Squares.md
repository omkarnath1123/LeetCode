Link: [1240. Tiling a Rectangle with the Fewest Squares](https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/) <br>
Tag : **Hard**<br>
Lock: **Normal**

Given a rectangle of size `n` x `m`, return _the minimum number of integer-sided squares that tile the rectangle_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/10/17/sample_11_1592.png)
```
Input: n = 2, m = 3
Output: 3
Explanation: 3 squares are necessary to cover the rectangle.
2 (squares of 1x1)
1 (square of 2x2)
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2019/10/17/sample_22_1592.png)
```
Input: n = 5, m = 8
Output: 5
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2019/10/17/sample_33_1592.png)
```
Input: n = 11, m = 13
Output: 6
```

**Constraints:**
-   `1 <= n, m <= 13`

## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **Game Theory Concept:**
   - Each move places a square
   - State is current unfilled region
   - Optimal play minimizes squares used
   - Need to consider all possible strategies

2. **Key Insights:**
   - Always fill lowest empty position
   - Try largest possible square first
   - Backtrack on suboptimal choices
   - Special cases need different strategies

### ðŸ” Edge Cases to Consider
- Square dimensions (n=m)
- Small rectangles (1Ã—2, 2Ã—3)
- Large rectangles (13Ã—13)
- Prime dimensions
- Perfect square dimensions
- Known special cases (11Ã—13)
- One dimension much larger
- Equal dimensions
- Minimum dimension (1)
- Maximum dimension (13)

### ðŸŽ¯ Solution Approaches

1. **Game Theory with Backtracking**
   ```pseudo
   function tilingRectangle(n, m):
       if n == m:
           return 1  # Perfect square case
       
       # Initialize board
       board = new boolean[n][m]  # false = empty
       result = n * m  # worst case
       
       function backtrack(count):
           if count >= result:
               return  # Already found better solution
           
           # Find lowest empty position
           row = col = -1
           outer:
           for i in 0..n-1:
               for j in 0..m-1:
                   if !board[i][j]:
                       row = i
                       col = j
                       break outer
           
           if row == -1:  # Board filled
               result = min(result, count)
               return
           
           # Try each possible square size
           for size in min(n-row, m-col)..1:
               if canPlaceSquare(row, col, size):
                   placeSquare(row, col, size, true)
                   backtrack(count + 1)
                   placeSquare(row, col, size, false)
       
       backtrack(0)
       return result
   ```
   Time: O(k^(nÃ—m)), Space: O(nÃ—m) where k is average choices per state

### ðŸ“ˆ Visual Explanation
```
Example: n=2, m=3

Initial state:
[ ][ ][ ]
[ ][ ][ ]

Step 1: Place 2Ã—2 square
[â–£â–£][ ]
[â–£â–£][ ]

Step 2: Place 1Ã—1 squares
[â–£â–£][â– ]
[â–£â–£][â– ]

Result: 3 squares needed
```

### ðŸ› ï¸ Implementation Tips
1. Track board state efficiently
2. Find empty positions quickly
3. Validate square placement
4. Use pruning techniques
5. Handle special cases first

### ðŸ“Š Complexity Analysis
- Time Complexity: O(k^(nÃ—m))
  - k possible moves per state
  - nÃ—m total positions
- Space Complexity: O(nÃ—m)
  - Board representation
  - Recursion stack

### ðŸ”— Related Patterns
- Game Theory
- Backtracking
- Greedy Strategy
- Similar Problems:
  - Perfect Squares
  - Partition Equal Subset Sum
  - Stone Game variants

### ðŸ“ Example Processing Flow
```
Input: n=2, m=3

1. Initial strategy:
   Try 2Ã—2 square at (0,0)
   
2. After first move:
   Need to cover remaining 1Ã—2 strip
   
3. Complete solution:
   - One 2Ã—2 square
   - Two 1Ã—1 squares
   
Result: 3 squares minimum
```

### âš ï¸ Common Mistakes to Avoid
1. Not trying all possibilities
2. Wrong square placement
3. Missing optimal solutions
4. Inefficient state tracking
5. Missing special cases

```java
class Solution {
    private int result;
    private boolean[][] board;
    
    public int tilingRectangle(int n, int m) {
        if (n == m) return 1;
        
        this.board = new boolean[n][m];
        this.result = n * m;  // worst case
        
        backtrack(0);
        return result;
    }
    
    private void backtrack(int count) {
        if (count >= result) return;
        
        // Find lowest empty position
        int row = -1, col = -1;
        outer:
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (!board[i][j]) {
                    row = i;
                    col = j;
                    break outer;
                }
            }
        }
        
        if (row == -1) {  // Board filled
            result = Math.min(result, count);
            return;
        }
        
        // Try each possible square size
        int maxSize = Math.min(
            Math.min(board.length - row, 
                    board[0].length - col),
            Math.min(result - count,
                    Math.max(board.length, board[0].length))
        );
        
        for (int size = maxSize; size >= 1; size--) {
            if (canPlaceSquare(row, col, size)) {
                placeSquare(row, col, size, true);
                backtrack(count + 1);
                placeSquare(row, col, size, false);
            }
        }
    }
    
    private boolean canPlaceSquare(int row, int col, int size) {
        if (row + size > board.length || 
            col + size > board[0].length) return false;
            
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                if (board[row + i][col + j]) return false;
            }
        }
        return true;
    }
    
    private void placeSquare(int row, int col, int size, boolean value) {
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                board[row + i][col + j] = value;
            }
        }
    }
}
3. Order of placement matters
4. Can use backtracking with pruning

### Step-by-Step Approach:
1. **State Representation**:
   - Track covered/uncovered cells
   - Find leftmost-bottommost empty cell
   - Try placing squares at this position

2. **Square Selection**:
   - Try largest possible square first
   - Maximum size limited by:
     - Distance to rectangle edges
     - Distance to placed squares

### Visual Guide:
```
Example: 2Ã—3 rectangle

Starting state:
[ ][ ][ ]
[ ][ ][ ]

Possible first moves:
[2][ ]    [1][ ][ ]
[2][ ]    [1][ ][ ]

After 2Ã—2:
[2][1]
[2][1]

Final solution (3 squares):
[2][1][1]
[2][1][1]
```

### Edge Cases to Consider:
- Square rectangle (n=m)
- Very different dimensions
- Prime number dimensions
- Small rectangles (1Ã—n)
- Maximum size (13Ã—13)

### Common Pitfalls:
1. Not trying all possible placements
2. Wrong order of square placement
3. Missing optimal solutions
4. Inefficient state tracking

### Optimization Techniques:
1. **Placement Strategy**:
   - Start from largest possible squares
   - Fill from bottom-left corner
   - Track minimum squares needed

2. **Pruning**:
   - Stop if current count â‰¥ best found
   - Use geometric properties for bounds
   - Cache impossible configurations

### Time and Space Analysis:
- Time Complexity: Exponential
  - Each position has multiple square choices
  - Need to try various combinations
- Space Complexity: O(nÃ—m)
  - Track state of rectangle
  - Recursion stack depth

### Similar Problems:
- Perfect Squares
- The Skyline Problem
- Maximal Square

### Geometric Properties:
1. Optimal solution properties:
   - Larger squares are generally better
   - Corner placements often optimal
   - Some configurations impossible

2. Special cases:
   - When n divides m (or vice versa)
   - Perfect squares
   - Prime dimensions

### Useful Resources:
- [Rectangle Decomposition](https://en.wikipedia.org/wiki/Rectangle_decomposition)
- [Geometric Algorithms](https://www.cs.cmu.edu/~ckingsf/class/02713-s13/)

**Time Complexity** : O(n<sup>2</sup>*m<sup>2</sup>)<br>
**Space Complexity** : O(n*m)

```java
    int ans = Integer.MAX_VALUE,
        len, bre;
    public int tilingRectangle(int n, int m) {
        len = n;
        bre = m;
        backTrack(0, 0, new boolean[len][bre], 0);
        return ans;
    }
    // (r, c) is the starting point for selecting a square
    // rect records the status of current rectangle
    // cnt is the number of squares we have covered
    private void backTrack(int r, int c, boolean[][] rect, int count) {
        // optimization 1: The current cnt >= the current answer
        if (count >= ans) return;

		// Successfully cover the whole rectangle
        if (r >= len) {
            ans = count;
            return;
        }
        
        // Successfully cover the area [0, ..., n][0, ..., c] => Move to next row
        if (c >= bre) {
            backTrack(r + 1, 0, rect, count);
            return;
        }
        
        // If (r, c) is already covered => move to next point (r, c+1)
        if (rect[r][c]) {
            backTrack(r, c + 1, rect, count);
            return;
        }
        
        // Try all the possible size of squares starting from (r, c)
        for (int k = Math.min(len - r, bre - c);
             k >= 1 && isAvailable(rect, r, c, k);
             k--) {
            cover(rect, r, c, k);
            backTrack(r, c + 1, rect, count + 1);
            uncover(rect, r, c, k);
        }
    }
    private boolean isAvailable(boolean[][] rect, int r, int c, int k) {
        for (int i = 0; i < k; i++)
            for (int j = 0; j < k; j++)
                if (rect[r + i][c + j]) return false;
        
        return true;
    }
    private void cover(boolean[][] rect, int r, int c, int k) {
        for (int i = 0; i < k; i++)
            for (int j = 0; j < k; j++)
                rect[r + i][c + j] = true;
    }
    private void uncover(boolean[][] rect, int r, int c, int k) {
        for (int i = 0; i < k; i++)
            for (int j = 0; j < k; j++)
                rect[r + i][c + j] = false;
    }
```
