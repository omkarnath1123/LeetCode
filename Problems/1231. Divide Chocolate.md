Link: [1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/) <br>
Tag : **Hard**<br>
Lock: **Premium**

You have one chocolate bar that consists of some chunks. Each chunk has its own sweetness given by the array `sweetness`.

You want to share the chocolate with your `k` friends so you start cutting the chocolate bar into `k + 1` pieces using `k` cuts, each piece consists of some **consecutive** chunks.

Being generous, you will eat the piece with the **minimum total sweetness** and give the other pieces to your friends.

Find the **maximum total sweetness** of the piece you can get by cutting the chocolate bar optimally.

**Example 1:**
```
Input: sweetness = [1,2,3,4,5,6,7,8,9], k = 5
Output: 6
Explanation: You can divide the chocolate to [1,2,3], [4,5], [6], [7], [8], [9]
```

**Example 2:**
```
Input: sweetness = [5,6,7,8,9,1,2,3,4], k = 8
Output: 1
Explanation: There is only one way to cut the bar into 9 pieces.
```

**Example 3:**
```
Input: sweetness = [1,2,2,1,2,2,1,2,2], k = 2
Output: 5
Explanation: You can divide the chocolate to [1,2,2], [1,2,2], [1,2,2]
```

**Constraints:**
-   `0 <= k < sweetness.length <= 104`
-   `1 <= sweetness[i] <= 105`

**Solution:**
- [x] [[Binary Search]] + [[Greedy]]

## Detailed Intuition

### How to Think About the Solution:
1. This is a "minimize the maximum" or "maximize the minimum" type problem
2. When you see this pattern, think binary search on the answer
3. Instead of searching for a value, we're searching for the optimal sweetness

### Key Insights:
1. We can test any potential minimum sweetness value
2. If we can achieve a sweetness X, we can also achieve any value < X
3. This monotonic property makes binary search possible

### Step-by-Step Approach:
1. **Binary Search Setup**:
   - Lower bound: min(sweetness)
   - Upper bound: sum(sweetness)/(k+1)
   - Search for maximum valid sweetness

2. **Validation Function**:
   - Try to cut chocolate into k+1 pieces
   - Each piece must have >= current sweetness
   - Count how many valid pieces we can make

### Visual Guide:
```
Example: sweetness = [1,2,3,4,5,6,7,8,9], k = 5
Target: 6 pieces (k+1 = 6)

Binary Search Process:
1. Initial range: [1, 7]
2. Try mid = 4:
   [1,2,3,4][5,6][7][8][9] ✅ (can make 5 cuts)
3. Try mid = 6:
   [1,2,3,4,5,6][7,8][9] ❌ (can't make 5 cuts)
4. Try mid = 5:
   [1,2,3,4,5][6,7][8][9] ❌
5. Final answer: 4
```

### Edge Cases to Consider:
- All pieces have same sweetness
- Minimum possible cuts (k=1)
- Maximum possible cuts (k=n-1)
- Very large sweetness values
- Large number of pieces

### Common Pitfalls:
1. Not handling integer overflow
2. Wrong binary search boundaries
3. Off-by-one errors in counting pieces
4. Not considering the k+1 pieces requirement

### Optimization Techniques:
1. **Binary Search Bounds**:
   - Tighter initial bounds = faster convergence
   - Use sum/(k+1) as upper bound

2. **Early Termination**:
   - If current count > k+1, might still be valid
   - If current count < k+1, definitely invalid

### Time and Space Analysis:
- Time Complexity: O(N * log(S)) where:
  - N = length of array
  - S = sum of sweetness values
- Space Complexity: O(1)

### Similar Problems:
- Split Array Largest Sum
- Capacity To Ship Packages Within D Days
- Koko Eating Bananas

### Useful Resources:
- [Binary Search on Answer](https://leetcode.com/discuss/general-discussion/786126/python-powerful-ultimate-binary-search-template)
- [Monotonic Search Space](https://leetcode.com/articles/introduction-to-binary-search/)

**Algorithm**
1.  Set up the two boundaries (`left` and `right`) of the search space, that is: `left = 1`, `right = total / (k + 1)`.
2.  Get the middle value from `left` and `right`, that is `mid = (left + right + 1) / 2`.
3.  Check if we can cut the chocolate into `k + 1` pieces with sweetness no less than `mid`, where `mid` is our current guess at the optimal workable value.
4.  If cutting the chocolate bar in this method results in everyone receiving a piece of chocolate that is at least as sweet as `mid`, then let `left = mid`. Otherwise, let `right = mid - 1`.
5.  Repeat the **steps 2, 3, and 4** until the two boundaries overlap, i.e., `left == right`, which means that you have found the maximum total sweetness of a piece you can receive by cutting the chocolate bar optimally. We can return either `left` or `right` as the answer.

```
s = the total sweetness of the chocolate bar
n = the number of chunks in the chocolate

**Time Complexity** : O(n log(s))<br>
**Space Complexity** : O(1)

```java
    public int maximizeSweetness(int[] sweetness, int chunks) {
        
        long min = Integer.MAX_VALUE,
             sum = 0;
        for (int piece : sweetness) {
            min = Math.min(min, piece);
            sum = sum + piece;
        }
            
        long low = min, 
            high = sum,
            minSweetness = 0,
            mid;
        while (low <= high) {
            mid = low + (high - low) / 2;
            
            if (canDivide(sweetness, chunks, mid)) {
                minSweetness = mid;
                low = mid + 1;
            } else
                high = mid - 1;
        }
        return (int) minSweetness;
    }
    private boolean canDivide(int[] sweetness, int chunks, long minSweetness) {
        
        long currSweet = 0;
        
        for (int sweet : sweetness) {
            if (currSweet >= minSweetness) {
                chunks--;
                currSweet = sweet;
            } else
                currSweet = currSweet + sweet;
        }
        if (currSweet >= minSweetness) chunks--;
        return chunks <= -1;
    }
```
