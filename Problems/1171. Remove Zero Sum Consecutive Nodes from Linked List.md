Link: [1171.Â Remove Zero Sum Consecutive Nodes from Linked List](https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/) <br>
Tag : **Medium**<br>
Lock: **Normal**

Given theÂ `head`Â of a linked list, we repeatedly delete consecutive sequences of nodes that sum toÂ `0`Â until there are no such sequences.

After doing so, return the head of the final linked list.Â  You may return any such answer.

(Note that in the examples below, all sequences are serializations ofÂ `ListNode`Â objects.)

**Example 1:**

```
Input: head = [1,2,-3,3,1]
Output: [3,1]
Note: The answer [1,2,1] would also be accepted.
```

**Example 2:**

```
Input: head = [1,2,3,-3,4]
Output: [1,2,4]
```

**Example 3:**

```
Input: head = [1,2,3,-3,-2]
Output: [1]
```

**Constraints:**

- The given linked list will contain betweenÂ `1`Â andÂ `1000`Â nodes.
- Each node in the linked list hasÂ `-1000 <= node.val <= 1000`.

## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **Prefix Sum with Linked List Concept:**
   - Track cumulative sum at each node
   - Same sum means zero-sum sequence
   - Need to handle node deletion
   - Consider overlapping sequences

2. **Key Insights:**
   - Store prefix sum â†’ node mapping
   - Later occurrence overrides earlier
   - Process list in two passes
   - Handle edge cases with dummy head

### ðŸ” Edge Cases to Consider
- Single node list
- All nodes sum to zero
- Multiple zero-sum sequences
- Overlapping sequences
- Negative numbers
- Maximum list length (1000)
- Maximum node value (Â±1000)
- Zero value nodes
- Entire list sums to zero
- No zero-sum sequences

### ðŸŽ¯ Solution Approaches

1. **Two-Pass Prefix Sum**
   ```pseudo
   function removeZeroSum(head):
       dummy = new ListNode(0)
       dummy.next = head
       prefix_sum = 0
       
       # First pass: Build prefix sum map
       # Last occurrence of sum will remain
       curr = dummy
       sum_to_node = {}
       while curr:
           prefix_sum += curr.val
           sum_to_node[prefix_sum] = curr
           curr = curr.next
       
       # Second pass: Connect nodes
       prefix_sum = 0
       curr = dummy
       while curr:
           prefix_sum += curr.val
           curr.next = sum_to_node[prefix_sum].next
           curr = curr.next
       
       return dummy.next
   ```
   Time: O(n), Space: O(n)

### ðŸ“ˆ Visual Explanation
```
Example: [1,2,-3,3,1]
Dummy node: [0,1,2,-3,3,1]

First Pass (prefix sums):
0 â†’ node(0)
1 â†’ node(1)
3 â†’ node(2)
0 â†’ node(-3)  # Overwrites node(0)
3 â†’ node(3)   # Overwrites node(2)
4 â†’ node(1)

Second Pass:
0: connects to node after -3 (3)
3: connects to node after 3 (1)
4: end of list
```

### ðŸ› ï¸ Implementation Tips
1. Use dummy head node
2. Handle null checks
3. Store node references
4. Track prefix sums carefully
5. Process list in two passes

### ðŸ“Š Complexity Analysis
- Time Complexity: O(n)
  - Two passes through list
  - Hash map operations O(1)
- Space Complexity: O(n)
  - Store prefix sum map
  - No recursion stack

### ðŸ”— Related Patterns
- Prefix Sum
- Hash Table
- Linked List Manipulation
- Similar Problems:
  - Subarray Sum Equals K
  - Contiguous Array
  - Delete Nodes with Sum Zero

### ðŸ“ Example Processing Flow
```
Input: [1,2,-3,3,1]

1. Add dummy: [0,1,2,-3,3,1]
   
2. First Pass (sum â†’ node):
   0: 0 â†’ [0,...]
   1: 1 â†’ [1,...]
   3: 3 â†’ [2,...]
   0: 0 â†’ [-3,...] âœ“
   3: 3 â†’ [3,...]
   4: 4 â†’ [1]

3. Second Pass:
   At 0: Connect to node after -3
   Result: [3,1]
```

### âš ï¸ Common Mistakes to Avoid
1. Not using dummy node
2. Wrong prefix sum calculation
3. Missing node connections
4. Not handling zero values
5. Incorrect sequence removal

```java
class Solution {
    public ListNode removeZeroSumSublists(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        
        Map<Integer, ListNode> sumToNode = new HashMap<>();
        int prefixSum = 0;
        
        // First pass: record last node for each prefix sum
        ListNode current = dummy;
        while (current != null) {
            prefixSum += current.val;
            sumToNode.put(prefixSum, current);
            current = current.next;
        }
        
        // Second pass: reconnect nodes
        prefixSum = 0;
        current = dummy;
        while (current != null) {
            prefixSum += current.val;
            current.next = sumToNode.get(prefixSum).next;
            current = current.next;
        }
        
        return dummy.next;
    }
}
3. Head of list might be part of zero-sum sequence

### Step-by-Step Approach:
1. **Setup**:
   - Create dummy node before head
   - Track prefix sums in hashmap
   - Map prefix sum to node position

2. **Two-Pass Strategy**:
   First Pass:
   - Calculate prefix sums
   - Store latest node for each sum
   
   Second Pass:
   - Use stored positions to skip zero-sum sequences

### Visual Guide:
```
Example: [1,2,-3,3,1]

Prefix Sums:
dummy: 0
1:     1
1,2:   3
1,2,-3: 0 (found zero sum: 2,-3)
1,2,-3,3: 3
1,2,-3,3,1: 4

After Processing:
[3,1] (or [1,2,1])

Key Observation:
When prefix sum repeats (0),
sequence in between sums to zero
```

### Edge Cases to Consider:
- Single node list
- All nodes form zero sum
- Multiple zero-sum sequences
- Nested zero-sum sequences
- Zero value nodes

### Common Pitfalls:
1. Not using dummy node
2. Missing overlapping sequences
3. Incorrect pointer updates
4. Not handling head removal

### Optimization Techniques:
1. **Two-Pass Approach**:
   - First pass: Find all zero-sum sequences
   - Second pass: Remove them efficiently

2. **Memory Management**:
   - Clear references in deleted nodes
   - Update pointers carefully

### Time and Space Analysis:
- Time Complexity: O(n), two passes through list
- Space Complexity: O(n) for hashmap

### Similar Problems:
- Subarray Sum Equals K
- Remove Duplicates from Sorted List
- Linked List Cycle

### Implementation Tips:
1. Use dummy node to handle head changes
2. Store node references, not just values
3. Update pointers carefully during removal
4. Consider using two passes for clarity

### Useful Resources:
- [Prefix Sum Technique](https://leetcode.com/articles/prefix-sum-array/)
- [Linked List Manipulation](https://www.geeksforgeeks.org/linked-list-set-1-introduction/)

1. If it's a prefix that we've never seen, we setÂ `m[prefix] = cur`.
2. If we have seen this prefix,Â `m[prefix]`Â is the node we achieve this prefix sum.  
    We want to skip all nodes betweenÂ `m[prefix]`Â andÂ `cur.next`Â (exclusive).  
    So we simplely doÂ `m[prefix].next = cur.next`.

```
n = length of string

**Time Complexity** : O(n)<br>
**Space Complexity** : O(1)

```java
    public ListNode removeZeroSumSublists(ListNode head) {
        
        Map<Integer, ListNode> sumMap = new HashMap<>();
        
        int total = 0;
        ListNode start = new ListNode(0, head);
        sumMap.put(0, start);
        
        for (ListNode iter = start.next;
             iter != null; 
             iter = iter.next) {
            
            total = total + iter.val;
            if (sumMap.containsKey(total)) {
                ListNode other = sumMap.get(total);
                
                int sum = total;
                ListNode j = other.next;
                while (j != iter) {
                    sum = sum + j.val;
                    sumMap.remove(sum);
                    j = j.next;
                }
                
                other.next = iter.next;
            } else {
                sumMap.put(total, iter);
            }
        }
        return start.next;
    }
```
