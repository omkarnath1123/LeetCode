Link: [2333. Minimum Sum of Squared Difference](https://leetcode.com/problems/minimum-sum-of-squared-difference/description/) <br>
Tag : **Medium**<br>
Lock: **Normal**

You are given two positive **0-indexed** integer arrays `nums1` and `nums2`, both of length `n`.

The **sum of squared difference** of arrays `nums1` and `nums2` is defined as the **sum** of `(nums1[i] - nums2[i])2` for each `0 <= i < n`.

You are also given two positive integers `k1` and `k2`. You can modify any of the elements of `nums1` by `+1` or `-1` at most `k1` times. Similarly, you can modify any of the elements of `nums2` by `+1` or `-1` at most `k2` times.

Return _the minimum **sum of squared difference** after modifying array_ `nums1` _at most_ `k1` _times and modifying array_ `nums2` _at most_ `k2` _times_.

**Note**: You are allowed to modify the array elements to become **negative** integers.

**Example 1:**

```
Input: nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0
Output: 579
Explanation: The elements in nums1 and nums2 cannot be modified because k1 = 0 and k2 = 0. 
The sum of square difference will be: (1 - 2)2 + (2 - 10)2 + (3 - 20)2 + (4 - 19)2 = 579.
```

**Example 2:**

```
Input: nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1
Output: 43
Explanation: One way to obtain the minimum sum of square difference is: 
- Increase nums1[0] once.
- Increase nums2[2] once.
The minimum of the sum of square difference will be: 
(2 - 5)2 + (4 - 8)2 + (10 - 7)2 + (12 - 9)2 = 43.
Note that, there are other ways to obtain the minimum of the sum of square difference, but there is no way to obtain a sum smaller than 43.
```

**Constraints:**

- `n == nums1.length == nums2.length`
- `1 <= n <= 105`
- `0 <= nums1[i], nums2[i] <= 105`
- `0 <= k1, k2 <= 109`

**Solution:**

- [x] [[Greedy]] + [[Heap]]

## Detailed Intuition

1. Count the differences between each nums1[i] and nums2[i] and store them into an int[100_001], as nums is between 0 and 100_000.
2. Let's look at the example of [1,4,10,12], [4,8,6,7]. k1= 1, k2 =1
    Looking at the pairs of abs diff we have 3,4,4,5.
    So a total of 16 diff points with k = 2.
    As we observe, if we use the k operations on the first pair, we can decrease 3 to 1.
    but this would only help with 3^2 (9) -> 1. So we decrease the totam sum diff by 8.
    However, if we operate on the diff of 5, this would have much more impact.
    5 - 1 => (4^2)25 - 16 . so we save 9 points by using 1 k
    5 - 2 => (3^2) 25 - 9. So we save 16 points.
3. As we can see, we need to operate on the highest diff, lowering them.
4. As we have counted them on step #1, we would have an array like this
    [0,0,0,1,2,1] : 1 diff of 3, 2 of 4 and 1 of 5.
5. While k is > 0 (k1 + k2), start from the back (highest) and decrease it one group at a time.
    So make all 5 diffs into 4 diff, only if their cardinal is <= k. If it's greater than k, we can only
    lower k diff to diff -1.
    So [0,0,0,1,2,1] and k = 2 => [0,0,0,1,3,0] and k =1
    We have 3 diff of 4 and just k =1 so we can turn one 4 into a 3.
    => [0,0,0,2,2,0]. Thus. the diff becomes 2 of 3 and 2 of 4.

### Edge cases

- All differences are zero (nums1 equals nums2). The answer is 0 regardless of k1/k2; any edits must preserve this.
- k1 + k2 >= sum(abs(nums1[i] - nums2[i])): there are enough operations to reduce every absolute difference to 0, so the answer is 0. Detect this early to short-circuit work.
- Very large k (up to 1e9) but small total differences: don't iterate per operation. Use counts/batching to apply many operations at once.
- Large n (up to 1e5) and large values (up to 1e5): avoid per-value heaps of size k; use counting buckets (0..maxDiff) or a TreeMap of counts to move groups down efficiently.
- When dec (k1+k2) is less than the frequency of the current largest diff, you only reduce a subset of that group; handle partial reductions carefully (distribute remainder among top elements).
- Single-element arrays and tiny arrays: algorithm still applies; ensure types (long) are used for return value.
- Overflow concerns: max diff <= 1e5; diff^2 <= 1e10; sum over n (1e5) can be up to ~1e15 — fits in signed 64-bit but not 32-bit. Use long for sums and intermediate products.
- Negative values after operations: allowed by the problem statement, but thinking in terms of absolute differences makes the algorithm unaffected by sign because each +/- on either array changes the absolute difference by at most 1 in the desired direction.
- Off-by-one when moving diffs down multiple levels: when computing how many operations are needed to drop a group of counts from level d to next level d', compute need = counts_cumulative * (d - d') and compare accurately with remaining dec.

### How to think about the solution (intuition and implementation strategies)

- Marginal benefit (why greedy works): reducing a difference from d to d-1 decreases the squared term by d^2 - (d-1)^2 = 2*d - 1. This marginal benefit increases with d, so it's always optimal to spend an operation on the currently largest absolute difference.

- Greedy scheduling options:
  - Max-heap approach: repeatedly pop the largest diff, decrement it, and push back. This clearly follows the greedy rule but is O(k log n) and fails when k is huge (up to 1e9).
  - Bucket / counting approach: since diffs are bounded (0..100000), count frequencies and move counts from high buckets to lower buckets in chunks. This lets you apply many operations in O(maxDiff + n) time by processing groups instead of single operations.
  - TreeMap / ordered map of counts (descending): like the provided code, store counts of each diff and repeatedly move an entire bucket down one or more levels until dec runs out. This is compact and works well when diffs are sparse.
  - Binary-search threshold: find the final cutoff value t such that reducing all diffs greater than t down to t uses <= dec, then distribute the leftover operations to lower some of the diffs from t to t-1. This allows an O(n log M) solution where M is maxDiff.

- Implementation sketch (bucket/tree approach, efficient and robust):
  1. Compute diffs: d[i] = abs(nums1[i] - nums2[i]) and build counts array or map.
  2. Let dec = k1 + k2. Remove zeros from consideration.
  3. Iterate from maxDiff downwards. Keep a running cumulative count of how many entries are >= current level (or merge buckets as you lower them). For level d, compute how many ops needed to lower all current items to the next level d' (either the next non-empty bucket or 0): need = cumulative_count * (d - d'). If need <= dec, apply it (move counts), subtract from dec, and continue. If need > dec, compute full_steps = dec / cumulative_count and remainder = dec % cumulative_count. Lower all current items by full_steps, then lower remainder items by one extra and stop (dec becomes 0).
  4. After dec is exhausted, compute the final answer by summing count[level] * (long)level * level over all remaining levels.

- Data types and performance notes:
  - Use long for dec accumulations and the final sum.
  - Avoid simulating single +/- operations when dec is large; always batch by groups.
  - Complexity: O(n + M) with a bucket approach (M = maxDiff, <= 1e5). With TreeMap, cost is O(number_of_distinct_diffs * log distinct) which is fine for sparse diffs.

**Summary**: think in terms of marginal gain (2*d - 1) to justify greedy on the largest diff, then implement the greedy in a batched way using counts/buckets or an ordered map so you can handle huge k efficiently and avoid per-operation loops.

```java
    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {

        int len = nums1.length;
        int dec = k1 + k2;
        TreeMap<Integer, Integer> freqMap = new TreeMap<>(Collections.reverseOrder());
        for (int i = 0; i < len; i++)
            freqMap.merge(Math.abs(nums1[i] - nums2[i]), 1, Integer::sum);

        freqMap.remove(0);
        while (!freqMap.isEmpty() && dec != 0) {
            Integer diff = freqMap.firstKey();
            Integer freq = freqMap.remove(diff);

            if (freq > dec) {
                Integer otherFreq = freq - dec;
                freq = freq - otherFreq;
                freqMap.merge(diff, otherFreq, Integer::sum);
            }

            diff--;
            dec = dec - freq;
            freqMap.merge(diff, freq, Integer::sum);
            freqMap.remove(0);
        }

        long sum = 0;
        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
            sum = sum + (long) Math.pow(entry.getKey(), 2) * (long) entry.getValue();
        }
        return sum;
    }
```
