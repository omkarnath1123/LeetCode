Link: [7. Remove Element](https://leetcode.com/problems/remove-element/description/?envType=study-plan-v2&envId=top-interview-150) <br>
Tag : **Easy**<br>
Lock: **Normal**

Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm). The order of the elements may be changed. Then return _the number of elements in_ `nums` _which are not equal to_ `val`.

Consider the number of elements in `nums` which are not equal to `val` be `k`, to get accepted, you need to do the following things:

- Change the array `nums` such that the first `k` elements of `nums` contain the elements which are not equal to `val`. The remaining elements of `nums` are not important as well as the size of `nums`.
- Return `k`.

**Custom Judge:**

The judge will test your solution with the following code:

```
int[] nums = [...]; // Input array
int val = ...; // Value to remove
int[] expectedNums = [...]; // The expected answer with correct length.
                            // It is sorted with no values equaling val.

int k = removeElement(nums, val); // Calls your implementation

assert k == expectedNums.length;
sort(nums, 0, k); // Sort the first k elements of nums
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```

If all assertions pass, then your solution will be **accepted**.

**Example 1:**

```
Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2,_,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

**Example 2:**

```
Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5, nums = [0,1,4,0,3,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

**Constraints:**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

**Solution:**

- [x] [[Two Pointer]]

## Detailed Intuition

Goal: keep the first k elements of the array as the elements that are not equal to val, doing the work in-place and with O(1) extra memory.

High-level idea (two-pointer / slow-fast):
- Use two pointers: a "write" pointer (call it i or `one` in the provided code) and a "scan" pointer (call it j or `two`).
- The invariant before processing index j is: all elements before index `one` (i.e., indices [0..one-1]) are values we want to keep (they are != val).
- We scan the array with `two`. When nums[two] != val we copy or swap that value into nums[one] and increment `one`. When nums[two] == val we simply skip it.
- After the loop finishes, `one` is the count k of elements kept and the first k slots of the array contain all values != val (order among them may change depending on whether you swap or overwrite).

Why this works (invariants and correctness):
- The invariant guarantees we never overwrite a kept element with a value we haven't inspected yet: we only write into index `one` when we've found a new keepable value at `two`.
- Each element is examined exactly once by `two`, and each kept element causes exactly one write to nums[one], so the algorithm is linear time.

Implementation notes (swap vs overwrite):
- The provided Java solution uses an explicit swap between nums[one] and nums[two]. That preserves the original value at nums[two] in the tail of the array, but that's unnecessary for correctness because the judge ignores elements beyond the first k.
- A slightly simpler and more common variant is to overwrite: if (nums[two] != val) nums[one++] = nums[two]; This avoids an extra temporary variable and is still in-place.

Step-by-step example (nums = [3,2,2,3], val = 3):
1. one = 0, two = 0 -> nums[0] == 3 (== val), skip.
2. two = 1 -> nums[1] == 2 (!= val): write nums[one] = 2, one -> 1. Array becomes [2,2,2,3].
3. two = 2 -> nums[2] == 2 (!= val): write nums[one] = 2, one -> 2. Array now [2,2,2,3].
4. two = 3 -> nums[3] == 3 (== val), skip.
Finish: return one == 2. First two elements are the kept values.

Edge cases to think about and test:
- Empty array (nums.length == 0): loop does nothing, return 0.
- All elements equal to val: no element is written, return 0 and array contents beyond k are unimportant.
- No elements equal to val: every element is kept, return nums.length and array remains (or becomes a copy) of original values in first k positions.
- Single-element array: works for both cases where the single element equals val (return 0) and where it doesn't (return 1).
- val appears only at the beginning, only at the end, or interleaved with other values: algorithm handles all positions uniformly.
- Repeated values and duplicates: algorithm doesn't care about duplicates; duplicate non-val items will be copied/kept in the same order if you overwrite, or may move if you swap, but the judge sorts the first k elements before comparing so order doesn't matter for correctness.
- Very small or very large k relative to n: algorithm's performance is unchanged (O(n) time, O(1) extra space).

When to prefer the alternative "swap with tail" approach:
- If the number of elements equal to val is small and you want fewer writes, another two-pointer pattern uses a left pointer i scanning forward and a right pointer n-1 scanning backward. When nums[i] == val you swap it with nums[right] and decrement right, and do not increment i. This reduces the number of writes when val is rare but does not preserve order and complicates traversal slightly. It also means you must be careful not to inspect the moved value at i again without proper checks.

Complexity (short reminder):
- Time: O(n) because every element is visited once by the scan pointer.
- Space: O(1) extra space — the algorithm modifies the input array in-place and only needs constant extra variables (caveat: the file's existing summary lists space as O(n), but the two-pointer in-place approach uses O(1) extra memory).

Testing checklist (quick manual tests):
- [] nums = [] , val = 0 -> expect k = 0
- [] nums = [1,1,1], val = 1 -> expect k = 0
- [] nums = [1,2,3], val = 4 -> expect k = 3
- [] nums = [2,2,3,2], val = 2 -> expect k = 1 with the kept element 3
- [] nums = [3,2,2,3], val = 3 -> expect k = 2 with kept values [2,2]


```java
    public int removeElement(int[] nums, int val) {
        
        int one = 0,
            length = nums.length,
            temp;
        for (int two = 0; two < length; two++) {
            if (nums[two] != val) {
                temp = nums[one];
                nums[one] = nums[two];
                nums[two] = temp;
                one++;
            }
        }
        return one;
    }
```
