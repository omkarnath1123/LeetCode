Link: [1230.Â Toss Strange Coins](https://leetcode.com/problems/toss-strange-coins/) <br>
Tag : **Medium**<br>
Lock: **Premium**

You have some coins.Â  TheÂ `i`-thÂ coin has a probabilityÂ `prob[i]`Â of facing heads when tossed.

Return the probability that the number of coins facing heads equalsÂ `target`Â if you toss every coin exactly once.

**Example 1:**
```
Input: prob = [0.4], target = 1
Output: 0.40000
```

**Example 2:**
```
Input: prob = [0.5,0.5,0.5,0.5,0.5], target = 0
Output: 0.03125
```

**Constraints:**
-   `1 <= prob.length <= 1000`
-   `0 <= prob[i] <= 1`
-   `0 <= target`Â `<= prob.length`
-   Answers will be accepted as correct if they are withinÂ `10^-5`Â of the correct answer.

## Detailed Intuition

### ğŸ’¡ How to Think About the Solution

1. **Probability Combination Concept:**
   - Each coin has independent probability
   - Need to count ways to get target heads
   - Use DP to build up probabilities
   - Each toss affects overall probability

2. **Key Insights:**
   - State represents coins used and heads seen
   - Two possible outcomes for each coin
   - Multiply probabilities for independence
   - Sum different ways to reach target

### ğŸ” Edge Cases to Consider
- Single coin (prob.length = 1)
- Target = 0 (all tails)
- Target = length (all heads)
- All probabilities = 0.5
- Extreme probabilities (0 or 1)
- Maximum coins (1000)
- Target > number of coins
- Very small probabilities
- Floating point precision

### ğŸ¯ Solution Approaches

1. **Dynamic Programming Approach**
   ```pseudo
   function probabilityOfHeads(prob, target):
       n = prob.length
       dp = new double[n+1][target+1]
       dp[0][0] = 1.0  # Base case
       
       for i in range(1, n+1):
           p = prob[i-1]
           for j in range(0, min(i+1, target+1)):
               # Don't get head with current coin
               if j <= i:
                   dp[i][j] += dp[i-1][j] * (1-p)
               # Get head with current coin
               if j > 0:
                   dp[i][j] += dp[i-1][j-1] * p
       
       return dp[n][target]
   ```
   Time: O(nÃ—target), Space: O(nÃ—target)

### ğŸ“ˆ Visual Explanation
```
Example: prob=[0.5,0.5], target=1

DP Table (probability of j heads using i coins):
     j=0   j=1   j=2
i=0  1.0   0     0
i=1  0.5   0.5   0
i=2  0.25  0.5   0.25

For i=1, j=1:
- Get head (0.5): 1.0 * 0.5
- Get tail (0.5): 0.0 * 0.5
Total: 0.5

For i=2, j=1:
- Previous 1 head (0.5) * get tail (0.5)
- Previous 0 head (0.5) * get head (0.5)
Total: 0.5
```

### ğŸ› ï¸ Implementation Tips
1. Use double precision for calculations
2. Initialize base case dp[0][0] = 1.0
3. Handle floating point comparisons
4. Optimize space if needed
5. Consider numerical stability

### ğŸ“Š Complexity Analysis
- Time Complexity: O(nÃ—target)
  - n = number of coins
  - target = target heads
- Space Complexity: O(nÃ—target)
  - Can optimize to O(target)

### ğŸ”— Related Patterns
- Dynamic Programming
- Probability Calculations
- State Transition
- Similar Problems:
  - Knight Probability in Chessboard
  - Soup Servings
  - Random Pick with Weight

### ğŸ“ Example Processing Flow
```
Input: prob=[0.4], target=1

1. Initialize:
   dp[0][0] = 1.0

2. Process coin 1 (p=0.4):
   dp[1][0] = dp[0][0] * 0.6 = 0.6
   dp[1][1] = dp[0][0] * 0.4 = 0.4

Result: 0.4 (40% chance of exactly one head)
```

### âš ï¸ Common Mistakes to Avoid
1. Not handling floating point precision
2. Incorrect probability multiplication
3. Missing base cases
4. Integer division instead of float
5. Not considering all possible paths

```java
public double probabilityOfHeads(double[] prob, int target) {
    int n = prob.length;
    double[][] dp = new double[n + 1][target + 1];
    dp[0][0] = 1.0;
    
    for (int i = 1; i <= n; i++) {
        double p = prob[i-1];
        for (int j = 0; j <= Math.min(i, target); j++) {
            // Don't get head
            dp[i][j] += dp[i-1][j] * (1-p);
            // Get head
            if (j > 0) {
                dp[i][j] += dp[i-1][j-1] * p;
            }
        }
    }
    
    return dp[n][target];
}

```java
    public double probabilityOfHeads(double[] prob, int target) {
        
        int len = prob.length;
        double[][] store = new double[len + 1][len + 1];
        store[0][0] = 1.0;
        
        for (int i = 1; i <= len; i++) {
            for (int j = 0; j <= i; j++)
                if (j == 0)
                    store[i][j] = store[i - 1][j] * (1.0 - prob[i - 1]);
                else 
                    store[i][j] = store[i - 1][j - 1] * prob[i - 1] + 
                                  store[i - 1][j] * (1.0 - prob[i - 1]);
        }
        return store[len][target];
    }
```


