Link: [1197. Minimum Knight Moves](https://leetcode.com/problems/minimum-knight-moves/) <br>
Tag : **Medium**<br>
Lock: **Premium**

In an **infinite** chess board with coordinates from `-infinity` to `+infinity`, you have a **knight** at square `[0, 0]`.

A knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.

![](https://assets.leetcode.com/uploads/2018/10/12/knight.png)

Return _the minimum number of steps needed to move the knight to the square_ `[x, y]`. It is guaranteed the answer exists.

**Example 1:**
```
Input: x = 2, y = 1
Output: 1
Explanation: [0, 0] → [2, 1]
```

**Example 2:**
```
Input: x = 5, y = 5
Output: 4
Explanation: [0, 0] → [2, 1] → [4, 2] → [3, 4] → [5, 5]
```

**Constraints:**
-   `-300 <= x, y <= 300`
-   `0 <= |x| + |y| <= 300`

**Solution:**

- [x] [[Breath First Search]]

## Detailed Intuition

### How to Think About the Solution:
1. Think of this as a shortest path in infinite space
2. Can use symmetry to reduce search space
3. BFS guarantees shortest path
4. Need efficient state space exploration

### Key Insights:
1. Problem has symmetry - can work in first quadrant
2. Knight moves create a graph structure
3. Optimal path stays relatively close to direct line
4. Can bound search space despite infinite board

### Step-by-Step Approach:
1. **Space Reduction**:
   - Convert coordinates to first quadrant
   - Use absolute values of x,y
   - Search within bounded region

2. **BFS Implementation**:
   - Start from (0,0)
   - Track visited positions
   - Try all 8 knight moves
   - Track moves count

### Visual Guide:
```
Example: Target (2,1)

Knight's possible moves from (0,0):
   2  →  →  ↑
   1  *  →  →  ↑
   0  K  →  →  →
  -1  *  →  →  ↓
  -2  →  →  ↓
    0  1  2  3

K: Knight's starting position
*: Possible first moves
Target can be reached in one move!
```

### Edge Cases to Consider:
- Target at (0,0)
- Nearby targets
- Far targets
- Diagonal targets
- Maximum distance (300,300)

### Common Pitfalls:
1. Exploring unnecessary space
2. Not using symmetry
3. Inefficient state tracking
4. Memory limit exceeded

### Optimization Techniques:
1. **Search Space Reduction**:
   - Use coordinate symmetry
   - Bound exploration area
   - Early termination

2. **Memory Management**:
   - Efficient visited set
   - Coordinate compression
   - Direction optimization

### Time and Space Analysis:
- Time Complexity: O(max(x,y)²)
  - Search area grows quadratically
  - Most moves stay within bounded region
- Space Complexity: O(max(x,y)²)
  - Visited positions storage
  - Queue for BFS

### Similar Problems:
- Knight Probability in Chessboard
- The Maze
- Shortest Path in Binary Matrix

### Mathematical Properties:
1. Distance Properties:
   - Minimum moves ≤ max(|x|,|y|)
   - Triangle inequality applies
   - Symmetry in all quadrants

2. Move Patterns:
   - 8 possible moves
   - Forms connected graph
   - Some positions unreachable in odd moves

### Useful Resources:
- [Knight's Tour Problem](https://en.wikipedia.org/wiki/Knight%27s_tour)
- [BFS on Infinite Grids](https://www.geeksforgeeks.org/bfs-on-infinite-grids/)
**Time Complexity** : O(max (x,y)<sup>2</sup>)<br>
**Space Complexity** : O(max (x,y)<sup>2</sup>)

```java
    public int minKnightMoves(int x, int y) {
        
        x = Math.abs(x);
        y = Math.abs(y);
        int[][] dirs = new int[][]{
            {2,1}, {1,2}, {2,-1},
            {-1, 2}, {-2, 1},
            {1, -2}, {-2, -1}, {-1, -2}
        };
        Cell source = new Cell(0, 0);
        Set<String> visited = new HashSet<>();
        Deque<Cell> queue = new LinkedList<>();
        queue.add(source);
        visited.add(source.hash());
        
        for (int depth = 0; !queue.isEmpty(); depth++)
            for (int size = queue.size(); size > 0; size--) {
                Cell poll = queue.pollFirst();
                if (poll.x == x && poll.y == y)
                    return depth;
                
                for (int[] dir : dirs) {
                    Cell next = new Cell(poll.x + dir[0], poll.y + dir[1]);
                    
                    if (!visited.contains(next.hash()) && poll.x >= -1 && poll.y >= -1) {
                        visited.add(next.hash());
                        queue.offerLast(next);
                    }
                }
            }
        return -1;
    }
    class Cell {
        int x, y;
        Cell (int x, int y) {
            this.x = x;
            this.y = y;
        }
        public String hash() {
            return x + "|" + y;
        }
    }
```
