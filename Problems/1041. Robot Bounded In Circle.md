Link: [1041.Â Robot Bounded In Circle](https://leetcode.com/problems/robot-bounded-in-circle/) <br>
Tag : **Medium**<br>
Lock: **Normal**

On an infinite plane, a robot initially stands atÂ `(0, 0)`Â and faces north. Note that:

-   TheÂ **north direction**Â is the positive direction of the y-axis.
-   TheÂ **south direction**Â is the negative direction of the y-axis.
-   TheÂ **east direction**Â is the positive direction of the x-axis.
-   TheÂ **west direction**Â is the negative direction of the x-axis.

The robot can receive one of three instructions:

-   `"G"`: go straight 1 unit.
-   `"L"`: turn 90 degrees to the left (i.e., anti-clockwise direction).
-   `"R"`: turn 90 degrees to the right (i.e., clockwise direction).

The robot performs theÂ `instructions`Â given in order, and repeats them forever.

ReturnÂ `true`Â if and only if there exists a circle in the plane such that the robot never leaves the circle.

**Example 1:**
```
Input: instructions = "GGLLGG"
Output: true
Explanation: The robot is initially at (0, 0) facing the north direction.
"G": move one step. Position: (0, 1). Direction: North.
"G": move one step. Position: (0, 2). Direction: North.
"L": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: West.
"L": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: South.
"G": move one step. Position: (0, 1). Direction: South.
"G": move one step. Position: (0, 0). Direction: South.
Repeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) --> (0, 2) --> (0, 1) --> (0, 0).
Based on that, we return true.
```

**Example 2:**
```
Input: instructions = "GG"
Output: false
Explanation: The robot is initially at (0, 0) facing the north direction.
"G": move one step. Position: (0, 1). Direction: North.
"G": move one step. Position: (0, 2). Direction: North.
Repeating the instructions, keeps advancing in the north direction and does not go into cycles.
Based on that, we return false.
```

**Example 3:**
```
Input: instructions = "GL"
Output: true
Explanation: The robot moves from (0, 0) to (0, 1), then turns left and faces west. After repeating these instructions, it will be in a cycle.
```

**Constraints:**
- `1 <= instructions.length <= 100`
- `instructions[i]` is `'G'`, `'L'` or `'R'`

## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **State Machine Concept:**
   - Robot has position state (x, y)
   - Direction state (North, East, South, West)
   - Instructions modify both states
   - Need to detect cycles

2. **Key Insights:**
   - If robot returns to origin, it's in a cycle
   - If robot faces different direction after one sequence, it will form cycle
   - Only need to simulate one full sequence
   - Four possible final directions

### ðŸ” Edge Cases to Consider
- Single instruction
- Maximum length (100)
- All movement instructions
- All turn instructions
- Equal left and right turns
- Returns to origin
- Faces original direction
- Faces different direction
- Forms large cycle
- No movement

### ðŸŽ¯ Solution Approaches

1. **Direction State Machine**
   ```pseudo
   function isRobotBounded(instructions):
       # Directions: North=0, East=1, South=2, West=3
       dx = [0, 1, 0, -1]  # x-movement for each direction
       dy = [1, 0, -1, 0]  # y-movement for each direction
       
       x = y = 0  # starting position
       direction = 0  # facing north
       
       for instruction in instructions:
           if instruction == 'G':
               x += dx[direction]
               y += dy[direction]
           elif instruction == 'L':
               direction = (direction + 3) % 4
           else:  # 'R'
               direction = (direction + 1) % 4
       
       # Cycle exists if:
       # 1. Returns to origin, or
       # 2. Has different final direction
       return (x == 0 && y == 0) || direction != 0
   ```
   Time: O(n), Space: O(1)

### ðŸ“ˆ Visual Explanation
```
Example: "GGLLGG"

State progression:
Step  Instruction  Position  Direction
0     -           (0,0)     North
1     G           (0,1)     North
2     G           (0,2)     North
3     L           (0,2)     West
4     L           (0,2)     South
5     G           (0,1)     South
6     G           (0,0)     South

Final: Returns to origin â†’ Cycle exists!
```

### ðŸ› ï¸ Implementation Tips
1. Use arrays for direction vectors
2. Handle direction changes with modulo
3. Track position efficiently
4. Check both cycle conditions
5. Use constants for directions

### ðŸ“Š Complexity Analysis
- Time Complexity: O(n)
  - Single pass through instructions
  - Constant work per instruction
- Space Complexity: O(1)
  - Fixed space regardless of input
  - Only tracking position and direction

### ðŸ”— Related Patterns
- State Machines
- Simulation
- Cycle Detection
- Similar Problems:
  - Spiral Matrix
  - Walking Robot Simulation
  - Prison Cells After N Days

### ðŸ“ Example Processing Flow
```
Input: "GL"

1. Initial state:
   pos=(0,0), dir=North

2. Process 'G':
   pos=(0,1), dir=North

3. Process 'L':
   pos=(0,1), dir=West

4. Analysis:
   - Not at origin
   - Different final direction
   Will form cycle after 4 sequences

Result: true
```

### âš ï¸ Common Mistakes to Avoid
1. Wrong direction changes
2. Missing cycle conditions
3. Incorrect vector movements
4. Over-simulating sequences
5. Wrong modulo arithmetic

```java
class Solution {
    public boolean isRobotBounded(String instructions) {
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        int x = 0, y = 0;      // position
        int direction = 0;      // facing north
        
        for (char instruction : instructions.toCharArray()) {
            if (instruction == 'G') {
                x += directions[direction][0];
                y += directions[direction][1];
            } else if (instruction == 'L') {
                direction = (direction + 3) % 4;
            } else {  // 'R'
                direction = (direction + 1) % 4;
            }
        }
        
        // Cycle exists if returns to origin or faces different direction
        return (x == 0 && y == 0) || direction != 0;
    }
}
Explanation: The robot is initially at (0, 0) facing the north direction.
"G": move one step. Position: (0, 1). Direction: North.
"L": turn 90 degrees anti-clockwise. Position: (0, 1). Direction: West.
"G": move one step. Position: (-1, 1). Direction: West.
"L": turn 90 degrees anti-clockwise. Position: (-1, 1). Direction: South.
"G": move one step. Position: (-1, 0). Direction: South.
"L": turn 90 degrees anti-clockwise. Position: (-1, 0). Direction: East.
"G": move one step. Position: (0, 0). Direction: East.
"L": turn 90 degrees anti-clockwise. Position: (0, 0). Direction: North.
Repeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) --> (-1, 1) --> (-1, 0) --> (0, 0).
Based on that, we return true.
```

**Constraints:**
-   `1 <= instructions.length <= 100`
-   `instructions[i]`Â isÂ `'G'`,Â `'L'`Â or,Â `'R'`.

**Solution:**
- [x]  [[Hash Table]] 

**Intuition** :
The robot'sÂ [trajectory attractor](https://en.wikipedia.org/wiki/Attractor)Â is a set of trajectories toward which a system tends to evolve. The question may sound a bit theoretical - is this attractor is limited or not. In other words, if there exists a circle in the plane such that the robot never leaves the circle.

Diverging Trajectory
![bla](https://leetcode.com/problems/robot-bounded-in-circle/Figures/1041/pic1.png)

Limit Cycle Trajectory
![bla](https://leetcode.com/problems/robot-bounded-in-circle/Figures/1041/pic2.png)
_Figure 1. Diverging Trajectory vs Limit Cycle Trajectory._

Why is it interesting to know? There is a bunch of practical problems related to topology, networks planning, and password brute-forcing. For all these problems, the first thing to understand is do we work within a limited space or the behavior of our system could drastically diverge at some point?

Diverging Trajectory

![bla](https://leetcode.com/problems/robot-bounded-in-circle/Figures/1041/pic3.png)

Limit Cycle Trajectory
![bla](https://leetcode.com/problems/robot-bounded-in-circle/Figures/1041/pic4.png)

_Figure 2. Diverging Trajectory vs Limit Cycle Trajectory._

```
n = length of instructions

**Time Complexity** : O(n)<br>
**Space Complexity** : O(1)

```java
    char north = 'N', south = 'S', west = 'W', east = 'E';
    List<Character> order = new LinkedList<>(Arrays.asList(west, south, east, north));
    
    public boolean isRobotBounded(String instructions) {
        
        instructions = instructions + instructions + instructions + instructions;
        int index = 3;
        Map<Character, Integer> count = new HashMap<>();
        for (char instruction : instructions.toCharArray()) {
            if (instruction == 'L') index++;
            else if (instruction == 'R') index--;
            else {
                char dir = order.get(index);
                count.merge(dir, 1, Integer::sum);
            }
            index = (index + 4) % 4;
        }
        return count.getOrDefault(north, 0) == count.getOrDefault(south, 0) && 
                count.getOrDefault(east, 0) == count.getOrDefault(west, 0);
    }
```
