Link: [542. 01 Matrix](https://leetcode.com/problems/01-matrix/description/) <br>
Tag : **Medium**<br>
Lock: **Normal**

Given an `m x n` binary matrix `mat`, return _the distance of the nearest_ `0` _for each cell_.

The distance between two cells sharing a common edge is `1`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/04/24/01-1-grid.jpg)

```
Input: mat = [[0,0,0],[0,1,0],[0,0,0]]
Output: [[0,0,0],[0,1,0],[0,0,0]]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/04/24/01-2-grid.jpg)

```
Input: mat = [[0,0,0],[0,1,0],[1,1,1]]
Output: [[0,0,0],[0,1,0],[1,2,1]]
```

**Constraints:**

- `m == mat.length`
- `n == mat[i].length`
- `1 <= m, n <= 104`
- `1 <= m * n <= 104`
- `mat[i][j]` is either `0` or `1`.
- There is at least one `0` in `mat`.

**Note:** This question is the same as 1765: [https://leetcode.com/problems/map-of-highest-peak/](https://leetcode.com/problems/map-of-highest-peak/description/)

**Solution:**
- [x] [[Breath First Search]]

**Intuition** :

- For convinience, let's call the cell with value 0 as **zero-cell**, the cell has with value 1 as **one-cell**, the distance of the nearest 0 of a cell as **distance**.
- Firstly, we can see that the distance of all **zero-cells** are 0.
- Same idea with Topology Sort, we process **zero-cells** first, then we use `queue` data structure to keep the order of processing cells, so that cells which have the smaller distance will be processed first. Then we expand the unprocessed neighbors of the current processing cell and push into our queue.
- Afterall, we can achieve the minimum distance of all cells in our matrix.

![image](https://assets.leetcode.com/users/images/0de8711a-bdd9-4da3-a094-012abe995508_1627576450.2849615.png)

```
n = is the length of grid
m = is the breath of grid
```

**Time Complexity** : O(n*m)<br>
**Space Complexity** : O(n*m)

```java
    int[][] dirs = new int[][]{
        {-1, 0}, {0, -1}, {1, 0}, {0, 1}
    };
    public int[][] updateMatrix(int[][] mat) {
        
        int len = mat.length,
            bre = mat[0].length;
        boolean[][] visited = new boolean[len][bre];
        ArrayDeque<Point> queue = new ArrayDeque<>();

        for (int i = 0; i < len; i++)
            for (int j = 0; j < bre; j++)
                if (mat[i][j] == 0) {
                    visited[i][j] = true;
                    queue.offerLast(new Point(i, j));
                }
        
        int depth = 1;
        int size = queue.size();
        while (!queue.isEmpty()) {
            size--;

            Point remove = queue.pollFirst();

            for (int[] dir : dirs) {
                Point next = new Point(remove.x + dir[0], remove.y + dir[1]);
                
                if (next.x < 0 || 
                    next.y < 0 || 
                    next.x >= len || 
                    next.y >= bre || 
                    visited[next.x][next.y]) 
                        continue;
                visited[next.x][next.y] = true;
                mat[next.x][next.y] = depth;
                queue.offerLast(next);
            }

            if (size == 0) {
                size = queue.size();
                depth++;
            }
        }

        return mat;
    }
    class Point {
        int x, y;
        public Point (int x, int y) {
            this.x = x;
            this.y = y;
        }
        @Override
        public boolean equals(Object obj) {
            Point that = (Point) obj;
            return this.x == that.x && this.y == that.y;
        }
        @Override
        public int hashCode() {
            return Objects.hash(this.x, this.y);
        }
    }
```
