Link: [865. Smallest Subtree with all the Deepest Nodes](https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/description/?envType=daily-question&envId=2025-11-10) <br>
Tag : **Easy**<br>
Lock: **Normal**

Given an array of integers `arr`, a **lucky integer** is an integer that has a frequency in the array equal to its value.

Return _the largest **lucky integer** in the array_. If there is no **lucky integer** return `-1`.

**Example 1:**

```
Input: arr = [2,2,3,4]
Output: 2
Explanation: The only lucky number in the array is 2 because frequency[2] == 2.
```

**Example 2:**

```
Input: arr = [1,2,2,3,3,3]
Output: 3
Explanation: 1, 2 and 3 are all lucky numbers, return the largest of them.
```

**Example 3:**

```
Input: arr = [2,2,2,3,3]
Output: -1
Explanation: There are no lucky numbers in the array.
```

**Constraints:**

- `1 <= arr.length <= 500`
- `1 <= arr[i] <= 500`

**Solution:**

- [x] [[Hash Table]]

## Detailed Intuition

**Count Frequencies**: First, we need to count how many times each number appears in the array.

**Time Complexity** : O(n)<br>
**Space Complexity** : O(n)

```java
    public int findLucky(int[] arr) {
        
        Map<Integer, Integer> freq = new HashMap<>();
        for (int num : arr) freq.merge(num, 1, Integer::sum);

        int maxNum = -1;
        for (Map.Entry<Integer, Integer> entry : freq.entrySet())
            if (entry.getKey().equals(entry.getValue()))
                maxNum = Math.max(maxNum, entry.getKey());
        return maxNum;
    }
```

