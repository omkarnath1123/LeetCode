Link: [1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/) <br>
Tag : **Medium**<br>
Lock: **Normal**

An **ugly number** is a positive integer that is divisible by `a`, `b`, or `c`.

Given four integers `n`, `a`, `b`, and `c`, return the `nth` **ugly number**.

**Example 1:**
```
Input: n = 3, a = 2, b = 3, c = 5
Output: 4
Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.
```

**Example 2:**
```
Input: n = 4, a = 2, b = 3, c = 4
Output: 6
Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.
```

**Example 3:**
```
Input: n = 5, a = 2, b = 11, c = 13
Output: 10
Explanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5th is 10.
```

**Constraints:**
-   `1 <= n, a, b, c <= 109`
-   `1 <= a * b * c <= 1018`
-   It is guaranteed that the result will be in range `[1, 2 * 109]`.


## Detailed Intuition

### üí° How to Think About the Solution

1. **Ugly Numbers Concept:**
   - Numbers divisible by either a, b, or c
   - Forms overlapping sets (like Venn diagram)
   - Need to count efficiently without duplicates
   - Binary search makes sense due to monotonicity

2. **Key Insights:**
   - Use inclusion-exclusion principle
   - |A‚à™B‚à™C| = |A| + |B| + |C| - |A‚à©B| - |B‚à©C| - |A‚à©C| + |A‚à©B‚à©C|
   - LCM helps find overlapping counts
   - Binary search on result range

### üîç Edge Cases to Consider
- Minimum value (n=1)
- Maximum values (10^9)
- When a, b, c are coprime
- When some numbers share factors
- When two numbers are multiples
- Large product (a*b*c ‚â§ 10^18)
- Result near maximum (2*10^9)
- Equal values of a, b, or c

### üéØ Solution Approaches

1. **Binary Search with Inclusion-Exclusion**
   ```pseudo
   function nthUglyNumber(n, a, b, c):
       def lcm(x, y):
           return x * y // gcd(x, y)
       
       def countUgly(num):
           # Count numbers divisible by a, b, or c up to num
           return num//a + num//b + num//c 
                  - num//lcm(a,b) - num//lcm(b,c) - num//lcm(a,c)
                  + num//lcm(lcm(a,b), c)
       
       left, right = 1, 2*10^9
       while left < right:
           mid = left + (right - left) // 2
           if countUgly(mid) < n:
               left = mid + 1
           else:
               right = mid
       return left
   ```
   Time: O(log(2√ó10^9)), Space: O(1)

### üìà Visual Explanation
```
Example: n=3, a=2, b=3, c=5

Numbers divisible by:
2: [2,4,6,8,10,...]
3: [3,6,9,12,...]
5: [5,10,15,...]

Venn Diagram:
   2: [2,4,6,8,10]
   ‚à©
3: [3,6,9] ‚à© 5: [5,10]

Count at num=6:
|A‚à™B‚à™C| = |2,3,4,5,6| = 5 numbers
```

### üõ†Ô∏è Implementation Tips
1. Use long/long long for calculations
2. Implement GCD efficiently
3. Handle integer overflow in LCM
4. Binary search boundary conditions
5. Optimize count calculation

### üìä Complexity Analysis
- Time Complexity: O(log(2√ó10^9))
  - Binary search on range [1, 2√ó10^9]
  - Each count operation is O(1)
- Space Complexity: O(1)
  - Only constant extra space needed

### üîó Related Patterns
- Binary Search
- Math (GCD/LCM)
- Inclusion-Exclusion Principle
- Similar Problems:
  - Ugly Number
  - Ugly Number II
  - Super Ugly Number

### üìù Example Processing Flow
```
Example: n=3, a=2, b=3, c=5

Binary Search Steps:
1. mid = 10^9
   count = too many > 3
2. mid = 5√ó10^8
   count > 3
3. mid = 4
   count = 3 (2,3,4)
   Found answer!

Verification:
- 2 is ugly (√∑2)
- 3 is ugly (√∑3)
- 4 is ugly (√∑2)
Therefore, 4 is the 3rd ugly number
```

### ‚ö†Ô∏è Common Mistakes to Avoid
1. Integer overflow in LCM calculation
2. Incorrect inclusion-exclusion formula
3. Binary search boundary conditions
4. Missing GCD optimization
5. Not handling duplicate counts properly
   - Count numbers divisible by each factor
   - Subtract double-counted intersections
   - Add back triple-counted intersections
   - Use floor division for counts

2. **Binary Search Strategy**:
   - Define search range [1, 2√ó10^9]
   - For each mid point N:
     - Calculate count F(N)
     - Adjust range based on comparison with n

### Visual Guide:
```
Example: n=3, a=2, b=3, c=5

Numbers divisible by:
2: 2,4,6,8,10,...
3: 3,6,9,...
5: 5,10,...

Count up to 4:
By 2: ‚åä4/2‚åã = 2 numbers (2,4)
By 3: ‚åä4/3‚åã = 1 number (3)
By 5: ‚åä4/5‚åã = 0 numbers
- Subtract overlaps using LCM
Total = 3 numbers (2,3,4)

Therefore, 4 is the 3rd ugly number
```

### Edge Cases to Consider:
- When factors share common divisors
- Large n requiring many steps
- Factors with high LCM
- Numbers at binary search boundaries
- Minimum/maximum constraints

### Common Pitfalls:
1. Integer overflow in LCM calculation
2. Missing set intersections
3. Wrong binary search boundaries
4. Precision errors in division

### Optimization Techniques:
1. **LCM Calculation**:
   - Use GCD to compute LCM
   - Handle overflow carefully
   - Cache repeated calculations

2. **Binary Search**:
   - Tight initial bounds
   - Handle edge cases early
   - Early termination checks

### Time and Space Analysis:
- Time Complexity: O(log(2√ó10^9))
  - Binary search on answer range
  - Constant time count calculation
- Space Complexity: O(1)
  - Only variables needed

### Similar Problems:
- Nth Magical Number
- Count Integers with Even Digit Sum
- Super Ugly Number

### Mathematical Properties:
1. Inclusion-Exclusion Principle:
   |A ‚à™ B ‚à™ C| = |A| + |B| + |C| - |A‚à©B| - |B‚à©C| - |A‚à©C| + |A‚à©B‚à©C|

2. LCM Properties:
   - lcm(a,b) √ó gcd(a,b) = a √ó b
   - lcm(a,b,c) = lcm(lcm(a,b),c)

### Useful Resources:
- [Inclusion-Exclusion Principle](https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle)
- [Binary Search on Answer](https://leetcode.com/discuss/general-discussion/786126/python-powerful-ultimate-binary-search-template)

**Solution:**

- [x] [[Binary Search]] + [[Greedy]]

**Intuition** :
For every integer N, `F(N) = (total number of positive integers <= N which are divisible by a or b or c.).`  
![image](https://assets.leetcode.com/users/insomniacat/image_1569133734.png)

`The left-top circle stands for numbers <= N that are divisible by a`  
others the same idea, and the intersection of two/three circles is the total number of positive integers <= N which are divisible by the`least common multiple` of them.  
`F(N) = a + b + c - a ‚à© c - a ‚à© b - b ‚à© c + a ‚à© b ‚à© c`  
`F(N) = N/a + N/b + N/c - N/lcm(a, c) - N/lcm(a, b) - N/lcm(b, c) + N/lcm(a, b, c)`(lcm = least common multiple)  
Find the least integer `N` that satisfies the condition `F(N) >= K`

**Time Complexity** : O(log 2e9)<br>
**Space Complexity** : O(1)

```java
    int max = 2 * (int) Math.pow(10, 9);
    public int nthUglyNumber(int n, int one, int two, int three) {
        
        int left = 0,
            right = max,
            result = 0;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if ((int) count(mid, one, two, three) >= n) {
                result = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return result;
    }
    private long count(int num, int one, int two, int three) {
        return num / one + num / two + num / three
            - num / lcm(one, two) +
            - num / lcm(two, three) + 
            - num / lcm(three, one) + 
            + num / lcm(one, lcm(two, three));
    }
    private long gcd(long one, long two) {
        if (two == 0) return one;
        return gcd(two, one % two);
    }
    private long lcm(long one, long two) {
        return one * two / gcd(one, two);
    }
```
