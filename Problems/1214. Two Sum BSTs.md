Link: [1214. Two Sum BSTs](https://leetcode.com/problems/two-sum-bsts/) <br>
Tag : **Medium**<br>
Lock: **Premium**

Given the roots of two binary search trees, `root1` and `root2`, return `true` if and only if there is a node in the first tree and a node in the second tree whose values sum up to a given integer `target`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/10/ex1.png)
```
Input: root1 = [2,1,4], root2 = [1,0,3], target = 5
Output: true
Explanation: 2 and 3 sum up to 5.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/10/ex2.png)
```
Input: root1 = [0,-10,10], root2 = [5,1,7,0,2], target = 18
Output: false
```

**Constraints:**
-   The number of nodes in each tree is in the range `[1, 5000]`.
-   `-109 <= Node.val, target <= 109`

**Solution:**
- [x]  [[Ordered Set]] 

## Detailed Intuition

### How to Think About the Solution:
1. Think of this as a modified two-pointer approach across two BSTs
2. Use BST properties (left < root < right) to optimize search
3. We can eliminate subtrees based on sum comparison with target

### Key Insights:
1. If sum > target, we need smaller values
2. If sum < target, we need larger values
3. BST property lets us skip searching entire subtrees

### Step-by-Step Approach:
1. **Initial Setup**:
   - Start at roots of both trees
   - Compare root1.val + root2.val with target

2. **Search Strategy**:
   - If sum == target: Found solution
   - If sum > target: Need smaller values
     - Try root1.left with current root2
     - Try current root1 with root2.left
   - If sum < target: Need larger values
     - Try root1.right with current root2
     - Try current root1 with root2.right

### Visual Guide:
```
Example:
Tree1:      2        Tree2:      1
           / \              / \
          1   4           0   3
          
Target = 5

Search Process:
1. Start: 2 + 1 = 3 < 5
   Need larger values
2. Try: 2 + 3 = 5 ✓
   Found target!

Alternative paths:
- 4 + 1 = 5 ✓
- 2 + 3 = 5 ✓
Multiple valid solutions possible
```

### Edge Cases to Consider:
- Negative values in trees
- Duplicate values
- Single node trees
- Very unbalanced trees
- Target sum larger than any possible combination

### Common Pitfalls:
1. Not handling null nodes properly
2. Missing potential combinations
3. Not utilizing BST properties effectively
4. Unnecessary searching of subtrees

### Optimization Techniques:
1. **BST Property Usage**:
   - Skip left subtree if current sum < target
   - Skip right subtree if current sum > target

2. **Early Termination**:
   - Return true as soon as target is found
   - Skip subtrees that can't contain answer

### Time and Space Analysis:
- Time Complexity: O(n1 * log(n2)) where:
  - n1 = nodes in first tree
  - n2 = nodes in second tree
- Space Complexity: O(h1 + h2) for recursion stack
  where h1, h2 are heights of trees

### Alternative Approaches:
1. **HashSet Approach**:
   - Store all values from one tree
   - Search for complements in other tree
   - Time: O(n1 + n2), Space: O(n1)

2. **Inorder + Two Pointers**:
   - Get sorted arrays from both trees
   - Use two-pointer technique
   - Time: O(n1 + n2), Space: O(n1 + n2)

### Similar Problems:
- Two Sum IV - Input is a BST
- Two Sum
- Binary Tree Level Order Traversal

### Useful Resources:
- [BST Properties](https://www.geeksforgeeks.org/binary-search-tree-data-structure/)
- [Two Pointer Technique](https://leetcode.com/articles/two-pointer-technique/)

```
n = is the height of one
m = is the height of two
h = height of tree

**Time Complexity** : O(n log(m) + m log(n))<br>
**Space Complexity** : O(h)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean twoSumBSTs(TreeNode one, TreeNode two, int target) {
        return doesExist(one, two, target);
    }
    private boolean doesExist(TreeNode one, TreeNode two, int target) {
        if (one == null) return false;
        
        if (find(two, target - one.val)) return true;
        return doesExist(one.left, two, target) || doesExist(one.right, two, target);
    }
    private boolean find(TreeNode node, int target) {
        if (node == null) return false;
        if (node.val == target) return true;
        
        if (node.val > target)
            return find(node.left, target);
        else
            return find(node.right, target);
    }
}
```
