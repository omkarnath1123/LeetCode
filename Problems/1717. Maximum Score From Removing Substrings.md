Link: [1717. Maximum Score From Removing Substrings](https://leetcode.com/problems/maximum-score-from-removing-substrings/description/?envType=daily-question&envId=2025-11-10) <br>
Tag : **Medium**<br>
Lock: **Normal**

You are given a string `s` and two integers `x` and `y`. You can perform two types of operations any number of times.

- Remove substring `"ab"` and gain `x` points.
    - For example, when removing `"ab"` from `"cabxbae"` it becomes `"cxbae"`.
- Remove substring `"ba"` and gain `y` points.
    - For example, when removing `"ba"` from `"cabxbae"` it becomes `"cabxe"`.

Return _the maximum points you can gain after applying the above operations on_ `s`.

**Example 1:**

```
Input: s = "cdbcbbaaabab", x = 4, y = 5
Output: 19
Explanation:
- Remove the "ba" underlined in "cdbcbbaaabab". Now, s = "cdbcbbaaab" and 5 points are added to the score.
- Remove the "ab" underlined in "cdbcbbaaab". Now, s = "cdbcbbaa" and 4 points are added to the score.
- Remove the "ba" underlined in "cdbcbbaa". Now, s = "cdbcba" and 5 points are added to the score.
- Remove the "ba" underlined in "cdbcba". Now, s = "cdbc" and 5 points are added to the score.
Total score = 5 + 4 + 5 + 5 = 19.
```

**Example 2:**

```
Input: s = "aabbaaxybbaabb", x = 5, y = 4
Output: 20
```

**Constraints:**

- `1 <= s.length <= 105`
- `1 <= x, y <= 104`
- `s` consists of lowercase English letters.

**Solution:**

- [x] [[Greedy]]

## Detailed Intuition

- First of all, let's say we have string `aba`. What we want to remove here? Obviously we want to remove `ab` if `x > y` and `ba` in the other case. So this suggest that this problem is Greedy - we want to remove first all the substrings that will give us the most points.
- Now, you need only one pass to ensure that you removed all possible substrings `ab` or `ba`. Here's why, for example, if you removed all `ab` from initial `s` you will never get any `ab` while removing `ba` after that:
    - When you removed all `ab` you removed ALL `a` that have `b` on the right of it.
    - Let's say we removed `ba` now and get `ab` (character `a` from the left of the `b` and character `b` on the right of the `a`, so after deleting `ba` strings concatenate into `ab`).
    - But stop, **"character `b` on the fight of the `a`"**, but didn't I tell you one point back that we deleted ALL `a` that have `b` on right? This conclude my prove, you can prove so for `ba` as well, because situations are symmetrical.
- Now if you understand this points (and I strongly believe you do, if not - please be free to ask questions in comments), all that remains is the way we will remove this "ab" or "ba" which is technical problem. Let's look at the dry run for my explanations and then look at two ways to code this problem (second solution has the same logic)

**Time Complexity** : O(n)<br>
**Space Complexity** : O(n)

```java
    int totalGain;
    public int maximumGain(String s, int x, int y) {
        
        totalGain = 0;
        if (x > y) {
            s = getGain(s, x, 'a', 'b');
            getGain(s, y, 'b', 'a');
        } else {
            s = getGain(s, y, 'b', 'a');
            getGain(s, x, 'a', 'b');
        }
        return totalGain;
    }

    private String getGain(String s, int point, char first, char second) {
        ArrayDeque<Character> stack = new ArrayDeque<>();
        int gain = 0;

        for (char ch : s.toCharArray()) {
            if (!stack.isEmpty() && stack.peekLast() == first && ch == second) {
                gain = gain + point;
                stack.pollLast(); 
                continue;
            }
            stack.offerLast(ch);
        }
        
        totalGain = gain + totalGain;
        StringBuilder sb = new StringBuilder();
        while (!stack.isEmpty()) sb.append(stack.pollFirst());
        return sb.toString();
    }
```

