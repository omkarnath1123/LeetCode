Link: [1135. Connecting Cities With Minimum Cost](https://leetcode.com/problems/connecting-cities-with-minimum-cost/) <br>
Tag : **Medium**<br>
Lock: **Premium**

There are `n` cities labeled from `1` to `n`. You are given the integer `n` and an array `connections` where `connections[i] = [xi, yi, costi]` indicates that the cost of connecting city `xi` and city `yi` (bidirectional connection) is `costi`.

Return _the minimum **cost** to connect all the_ `n` _cities such that there is at least one path between each pair of cities_. If it is impossible to connect all the `n` cities, return `-1`,

The **cost** is the sum of the connections' costs used.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/04/20/1314_ex2.png)
```
Input: n = 3, connections = [[1,2,5],[1,3,6],[2,3,1]]
Output: 6
Explanation: Choosing any 2 edges will connect all cities so we choose the minimum 2.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2019/04/20/1314_ex1.png)
```
Input: n = 4, connections = [[1,2,3],[3,4,4]]
Output: -1
Explanation: There is no way to connect all cities even if all edges are used.
```

**Constraints:**
-   `1 <= n <= 104`
-   `1 <= connections.length <= 104`
-   `connections[i].length == 3`
-   `1 <= xi, yi <= n`
-   `xi != yi`
-   `0 <= costi <= 105`

## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **Minimum Spanning Tree Concept:**
   - Cities are nodes in a graph
   - Connections are weighted edges
   - Need minimum cost tree
   - All cities must be reachable

2. **Key Insights:**
   - Sort connections by cost
   - Use Union-Find for cycle detection
   - Need exactly n-1 edges for valid tree
   - Early termination possible

### ðŸ” Edge Cases to Consider
- Single city (n=1)
- Disconnected cities
- All same cost edges
- No valid solution exists
- Maximum cities (10^4)
- Parallel connections
- Maximum cost (10^5)
- Cycle in minimum edges
- All cities connected directly
- Sparse vs dense connections

### ðŸŽ¯ Solution Approaches

1. **Kruskal's Algorithm with Union-Find**
   ```pseudo
   function minimumCost(n, connections):
       if connections.length < n-1:
           return -1  # Can't connect all cities
       
       # Sort by cost
       sort connections by cost
       
       uf = UnionFind(n+1)  # 1-based cities
       totalCost = 0
       edgesUsed = 0
       
       for (city1, city2, cost) in connections:
           if uf.union(city1, city2):
               totalCost += cost
               edgesUsed++
               if edgesUsed == n-1:
                   return totalCost
       
       return -1  # Not all cities connected
   ```
   Time: O(E log E), Space: O(V)

### ðŸ“ˆ Visual Explanation
```
Example: n=3, connections=[[1,2,5],[1,3,6],[2,3,1]]

Graph:
1 ----5---- 2
 \         /
  6       1
   \     /
    \   /
      3

MST Construction:
1. Pick (2,3,1) lowest cost
2. Pick (1,2,5) connects remaining
3. Skip (1,3,6) creates cycle

Final MST cost = 1 + 5 = 6
```

### ðŸ› ï¸ Implementation Tips
1. Use efficient UnionFind
2. Sort connections first
3. Track edges used count
4. Check for impossible cases early
5. Handle 1-based indexing

### ðŸ“Š Complexity Analysis
- Time Complexity: O(E log E)
  - Sorting connections: O(E log E)
  - Union-Find operations: O(Eâ‹…Î±(V))
- Space Complexity: O(V)
  - UnionFind data structure
  - Sorting space

### ðŸ”— Related Patterns
- Minimum Spanning Tree
- Union Find
- Graph Algorithms
- Similar Problems:
  - Network Delay Time
  - Optimize Water Distribution
  - Min Cost to Connect All Points

### ðŸ“ Example Processing Flow
```
Input: n=3, connections=[[1,2,5],[1,3,6],[2,3,1]]

1. Sort by cost:
   [2,3,1]
   [1,2,5]
   [1,3,6]

2. Process edges:
   (2,3): Union sets â†’ cost=1
   (1,2): Union sets â†’ cost+=5
   (1,3): Skip (creates cycle)

Result: 6 (minimum cost tree)
```

### âš ï¸ Common Mistakes to Avoid
1. Not checking connectivity
2. Wrong edge count check
3. Missing impossible cases
4. Inefficient cycle detection
5. Not handling 1-based indexing

```java
class Solution {
    class UnionFind {
        int[] parent;
        int[] rank;
        
        UnionFind(int n) {
            parent = new int[n];
            rank = new int[n];
            for (int i = 0; i < n; i++)
                parent[i] = i;
        }
        
        int find(int x) {
            if (parent[x] != x)
                parent[x] = find(parent[x]);
            return parent[x];
        }
        
        boolean union(int x, int y) {
            int px = find(x), py = find(y);
            if (px == py) return false;
            
            if (rank[px] < rank[py])
                parent[px] = py;
            else if (rank[px] > rank[py])
                parent[py] = px;
            else {
                parent[py] = px;
                rank[px]++;
            }
            return true;
        }
    }
    
    public int minimumCost(int n, int[][] connections) {
        if (connections.length < n - 1) return -1;
        
        // Sort by cost
        Arrays.sort(connections, (a, b) -> a[2] - b[2]);
        
        UnionFind uf = new UnionFind(n + 1);
        int totalCost = 0;
        int edgesUsed = 0;
        
        for (int[] conn : connections) {
            if (uf.union(conn[0], conn[1])) {
                totalCost += conn[2];
                edgesUsed++;
                if (edgesUsed == n - 1)
                    return totalCost;
            }
        }
        
        return -1;  // Not all cities connected
    }
}
1. **Connection Processing**:
   - Sort all connections by cost
   - Process from cheapest to costliest
   - Use Union-Find for cycle detection
   - Track total cost and connections

2. **Network Building**:
   - Add connection if no cycle formed
   - Update connected components
   - Track running cost sum
   - Check final connectivity

### Visual Guide:
```
Example: n=3, connections=[[1,2,5],[1,3,6],[2,3,1]]

Sort by cost:
[2,3,1]  (cost 1)
[1,2,5]  (cost 5)
[1,3,6]  (cost 6)

Building MST:
1. Add [2,3] (cost=1)
   1   2--3

2. Add [1,2] (cost=5)
   1--2--3

Total cost = 6
All cities connected âœ“
```

### Edge Cases to Consider:
- Single city
- No possible connections
- Multiple possible MSTs
- Disconnected components
- All same cost connections

### Common Pitfalls:
1. Not checking final connectivity
2. Wrong cost calculation
3. Missing cheaper solutions
4. Inefficient cycle detection

### Optimization Techniques:
1. **Union-Find Operations**:
   - Path compression
   - Union by rank
   - Quick cycle detection

2. **Connection Processing**:
   - Efficient sorting
   - Early termination
   - Component tracking

### Time and Space Analysis:
- Time Complexity: O(E log E)
  - E = number of connections
  - Sorting dominates
- Space Complexity: O(N)
  - Union-Find storage
  - N = number of cities

### Similar Problems:
- Minimum Spanning Tree
- Network Delay Time
- Optimize Water Distribution

### Implementation Tips:
1. Use efficient Union-Find
2. Sort connections first
3. Track component count
4. Validate final state

### Useful Resources:
- [Kruskal's Algorithm](https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/)
- [Union-Find Applications](https://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf)

**Solution:**
```java
     public int minimumCost(int n, int[][] connections) {
        
        DisjointSet set = new DisjointSet(n);
        Arrays.sort(connections, (int[] one, int[] two) -> Integer.compare(one[2], two[2]));
        
        int cost = 0;
        for (int[] connection : connections)
            if (set.union(connection[0], connection[1]))
                cost = cost + connection[2];
        
        return set.sets == 1 ? cost : -1;
    }
    class DisjointSet {
        class Node {
            int val, rank = 1;
            Node parent;
            Node (int val) {
                this.val = val;
            }
        }
        int sets = 0;
        Map<Integer, Node> map = new HashMap<>();
        DisjointSet(int n) {
            for (int i = 1; i <= n; i++)
                makeSet(i);
        }
        private void makeSet(int val) {
            map.computeIfAbsent(val, item -> {
                Node node = new Node(val);
                node.parent = node;
                sets++;
                return node;
            });
        }
        public int find(int val) {
            return findSet(map.get(val)).val;
        }
        private Node findSet(Node node) {
            if (node.parent == node)
                return node;
            node.parent = findSet(node.parent);
            return node.parent;
        }
        private boolean union(int one, int two) {
            Node left = findSet(map.get(one)),
                 right = findSet(map.get(two));
            if (left == right) return false;
            
            sets--;
            if (left.rank < right.rank)
                left.parent = right;
            else if (right.rank < left.rank)
                right.parent = left;
            else {
                left.parent = right;
                right.rank++;
            }
            return true;
        }
    }
```
