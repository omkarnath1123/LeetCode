Link: [1102. Path With Maximum Minimum Value](https://leetcode.com/problems/path-with-maximum-minimum-value/) <br>
Tag : **Medium**<br>
Lock: **Premium**

Given an `m x n` integer matrix `grid`, return _the maximum **score** of a path starting at_ `(0, 0)` _and ending at_ `(m - 1, n - 1)` moving in the 4 cardinal directions.

The **score** of a path is the minimum value in that path.

-   For example, the score of the path `8 â†’ 4 â†’ 5 â†’ 9` is `4`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/08/05/maxgrid1.jpg)
```
Input: grid = [[5,4,5],[1,2,6],[7,4,6]]
Output: 4
Explanation: The path with the maximum score is highlighted in yellow. 
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/08/05/maxgrid2.jpg)
```
Input: grid = [[2,2,1,2,2,2],[1,2,2,2,1,2]]
Output: 2
```

**Example 3:**

![](https://assets.leetcode.com/uploads/2021/08/05/maxgrid3.jpg)
```
Input: grid = [[3,4,6,3,4],[0,2,1,1,7],[8,8,3,2,7],[3,2,4,9,8],[4,1,2,0,0],[4,6,5,4,3]]
Output: 3
```

**Constraints:**
-   `m == grid.length`
-   `n == grid[i].length`
-   `1 <= m, n <= 100`
-   `0 <= grid[i][j] <= 109`

## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **Binary Search with Graph Concept:**
   - Path score is its minimum value
   - Binary search on possible scores
   - For each score, check if path exists
   - Use Union-Find for path existence

2. **Key Insights:**
   - Binary search range: [min, max] in grid
   - Connect cells â‰¥ mid in binary search
   - Path exists if start and end connected
   - Optimize connection checking

### ðŸ” Edge Cases to Consider
- Single cell grid
- All same values
- Long narrow grid
- Square grid
- Maximum grid size (100Ã—100)
- Maximum value (10^9)
- No valid path
- Multiple valid paths
- Path along border
- Diagonal-only connection possible

### ðŸŽ¯ Solution Approaches

1. **Binary Search with Union-Find**
   ```pseudo
   function maximumMinimumPath(grid):
       m = grid.length, n = grid[0].length
       left = min(grid[0][0], grid[m-1][n-1])
       right = 10^9
       
       function canReachEnd(threshold):
           uf = UnionFind(m * n)
           for i in 0..m-1:
               for j in 0..n-1:
                   if grid[i][j] >= threshold:
                       for next in getNeighbors(i, j):
                           if grid[next.x][next.y] >= threshold:
                               uf.union(i*n+j, next.x*n+next.y)
           
           return uf.connected(0, m*n-1)
       
       while left < right:
           mid = (left + right + 1) / 2
           if canReachEnd(mid):
               left = mid
           else:
               right = mid - 1
       
       return left
   ```
   Time: O(mn log V) where V is value range
   Space: O(mn)

### ðŸ“ˆ Visual Explanation
```
Example Grid:
5 4 5
1 2 6
7 4 6

Binary Search Process:
Try mid = 4:
[5][4][5]
[ ][2][6]
[7][4][6]
Connected! Try higher.

Try mid = 5:
[5][ ][5]
[ ][2][6]
[7][ ][6]
Not connected. Try lower.

Result: 4
```

### ðŸ› ï¸ Implementation Tips
1. Use efficient UnionFind implementation
2. Handle grid boundaries carefully
3. Optimize binary search range
4. Cache visited cells
5. Check path existence efficiently

### ðŸ“Š Complexity Analysis
- Time Complexity: O(mn log V)
  - Binary search on values: O(log V)
  - Each check: O(mn)
  - V = value range (10^9)
- Space Complexity: O(mn)
  - UnionFind data structure
  - Visited array

### ðŸ”— Related Patterns
- Binary Search
- Union Find
- Graph Traversal
- Similar Problems:
  - Swim in Rising Water
  - Making A Large Island
  - Number of Islands II

### ðŸ“ Example Processing Flow
```
Input: grid = [[5,4,5],
               [1,2,6],
               [7,4,6]]

Binary Search steps:
1. Try mid = 4:
   Can connect through:
   (0,0)-(0,1)-(0,2)-(1,2)-(2,2)
   Valid path exists!

2. Try mid = 5:
   Cannot connect start to end
   Lower threshold

3. Finalize at 4
   This is maximum possible score
```

### âš ï¸ Common Mistakes to Avoid
1. Wrong binary search boundaries
2. Missing grid edge checks
3. Inefficient path checking
4. Not handling disconnected cases
5. Wrong direction vectors

```java
class Solution {
    private int[] dx = {0, 1, 0, -1};
    private int[] dy = {1, 0, -1, 0};
    
    public int maximumMinimumPath(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int left = Math.min(grid[0][0], grid[m-1][n-1]);
        int right = 1_000_000_000;
        
        while (left < right) {
            int mid = left + (right - left + 1) / 2;
            if (canReachEnd(grid, mid)) {
                left = mid;
            } else {
                right = mid - 1;
            }
        }
        
        return left;
    }
    
    private boolean canReachEnd(int[][] grid, int threshold) {
        int m = grid.length, n = grid[0].length;
        UnionFind uf = new UnionFind(m * n);
        boolean[][] visited = new boolean[m][n];
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] >= threshold) {
                    visited[i][j] = true;
                    for (int k = 0; k < 4; k++) {
                        int ni = i + dx[k];
                        int nj = j + dy[k];
                        if (ni >= 0 && ni < m && nj >= 0 && nj < n &&
                            visited[ni][nj] && grid[ni][nj] >= threshold) {
                            uf.union(i*n + j, ni*n + nj);
                        }
                    }
                }
            }
        }
        
        return visited[0][0] && visited[m-1][n-1] && 
               uf.connected(0, m*n - 1);
    }
    
    class UnionFind {
        private int[] parent;
        private int[] rank;
        
        UnionFind(int n) {
            parent = new int[n];
            rank = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
            }
        }
        
        int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }
        
        void union(int x, int y) {
            int px = find(x), py = find(y);
            if (px == py) return;
            
            if (rank[px] < rank[py]) {
                parent[px] = py;
            } else if (rank[px] > rank[py]) {
                parent[py] = px;
            } else {
                parent[py] = px;
                rank[px]++;
            }
        }
        
        boolean connected(int x, int y) {
            return find(x) == find(y);
        }
    }
}
4. Consider it similar to finding the widest path in a graph

### Key Insights:
1. The path's score is its minimum value
2. Higher values provide more flexibility in path choices
3. We can use a modified Dijkstra's/Union-Find approach
4. Think of it as finding connected components with threshold

### Step-by-Step Approach:
1. **Binary Search on Answer**:
   - Use binary search to guess minimum path value
   - For each guess, check if path exists with values â‰¥ guess

2. **Path Validation**:
   - Use Union-Find or BFS to check connectivity
   - Consider only cells with values â‰¥ current threshold
   - Check if start and end are connected

### Visual Guide:
```
Example grid:
5 4 5     Path finding with threshold = 4:
1 2 6     5-4-5
7 4 6     â€¢ â€¢ 6
          7-4-6

Connected Components Analysis:
1. Start with highest values
2. Join adjacent cells â‰¥ threshold
3. Check if (0,0) connects to (m-1,n-1)
```

### Edge Cases to Consider:
- 1x1 grid
- Long narrow grids
- All same values
- No valid path exists
- Single possible path
- Multiple valid paths

### Common Pitfalls:
1. Using regular path-finding DFS/BFS
2. Not considering all possible paths
3. Greedy local choices
4. Incorrect binary search boundaries

### Optimization Techniques:
1. **Union-Find with Path Compression**:
   - Efficient component tracking
   - Quick connectivity checks

2. **Priority Queue Approach**:
   - Process cells in value order
   - Early termination when path found

### Time and Space Analysis:
- Time Complexity: O(mn * log(MAX)) where:
  - m, n are grid dimensions
  - MAX is maximum value in grid
  - Each check is O(mn)
- Space Complexity: O(mn)

### Similar Problems:
- Number of Islands
- Swim in Rising Water
- Making A Large Island

### Implementation Approaches:
1. **Binary Search + Union Find**:
   ```
   For each threshold T:
   1. Create components of cells â‰¥ T
   2. Check if start connects to end
   ```

2. **Modified Dijkstra's**:
   ```
   Use PQ to process cells by value
   Track maximum minimal path value
   ```

### Useful Resources:
- [Union-Find Data Structure](https://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf)
- [Binary Search on Answer](https://leetcode.com/discuss/general-discussion/786126/python-powerful-ultimate-binary-search-template)

We can maximize the score of a path by always picking the unvisited cell with the largest value. To determine what order we should visit the cells, we can sort them by their values. Then we traverse these cells in order from the largest value to the smallest value. Each time we visit a cell, we mark it as **visited** and use the union-find data structure to connect this cell with its **visited** neighbors.

After visiting each cell, we check if the top-left cell and the bottom-right cell have been connected, if so, it means that there is at least one 4 directionally connected path between them, and the last cell we visit is the 'last piece of the puzzle' in this path. Since we are traversing the cells by their decreasing values, the value of the last visited cell is the minimum value in this path and, therefore, the maximum minimum score for all valid paths.

**Algorithm**
1.  Sort all the cells decreasingly by their values.
2.  Iterate over the sorted cells from the largest value, for each visited cell, check if it has any 4-directionally connected visited neighbor cells, if so, we use the union-find data structure to connect it with its visited neighbors.
3.  Check if the top-left cell is connected with the bottom-right cell.
    -   If so, return the value of the last visited cell.
    -   Otherwise, repeat from the step 2.

```
n = the length of the grid
m = the breath of the grid

**Time Complexity** : O(n*m log(n*m))<br>
**Space Complexity** : O(n*m)

```java
    public int maximumMinimumPath(int[][] grid) {
        
        int len = grid.length,
            bre = grid[0].length,
            minValue;
        
        PriorityQueue<Cell> maxHeap = new PriorityQueue<>();
        for (int i = 0; i < len; i++)
            for (int j = 0; j < bre; j++)
                maxHeap.add(new Cell(i, j, grid[i][j]));
        
        int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};
        DisjointSet set = new DisjointSet();
        Cell source = new Cell(0, 0, grid[0][0]),
             dest = new Cell(len - 1, bre - 1, grid[len - 1][bre - 1]);
        
        set.find(source);
        set.find(dest);
        minValue = Math.min(source.val, dest.val);
        
        while (!set.find(source).equals(set.find(dest))) {
            Cell poll = maxHeap.poll();
            minValue = Math.min(minValue, poll.val);
            set.find(poll);
            
            for (int[] dir : dirs) {
                Cell next = new Cell(poll.x + dir[0], poll.y + dir[1]);
                
                if (next.x < 0 || next.y < 0 ||
                    next.x >= len || next.y >= bre || 
                    !set.exist(next)) continue;
                
                set.union(poll, next);
            }
        }
        return minValue;
    }
    class Cell implements Comparable<Cell> {
        int x, y, val = 0;
        Cell (int x, int y, int val) {
            this.x = x;
            this.y = y;
            this.val = val;
        }
        Cell (int x, int y) {
            this.x = x;
            this.y = y;
        }
        @Override
        public int compareTo(Cell that) {
            return -1 * Integer.compare(this.val, that.val);
        }
        @Override
        public int hashCode () {
            return Objects.hash(x, y);
        }
        @Override
        public boolean equals(Object obj) {
            Cell that = (Cell) obj;
            return this.x == that.x && this.y == that.y;
        }
    }
    class Node {
        Cell val;
        int rank = 1;
        Node parent;
        Node (Cell val) {
            this.val = val;
        }
    }
    class DisjointSet {
        Map<Cell, Node> store = new HashMap<>();
        private void makeSet(Cell val) {
            store.computeIfAbsent(val, item -> {
                Node node = new Node(val);
                node.parent = node;
                return node;
            });
        }
        public Cell find(Cell val) {
            makeSet(val);
            return findSet(store.get(val)).val;
        }
        private Node findSet(Node node) {
            if (node.parent == node)
                return node;
            node.parent = findSet(node.parent);
            return node.parent;
        }
        public void union(Cell one, Cell two) {
            makeSet(one);
            makeSet(two);
            Node left = findSet(store.get(one)),
                 right = findSet(store.get(two));
            if (left == right) return;
            
            if (left.rank < right.rank)
                left.parent = right;
            else if (right.rank < left.rank)
                right.parent = left;
            else {
                left.parent = right;
                right.rank++;
            }
        }
        public boolean exist(Cell cell) {
            return store.containsKey(cell);
        }
    }
```


