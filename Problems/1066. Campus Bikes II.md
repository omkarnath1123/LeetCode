Link: [1066.Â Campus Bikes II](https://leetcode.com/problems/campus-bikes-ii/) <br>
Tag : **Medium**<br>
Lock: **Premium**

On a campus represented as a 2D grid, there areÂ `n`Â workers andÂ `m`Â bikes, withÂ `n <= m`. Each worker and bike is a 2D coordinate on this grid.

We assign one unique bike to each worker so that the sum of theÂ **Manhattan distances**Â between each worker and their assigned bike is minimized.

ReturnÂ `the minimum possible sum of Manhattan distances between each worker and their assigned bike`.

TheÂ **Manhattan distance**Â between two pointsÂ `p1`Â andÂ `p2`Â isÂ `Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/03/06/1261_example_1_v2.png)
```
Input: workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]]
Output: 6
Explanation: 
We assign bike 0 to worker 0, bike 1 to worker 1. The Manhattan distance of both assignments is 3, so the output is 6.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2019/03/06/1261_example_2_v2.png)
```
Input: workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]]
Output: 4
Explanation: 
We first assign bike 0 to worker 0, then assign bike 1 to worker 1 or worker 2, bike 2 to worker 2 or worker 1. Both assignments lead to sum of the Manhattan distances as 4.
```

**Example 3:**
```
Input: workers = [[0,0],[1,0],[2,0],[3,0],[4,0]], bikes = [[0,999],[1,999],[2,999],[3,999],[4,999]]
Output: 4995
```

**Constraints:**
-   `n == workers.length`
-   `m == bikes.length`
-   `1 <= n <= m <= 10`
-   `workers[i].length == 2`
-   `bikes[i].length == 2`
-   `0 <= workers[i][0], workers[i][1], bikes[i][0], bikes[i][1] < 1000`
-   All the workers and the bikes locations areÂ **unique**.

## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **Assignment Problem Concept:**
   - Need to assign bikes to workers
   - Each worker gets exactly one bike
   - Minimize total Manhattan distance
   - State can be represented with bitmask

2. **Key Insights:**
   - Use bits to track bike assignments
   - Calculate distances upfront
   - Use DP to avoid recalculations
   - State includes worker and available bikes

### ðŸ” Edge Cases to Consider
- Single worker and bike
- Equal number of workers and bikes
- More bikes than workers
- Maximum grid size (1000Ã—1000)
- Workers/bikes at same points
- Maximum coordinate difference
- Manhattan distance overflow
- All points on same line
- Diagonal arrangements
- Maximum workers/bikes (10)

### ðŸŽ¯ Solution Approaches

1. **Bitmask Dynamic Programming**
   ```pseudo
   function assignBikes(workers, bikes):
       n = workers.length
       m = bikes.length
       
       # Precompute distances
       dist = [][]
       for i in 0..n-1:
           for j in 0..m-1:
               dist[i][j] = manhattan(workers[i], bikes[j])
       
       # dp(i, mask) = min cost to assign bikes to workers[i:]
       # with bikes represented by mask
       function dp(worker, mask):
           if worker == n:
               return 0
           
           if memo[worker][mask] exists:
               return memo[worker][mask]
           
           result = infinity
           for bike in 0..m-1:
               if mask & (1 << bike) == 0:
                   cost = dist[worker][bike] + 
                         dp(worker + 1, mask | (1 << bike))
                   result = min(result, cost)
           
           memo[worker][mask] = result
           return result
       
       return dp(0, 0)
   ```
   Time: O(n Ã— 2^m), Space: O(n Ã— 2^m)

### ðŸ“ˆ Visual Explanation
```
Example: workers=[[0,0],[2,1]], bikes=[[1,2],[3,3]]

State representation:
00 - No bikes assigned
01 - Bike 0 assigned
10 - Bike 1 assigned
11 - Both bikes assigned

Distance matrix:
     B0  B1
W0   3   6
W1   4   3

DP states tree:
         (W0,00)
        /        \
  (W1,01)        (W1,10)
     |              |
   (END,11)      (END,11)
```

### ðŸ› ï¸ Implementation Tips
1. Precompute Manhattan distances
2. Use memoization array
3. Track bike availability with bits
4. Handle integer overflow
5. Optimize state representation

### ðŸ“Š Complexity Analysis
- Time Complexity: O(n Ã— 2^m)
  - States: n workers Ã— 2^m bike combinations
  - Each state tries m bikes
- Space Complexity: O(n Ã— 2^m)
  - Memoization table size
  - Call stack depth O(n)

### ðŸ”— Related Patterns
- Bitmask DP
- Assignment Problems
- Distance Calculations
- Similar Problems:
  - Campus Bikes I
  - Minimum Cost to Hire K Workers
  - Fair Distribution of Cookies

### ðŸ“ Example Processing Flow
```
Input: workers=[[0,0],[2,1]], bikes=[[1,2],[3,3]]

1. Calculate distances:
   W0 to B0: |0-1| + |0-2| = 3
   W0 to B1: |0-3| + |0-3| = 6
   W1 to B0: |2-1| + |1-2| = 4
   W1 to B1: |2-3| + |1-3| = 3

2. DP states:
   dp(0,0) = min(
     3 + dp(1,1),  // Use bike 0 for worker 0
     6 + dp(1,2)   // Use bike 1 for worker 0
   )

Result: 6 (Optimal assignments: W0â†’B0, W1â†’B1)
```

### âš ï¸ Common Mistakes to Avoid
1. Wrong distance calculation
2. Incorrect bit manipulation
3. Missing memoization
4. Integer overflow
5. Inefficient state transitions

```java
class Solution {
    private int[][] workers;
    private int[][] bikes;
    private Integer[][] memo;
    private int n, m;
    
    public int assignBikes(int[][] workers, int[][] bikes) {
        this.workers = workers;
        this.bikes = bikes;
        this.n = workers.length;
        this.m = bikes.length;
        this.memo = new Integer[n][1 << m];
        
        return dp(0, 0);
    }
    
    private int dp(int worker, int mask) {
        if (worker == n) return 0;
        if (memo[worker][mask] != null) 
            return memo[worker][mask];
        
        int min = Integer.MAX_VALUE;
        for (int bike = 0; bike < m; bike++) {
            if ((mask & (1 << bike)) == 0) {
                int cost = distance(worker, bike) + 
                          dp(worker + 1, mask | (1 << bike));
                min = Math.min(min, cost);
            }
        }
        
        return memo[worker][mask] = min;
    }
    
    private int distance(int w, int b) {
        return Math.abs(workers[w][0] - bikes[b][0]) + 
               Math.abs(workers[w][1] - bikes[b][1]);
    }
}
```

![Campus Bikes](https://assets.leetcode.com/uploads/2019/03/06/1261_example_1_v2.png)
**Intuition** :

**Algorithm**

1.  For every worker starting from the worker at indexÂ `0`, traverse over the bits ofÂ `mask`Â and assign it to the worker if it is available (bit atÂ `bikeIndex`Â inÂ `mask`Â isÂ `0`Â ). After assigning the bike mark it is unavailable (change the bit atÂ `bikeIndex`Â inÂ `mask`Â toÂ `1`).
2.  Add the Manhattan distance of the above assignment and add it to the distance that will be returned by the recursive functionÂ `minimumDistanceSum`Â for the next workerÂ `workerIndex`.
3.  If we have assigned bikes to all the workers (`workerIndex >= workers.size()`) then we can return the distance asÂ `0`.
4.  Use memoization to store the result corresponding toÂ `mask`, because there will be repeated subproblems as shown below. This will help us to avoid recalculating subproblems.

```
n = is the length of workers

**Time Complexity** : O(n*2<sup>n</sup>)<br>
**Space Complexity** : O(2<sup>n</sup>)

```java
    Map<String, Integer> cache;
    int workerLen, bikeLen;
    public int assignBikes(int[][] workers, int[][] bikes) {
        
        workerLen = workers.length;
        bikeLen = bikes.length;
        int bikeMask = (1 << bikeLen) - 1,
            workerMask = (1 << workerLen) - 1;
        
        cache = new HashMap<>();
        return backTrack(workers, bikes, bikeMask, workerMask);
    }
    private int backTrack(int[][] workers, int[][] bikes, int bikeMask, int workerMask) {
        if (workerMask == 0) 
            return 0;
        
        String key = bikeMask + "|" + workerMask;
        if (cache.containsKey(key)) return cache.get(key);
        int minCost = Integer.MAX_VALUE;
        
        for (int i = 0; i < workerLen; i++) {
            boolean worker = ((workerMask >> i) & 1) == 1;

            if (worker)
                for (int j = 0; j < bikeLen; j++) {
                    boolean bike = ((bikeMask >> j) & 1) == 1;

                    if (bike) 
                        minCost = Math.min(minCost, backTrack(workers, bikes, 
                                bikeMask ^ (1 << j), 
                                workerMask ^ (1 << i)) + dist(workers[i], bikes[j]));
                }
        }
        cache.put(key, minCost);
        return minCost;
    }
    private int dist(int[] one, int[] two) {
        return Math.abs(one[0] - two[0]) + Math.abs(one[1] - two[1]);
    }
```
