Link: [1216. Valid Palindrome III](https://leetcode.com/problems/valid-palindrome-iii/) <br>
Tag : **Hard**<br>
Lock: **Premium**

Given a string `s` and an integer `k`, return `true` if `s` is a `k`**-palindrome**.

A string is `k`**-palindrome** if it can be transformed into a palindrome by removing at most `k` characters from it.

**Example 1:**
```
Input: s = "abcdeca", k = 2
Output: true
Explanation: Remove 'b' and 'e' characters.
```

**Example 2:**
```
Input: s = "abbababa", k = 1
Output: true
```

**Constraints:**
-   `1 <= s.length <= 1000`
-   `s` consists of only lowercase English letters.
-   `1 <= k <= s.length`


## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **K-Palindrome Concept:**
   - Regular palindrome: reads same forward and backward
   - K-palindrome: can become palindrome by removing â‰¤ k chars
   - Need to find minimum deletions needed
   - If minimum deletions â‰¤ k, it's a valid k-palindrome

2. **Key Insights:**
   - Each character mismatch gives us two choices:
     a) Delete character from left side
     b) Delete character from right side
   - Problem exhibits optimal substructure
   - Overlapping subproblems make it perfect for DP
   - Can solve smaller palindromes first

### ðŸ” Edge Cases to Consider
- String is already a palindrome (k=0)
- k equals string length
- String with all same characters
- String with alternating characters
- Maximum string length (1000)
- k equals 1 (minimum value)
- k equals string length (maximum value)

### ðŸŽ¯ Solution Approaches

1. **Dynamic Programming (Bottom-Up)**
   ```pseudo
   function isKPalindrome(s, k):
       n = length(s)
       dp = array[n][n]  // dp[i][j] = min deletions needed
       
       for len from 1 to n:
           for i from 0 to n-len:
               j = i + len - 1
               if i == j:
                   dp[i][j] = 0
               else if s[i] == s[j]:
                   dp[i][j] = dp[i+1][j-1]
               else:
                   dp[i][j] = 1 + min(dp[i+1][j], dp[i][j-1])
       
       return dp[0][n-1] <= k
   ```
   Time: O(nÂ²), Space: O(nÂ²)

2. **Recursive with Memoization**
   ```pseudo
   function minDeletions(s, i, j, memo):
       if i >= j: return 0
       if memo[i][j] != -1: return memo[i][j]
       
       if s[i] == s[j]:
           result = minDeletions(s, i+1, j-1, memo)
       else:
           result = 1 + min(
               minDeletions(s, i+1, j, memo),
               minDeletions(s, i, j-1, memo)
           )
       memo[i][j] = result
       return result
   ```

### ðŸ“ˆ Visual Explanation
```
Example: s = "abcdeca", k = 2

Analyzing "abcdeca":
     a b c d e c a
   a 0 1 2 3 4 3 2 â† Final answer: 2 deletions needed
   b   0 1 2 3 2 3   (remove 'b' and 'e')
   c     0 1 2 1 2
   d       0 1 2 3
   e         0 1 2
   c           0 1
   a             0

Each cell shows minimum deletions needed
for substring from row to column
```

### ðŸ› ï¸ Implementation Tips
1. Initialize DP table with appropriate size
2. Handle base cases first (i >= j)
3. Fill table diagonally or by length
4. Use memoization for recursive approach
5. Track actual characters to delete if needed

### ðŸ“Š Complexity Analysis
- Time Complexity: O(nÂ²)
  - Need to fill nÃ—n DP table
  - Each cell requires O(1) computation
- Space Complexity: O(nÂ²)
  - DP table stores results for all substrings

### ðŸ”— Related Patterns
- Palindrome Problems
- String Dynamic Programming
- Two Pointers Technique
- Similar Problems:
  - Valid Palindrome
  - Valid Palindrome II
  - Longest Palindromic Substring

### ðŸ“ Example Processing Flow
```
Input: "abcdeca", k = 2

Step-by-step for substring "abc":
1. Compare 'a' and 'c':
   - Mismatch â†’ try removing either
   - Remove 'a': check "bc" (1 deletion)
   - Remove 'c': check "ab" (1 deletion)
   - Choose minimum = 1 deletion

Continue this process for all substrings
Final result: 2 deletions ('b' and 'e')
```

### âš ï¸ Common Mistakes to Avoid
1. Not handling base cases properly
2. Forgetting to memoize recursive calls
3. Incorrect DP state transition
4. Not considering both deletion choices
5. Inefficient string operations in recursion

### Visual Guide:
```
Example: s = "abcdeca", k = 2

Two-pointer process:
a b c d e c a
â†‘           â†‘
match: move both

a b c d e c a
  â†‘       â†‘
mismatch: try both:
1. Skip b: [acdeca]
2. Skip c: [abdeca]

Continue with better choice...
Final: Remove 'b' and 'e'
Result: "acdca" (palindrome)
```

### Edge Cases to Consider:
- Single character string
- Already palindrome
- k = string length
- No solution possible
- Repeated characters

### Common Pitfalls:
1. Not trying both deletion options
2. Wrong base cases
3. Incorrect state tracking
4. Missing better solutions

### Optimization Techniques:
1. **DP Memoization**:
   - Cache subproblem results
   - Avoid redundant calculations
   - Track minimum deletions

2. **Early Termination**:
   - If deletions > k
   - If remaining length < k
   - If already palindrome

### Time and Space Analysis:
- Time Complexity: O(nÂ²)
  - Fill DP table
  - Each cell computed once
- Space Complexity: O(nÂ²)
  - DP table storage
  - Can optimize to O(n)

### Similar Problems:
- Valid Palindrome II
- Longest Palindromic Subsequence
- Minimum Insertion Steps to Make String Palindrome

### Implementation Tips:
1. Initialize DP table properly
2. Handle base cases first
3. Consider both deletion choices
4. Compare against k at end

### Useful Resources:
- [Dynamic Programming Patterns](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns)
- [String Manipulation Techniques](https://www.geeksforgeeks.org/string-data-structure/)

**Solution:**

- [x] [[Utils/Dynamic Programming]] + [[Bottom-Up Solution]]

**Intuition** :

How do we find the minimum characters to be removed to make it a palindrome? Let's imagine matching the characters of the string like a palindrome, from the beginning and the end with 2 pointers `i` and `j`. We may encounter the following two scenarios:

1.  The character at `i` matches character at `j`.
2.  The characters don't match each other.

For case 1 we just increase the pointer `i` and decrease the pointer `j`, `i++` and `j--` respectively.
In the second case we have 2 options:

-   Remove character at `j` and see if the previous character matches character at `i`.
Or
-   Remove character at `i` and see if the next character matches character at `j`.

Since we are not actually removing the characters from the string but just calculating the number of characters to be removed, in case 1 we decrement the pointer `j` by 1 and `i` stays as it is, as we still need a character to match character at `i` and in case 2 we increment the pointer `i` by 1 and `j` stays as it is, as we still need a character to match character at `j`. In both the cases we remove 1 character and thus it adds 1 to the cost.

We can then use these two different pairs of new `i` and `j` values (`i+1, j` and `i, j-1`) to again repeat the process and get the minimum result of them as our result for current pair `i, j`.


```
n = is the length of string

**Time Complexity** : O(n<sup>2</sup>)<br>
**Space Complexity** : O(n<sup>2</sup>)

```java
    public boolean isValidPalindrome(String source, int deletions) {
        
        int len = source.length();
        char[] order = source.toCharArray(),
               reverseOrder = new StringBuilder(source).reverse().toString().toCharArray();
        
        int[][] store = new int[len + 1][len + 1];
        
        for (int i = 1; i <= len; i++)
            for (int j = 1; j <= len; j++)
                if (order[i - 1] == reverseOrder[j - 1])
                    store[i][j] = store[i - 1][j - 1] + 1;
                else
                    store[i][j] = Math.max(store[i - 1][j], store[i][j - 1]);
        
        int reqDeletions = len - store[len][len];
        return reqDeletions <= deletions;
    }
```
