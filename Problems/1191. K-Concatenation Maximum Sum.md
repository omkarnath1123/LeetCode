Link: [1191. K-Concatenation Maximum Sum](https://leetcode.com/problems/k-concatenation-maximum-sum/) <br>
Tag : **Medium**<br>
Lock: **Normal**

Given an integer array `arr` and an integer `k`, modify the array by repeating it `k` times.

For example, if `arr = [1, 2]` and `k = 3` then the modified array will be `[1, 2, 1, 2, 1, 2]`.

Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be `0` and its sum in that case is `0`.

As the answer can be very large, return the answer **modulo** `109 + 7`.

**Example 1:**
```
Input: arr = [1,2], k = 3
Output: 9
```

**Example 2:**
```
Input: arr = [1,-2,1], k = 5
Output: 2
```

**Example 3:**
```
Input: arr = [-1,-2], k = 7
Output: 0
```

**Constraints:**

-   `1 <= arr.length <= 105`
-   `1 <= k <= 105`
-   `-104 <= arr[i] <= 104`


## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **K-Concatenation Pattern:**
   - Array repeats k times
   - Maximum subarray might span repeats
   - Three key cases based on k
   - Need to handle modular arithmetic

2. **Key Insights:**
   - Split into three cases:
     a) k = 1: Regular Kadane
     b) k = 2: Special case for connecting parts
     c) k > 2: Pattern repeats
   - Total sum affects long sequences
   - Need to handle negative sums carefully

### ðŸ” Edge Cases to Consider
- Single element array
- k = 1 (no repetition)
- All negative numbers
- Large k value (10^5)
- Maximum array length (10^5)
- Integer overflow cases
- Zero sum array
- Alternating positive/negative
- Sum very close to MOD

### ðŸŽ¯ Solution Approaches

1. **Modified Kadane's Algorithm**
   ```pseudo
   function kConcatenationMaxSum(arr, k):
       MOD = 1_000_000_007
       n = arr.length
       
       # Helper: Kadane's Algorithm
       def kadane(arr):
           maxSoFar = maxEndingHere = 0
           for num in arr:
               maxEndingHere = max(num, maxEndingHere + num)
               maxSoFar = max(maxSoFar, maxEndingHere)
           return maxSoFar
       
       # Calculate key values
       arraySum = sum(arr)
       oneRepeat = kadane(arr)
       twoRepeat = kadane(arr + arr)
       
       if k == 1:
           return oneRepeat % MOD
       
       if arraySum > 0:
           # Pattern: prefix + middle + suffix
           return (twoRepeat + (k-2) * arraySum) % MOD
       else:
           # Just take best consecutive sequence
           return twoRepeat % MOD
   ```
   Time: O(n), Space: O(1)

### ðŸ“ˆ Visual Explanation
```
Example: arr = [1,-2,1], k = 5

Array repeats: [1,-2,1,1,-2,1,1,-2,1,1,-2,1,1,-2,1]

Case Analysis:
1. Single copy max: 1
2. Two copies max: 2 (last 1 + first 1)
3. Full array sum: 0

For k = 5:
- Two-repeat handles connections
- Middle sections don't contribute
Result: 2
```

### ðŸ› ï¸ Implementation Tips
1. Use long for calculations
2. Apply modulo carefully
3. Handle negative sums
4. Check array boundaries
5. Consider overflow cases

### ðŸ“Š Complexity Analysis
- Time Complexity: O(n)
  - Single pass for Kadane's
  - Single pass for array sum
- Space Complexity: O(1)
  - Only constant extra space

### ðŸ”— Related Patterns
- Kadane's Algorithm
- Modular Arithmetic
- Prefix Sums
- Similar Problems:
  - Maximum Subarray
  - Maximum Sum Circular Subarray
  - Maximum Sum of Two Non-Overlapping Subarrays

### ðŸ“ Example Processing Flow
```
Input: arr = [1,2], k = 3

1. Calculate single repeat:
   maxSum = 3 (whole array)

2. Calculate two repeats:
   [1,2,1,2] â†’ maxSum = 6

3. Calculate array sum:
   sum = 3 (positive)

4. Result for k = 3:
   Two-repeat + (k-2)*sum
   = 6 + 1*3
   = 9
```

### âš ï¸ Common Mistakes to Avoid
1. Not handling MOD correctly
2. Integer overflow issues
3. Wrong case analysis
4. Missing negative sum cases
5. Incorrect boundary handling

```java
class Solution {
    public int kConcatenationMaxSum(int[] arr, int k) {
        final int MOD = 1_000_000_007;
        long sum = 0;
        for (int num : arr) sum += num;
        
        // Kadane's for one repeat
        long maxOne = kadane(arr);
        
        if (k == 1) return (int)(maxOne % MOD);
        
        // Kadane's for two repeats
        long maxTwo = kadaneTwo(arr);
        
        if (sum > 0) {
            // Pattern repeats beneficially
            long result = maxTwo + (k - 2) * sum;
            return (int)(result % MOD);
        } else {
            // Just take the best consecutive sequence
            return (int)(maxTwo % MOD);
        }
    }
    
    private long kadane(int[] arr) {
        long maxSoFar = 0, maxEndingHere = 0;
        for (int num : arr) {
            maxEndingHere = Math.max(num, maxEndingHere + num);
            maxSoFar = Math.max(maxSoFar, maxEndingHere);
        }
        return maxSoFar;
    }
    
    private long kadaneTwo(int[] arr) {
        int n = arr.length;
        long maxSoFar = 0, maxEndingHere = 0;
        for (int i = 0; i < 2*n; i++) {
            maxEndingHere = Math.max(arr[i % n], maxEndingHere + arr[i % n]);
            maxSoFar = Math.max(maxSoFar, maxEndingHere);
        }
        return maxSoFar;
    }
}

```
for (int i = 1; i < n * min(k, 2); i++) {
        sum = max(arr[i % n], sum + arr[i % n]);
        mx = max(mx, sum);
    }
```

The maximum sum will be maximum of the following:  
1. 0 (if all the elements are negative in the array)  2
2.  k * sum of all elements of array  
3. maximum suffix sum + maximum prefix sum (when k = 2)  
4. maximum suffix sum + maximum prefix sum + (k-2) sum of all elements of array

return max<int64_t>({0, mx, total * max(0, k - 2) + mx}) % mod;


```
n == the length of the input array

**Time Complexity** : O(n)<br>
**Space Complexity** : O(1)

```java
    int mod = (int) Math.pow(10, 9) + 7;
    public int kConcatenationMaxSum(int[] arr, int k) {
        if (k == 0) return 0;
        
        long sum = sum(arr),
             prefixSum = prefixSum(arr),
             suffixSum = suffixSum(arr),
             kadane = kadaneAlgo(arr);
        
        if (k == 1) return (int) kadane;
        long maxSum = kadane;
        if (sum < 0) maxSum = Math.max(maxSum, 
                                       (prefixSum + suffixSum) % mod);
        else maxSum = Math.max(maxSum, 
                               ((sum * (k - 2)) % mod + 
                                prefixSum + 
                                suffixSum) % mod);
        return (int) maxSum;
    }
    private long prefixSum(int[] arr) {
        
        int len = arr.length;
        long maxSum = arr[0],
            sum = arr[0];
        
        for (int i = 1; i < len; i++) {
            sum = (sum + arr[i]) % mod;
            maxSum = Math.max(maxSum, sum);
        }
        return maxSum;
    }
    private long suffixSum(int[] arr) {
        
        int len = arr.length;
        long maxSum = arr[len - 1],
            sum = arr[len - 1];
        
        for (int i = len - 2; i >= 0; i--) {
            sum = (sum + arr[i]) % mod;
            maxSum = Math.max(maxSum, sum);
        }
        return maxSum;
    }
    private long kadaneAlgo(int[] arr) {
        
        int len = arr.length;
        long maxSum = arr[0],
            sum = arr[0];
        
        for (int i = 1; i < len; i++) {
            sum = Math.max(arr[i], (sum + arr[i]) % mod);
            maxSum = Math.max(maxSum, sum);
        }
        if (maxSum < 0) return 0;
        return maxSum;
    }
    private long sum(int[] arr) {
        int len = arr.length;
        long sum = 0;
        for (int i = 0; i < len; i++)
            sum = (sum + arr[i]) % mod;
        return sum;
    }
```
