Link: [1156.¬†Swap For Longest Repeated Character Substring](https://leetcode.com/problems/swap-for-longest-repeated-character-substring/) <br>
Tag : **Medium**<br>
Lock: **Normal**

You are given a string¬†`text`. You can swap two of the characters in the¬†`text`.

Return¬†_the length of the longest substring with repeated characters_.

**Example 1:**
```
Input: text = "ababa"
Output: 3
Explanation: We can swap the first 'b' with the last 'a', or the last 'b' with the first 'a'. Then, the longest repeated character substring is "aaa" with length 3.
```

**Example 2:**
```
Input: text = "aaabaaa"
Output: 6
Explanation: Swap 'b' with the last 'a' (or the first 'a'), and we get longest repeated character substring "aaaaaa" with length 6.
```

**Example 3:**
```
Input: text = "aaaaa"
Output: 5
Explanation: No need to swap, longest repeated character substring is "aaaaa" with length is 5.
```

**Constraints:**
-   `1 <= text.length <= 2 * 104`
-   `text`¬†consist of lowercase English characters only.

## Detailed Intuition

### üí° How to Think About the Solution

1. **Character Swapping Concept:**
   - Can swap any two characters once
   - Need longest repeating sequence
   - Gap of one character can be bridged
   - Must consider character frequencies

2. **Key Insights:**
   - Process each character type separately
   - Allow one different character in window
   - Need extra character available for swap
   - Track total frequency of each character

### üîç Edge Cases to Consider
- Single character string
- Already all same characters
- No beneficial swaps possible
- Single character different
- Multiple gaps of size 1
- Maximum string length (2√ó10^4)
- All unique characters
- Repeating patterns
- Optimal swap not obvious

### üéØ Solution Approaches

1. **Character-wise Sliding Window**
   ```pseudo
   function maxRepeating(text):
       # Count total frequency of each char
       freq = count_frequencies(text)
       result = 1
       
       for ch in 'a'..'z':
           if ch not in text: continue
           
           # Find longest window with one different char
           count = different = start = 0
           for end in 0..n-1:
               if text[end] != ch:
                   different++
               
               # Shrink window if needed
               while different > 1:
                   if text[start] != ch:
                       different--
                   start++
               
               # Update result (min with total frequency)
               count = end - start + 1
               result = max(result, min(count, freq[ch]))
       
       return result
   ```
   Time: O(26√ón), Space: O(1)

### üìà Visual Explanation
```
Example: text = "aaabaaa"
Character 'a':

Step 1: Count total 'a's = 6
Window progression:
[a] ‚Üí 1
[aa] ‚Üí 2
[aaa] ‚Üí 3
[aaab] ‚Üí 4 (diff=1)
[aaba] ‚Üí 4 (diff=1)
[aabaa] ‚Üí 5 (diff=1)
[aabaaa] ‚Üí 6 (diff=1)

Can swap 'b' with another 'a'
Result = min(window_size, total_a) = 6
```

### üõ†Ô∏è Implementation Tips
1. Count frequencies first
2. Process each character separately
3. Handle window boundaries carefully
4. Track different character count
5. Consider available characters for swap

### üìä Complexity Analysis
- Time Complexity: O(26√ón)
  - Process each character type
  - Linear scan for each type
- Space Complexity: O(1)
  - Fixed size frequency array

### üîó Related Patterns
- Sliding Window
- Character Frequency Counting
- String Manipulation
- Similar Problems:
  - Longest Repeating Character Replacement
  - Max Consecutive Ones III
  - Longest Substring with At Most K Replacements

### üìù Example Processing Flow
```
Input: "ababa"

1. Count frequencies:
   a: 3, b: 2

2. Process 'a':
   Windows: [a], [ab], [aba], [abab], [ababa]
   Best: 3 (can swap one 'b')

3. Process 'b':
   Windows: [b], [ba], [bab], [baba]
   Best: 2 (can't improve due to frequency)

Result: 3 ('aaa' after swap)
```

### ‚ö†Ô∏è Common Mistakes to Avoid
1. Not checking total frequency
2. Wrong window expansion
3. Incorrect gap handling
4. Missing character types
5. Wrong swap availability check

```java
class Solution {
    public int maxRepOpt1(String text) {
        // Count frequencies
        int[] freq = new int[26];
        for (char c : text.toCharArray()) {
            freq[c - 'a']++;
        }
        
        int result = 1;
        
        // Try each character
        for (char ch = 'a'; ch <= 'z'; ch++) {
            if (freq[ch - 'a'] == 0) continue;
            
            int start = 0, different = 0;
            for (int end = 0; end < text.length(); end++) {
                if (text.charAt(end) != ch) different++;
                
                // Shrink window if needed
                while (different > 1) {
                    if (text.charAt(start) != ch) different--;
                    start++;
                }
                
                // Update result considering available chars
                int windowSize = end - start + 1;
                result = Math.max(result, 
                    Math.min(windowSize, freq[ch - 'a']));
            }
        }
        
        return result;
    }
}

```java
    public int maxRepOpt1(String text) {
        
        Map<Character, Integer> freq = new HashMap<>();
        for (char ch : text.toCharArray())
            freq.merge(ch, 1, Integer::sum);
        
        int maxLenSub = 0;
        for (int i = 0; i < 26; i++) {
            char repeated = (char)(i + 'a');
            maxLenSub = Math.max(maxLenSub, 
                                 getMaxlength(text, freq.getOrDefault(repeated, 0), repeated));
        }
        return maxLenSub;
    }
    private int getMaxlength(String text, int total, char repeated) {
        
        int start = 0,
            maxLength = 0,
            len = text.length(),
            otherChar = 1;
        
        for (int end = 0; end < len; end++) {
            char ch = text.charAt(end);
            if (ch != repeated) otherChar--;
            
            while (otherChar < 0) {
                ch = text.charAt(start);
                if (ch != repeated) otherChar++;
                start++;
            }
            maxLength = Math.max(maxLength, end - start + 1);
        }
        return Math.min(maxLength, total);
    }
```
