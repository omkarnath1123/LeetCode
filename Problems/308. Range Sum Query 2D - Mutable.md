Link: [308. Range Sum Query 2D - Mutable](https://leetcode.com/problems/range-sum-query-2d-mutable/) <br>
Tag : **Hard**<br>
Lock: **Premium**

Given a 2D matrix `matrix`, handle multiple queries of the following types:

1.  **Update** the value of a cell in `matrix`.
2.  Calculate the **sum** of the elements of `matrix` inside the rectangle defined by its **upper left corner** `(row1, col1)` and **lower right corner** `(row2, col2)`.

Implement the NumMatrix class:

-   `NumMatrix(int[][] matrix)` Initializes the object with the integer matrix `matrix`.
-   `void update(int row, int col, int val)` **Updates** the value of `matrix[row][col]` to be `val`.
-   `int sumRegion(int row1, int col1, int row2, int col2)` Returns the **sum** of the elements of `matrix` inside the rectangle defined by its **upper left corner** `(row1, col1)` and **lower right corner** `(row2, col2)`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/03/14/summut-grid.jpg)
```
Input
["NumMatrix", "sumRegion", "update", "sumRegion"]
[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [3, 2, 2], [2, 1, 4, 3]]
Output
[null, 8, null, 10]

Explanation
NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e. sum of the left red rectangle)
numMatrix.update(3, 2, 2);       // matrix changes from left image to right image
numMatrix.sumRegion(2, 1, 4, 3); // return 10 (i.e. sum of the right red rectangle)
```

**Constraints:**
-   `m == matrix.length`
-   `n == matrix[i].length`
-   `1 <= m, n <= 200`
-   `-105 <= matrix[i][j] <= 105`
-   `0 <= row < m`
-   `0 <= col < n`
-   `-105 <= val <= 105`
-   `0 <= row1 <= row2 < m`
-   `0 <= col1 <= col2 < n`
-   At most `104` calls will be made to `sumRegion` and `update`.

## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **2D Range Query Concept:**
   - Need efficient updates and range sums
   - Can extend 1D BIT to 2D
   - Each cell update affects multiple sums
   - Binary Indexed Tree gives O(log m Ã— log n) operations

2. **Key Insights:**
   - Use 2D Binary Indexed Tree
   - Store partial sums strategically
   - Each update affects O(log m Ã— log n) cells
   - Can decompose 2D query into 1D operations

### ðŸ” Edge Cases to Consider
- Single cell matrix
- Update same cell multiple times
- Query entire matrix
- Query single cell
- Maximum matrix size (200Ã—200)
- Negative numbers
- Zero values
- Overlapping queries
- Updates within query range

### ðŸŽ¯ Solution Approaches

1. **2D Binary Indexed Tree**
   ```pseudo
   class NumMatrix:
       def __init__(matrix):
           m, n = len(matrix), len(matrix[0])
           self.matrix = matrix
           self.bit = [[0]*(n+1) for _ in range(m+1)]
           
           # Initialize BIT
           for i in range(m):
               for j in range(n):
                   self.updateBIT(i+1, j+1, matrix[i][j])
       
       def update(row, col, val):
           diff = val - matrix[row][col]
           matrix[row][col] = val
           row += 1; col += 1
           
           i = row
           while i <= m:
               j = col
               while j <= n:
                   bit[i][j] += diff
                   j += j & (-j)
               i += i & (-i)
       
       def sumRegion(row1, col1, row2, col2):
           return (query(row2+1, col2+1) - 
                  query(row2+1, col1) -
                  query(row1, col2+1) + 
                  query(row1, col1))
   ```
   Time: 
   - Update: O(log m Ã— log n)
   - Query: O(log m Ã— log n)
   Space: O(mÃ—n)

### ðŸ“ˆ Visual Explanation
```
Matrix:
[3, 0, 1, 4, 2]
[5, 6, 3, 2, 1]
[1, 2, 0, 1, 5]
[4, 1, 0, 1, 7]
[1, 0, 3, 0, 5]

BIT Structure (partial sums):
Level 1: Single cells
Level 2: 2Ã—2 blocks
Level 3: 4Ã—4 blocks

Query (2,1,4,3):
+[0,0,4,3]
-[0,0,2,1]
-[2,0,4,3]
+[2,0,2,1]
```

### ðŸ› ï¸ Implementation Tips
1. Use 1-based indexing for BIT
2. Handle coordinate conversion
3. Cache original matrix
4. Optimize memory usage
5. Pre-compute initial state

### ðŸ“Š Complexity Analysis
- Time Complexity:
  - Initialization: O(mn log m log n)
  - Update: O(log m Ã— log n)
  - Query: O(log m Ã— log n)
- Space Complexity: O(mn)
  - Original matrix: O(mn)
  - BIT structure: O(mn)

### ðŸ”— Related Patterns
- Binary Indexed Tree (Fenwick Tree)
- Segment Tree
- Prefix Sum
- Similar Problems:
  - Range Sum Query - Immutable
  - Range Sum Query - Mutable
  - Matrix Block Sum

### ðŸ“ Example Processing Flow
```
Initial Matrix:
[3, 0, 1]
[5, 6, 3]
[1, 2, 0]

BIT Construction:
1. Add each value
2. Update affected cells
3. Maintain partial sums

Update(1,1,10):
1. Calculate diff = 10 - 6 = 4
2. Update affected cells in BIT
3. Maintain consistency
```

### âš ï¸ Common Mistakes to Avoid
1. Wrong indexing (0 vs 1-based)
2. Incorrect diff calculation
3. Missing coordinate translations
4. Wrong query decomposition
5. Inefficient memory usage

```java
class NumMatrix {
    private int[][] matrix;
    private int[][] bit;
    private int m, n;
    
    public NumMatrix(int[][] matrix) {
        this.matrix = matrix;
        this.m = matrix.length;
        this.n = matrix[0].length;
        this.bit = new int[m + 1][n + 1];
        
        // Initialize BIT
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                updateBIT(i + 1, j + 1, matrix[i][j]);
            }
        }
    }
    
    private void updateBIT(int row, int col, int diff) {
        for (int i = row; i <= m; i += i & (-i)) {
            for (int j = col; j <= n; j += j & (-j)) {
                bit[i][j] += diff;
            }
        }
    }
    
    private int queryBIT(int row, int col) {
        int sum = 0;
        for (int i = row; i > 0; i -= i & (-i)) {
            for (int j = col; j > 0; j -= j & (-j)) {
                sum += bit[i][j];
            }
        }
        return sum;
    }
    
    public void update(int row, int col, int val) {
        int diff = val - matrix[row][col];
        matrix[row][col] = val;
        updateBIT(row + 1, col + 1, diff);
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        return queryBIT(row2 + 1, col2 + 1)
             - queryBIT(row2 + 1, col1)
             - queryBIT(row1, col2 + 1)
             + queryBIT(row1, col1);
    }
}
```

![Range Sum Query](https://assets.leetcode.com/uploads/2021/03/14/summut-grid.jpg)

![[Range_Sum_Query_2D.png.png]]

```
n = no. of cells in the matrix

**Time Complexity** : update: O(log n) , query: O(log n) , build: O(n log n)<br>
**Space Complexity** : O(n)

```java
/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix obj = new NumMatrix(matrix);
 * obj.update(row,col,val);
 * int param_2 = obj.sumRegion(row1,col1,row2,col2);
 */
 
    int[][] store, tree;
    int len, bre;
    
    public NumMatrix(int[][] matrix) {
        len = matrix.length;
        bre = matrix[0].length;
        if (len == 0 || bre == 0) return;
        store = new int[len][bre];
        tree = new int[len + 1][bre + 1];
        
        for (int i = 0; i < len; i++)
            for (int j = 0; j < bre; j++)
                update(i, j, matrix[i][j]);
    }
    
    public void update(int row, int col, int val) {
        if (len == 0 || bre == 0) return;
        int delta = val - store[row][col];
        store[row][col] = val;
        
        for (int i = row + 1; i <= len; i += i & (-i))
            for (int j = col + 1; j <= bre; j += j & (-j))
                tree[i][j] = tree[i][j] + delta;
    }
    
    public int sumRegion(int rowOne, int colOne, int rowTwo, int colTwo) {
        if (len == 0 || bre == 0) return 0;
        rowTwo++;
        colTwo++;
        return sumRegionUtil(rowTwo, colTwo) + 
               sumRegionUtil(rowOne, colOne) - 
               sumRegionUtil(rowTwo, colOne) - 
               sumRegionUtil(rowOne, colTwo);
    }
    private int sumRegionUtil(int row, int col) {
        int sum = 0;
        for (int i = row; i > 0; i -= i & (-i))
            for (int j = col; j > 0; j -= j & (-j))
                sum = sum + tree[i][j];
        
        return sum;
    }
```
