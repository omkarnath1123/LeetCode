Link: [1528. Shuffle String](https://leetcode.com/problems/shuffle-string/description/) <br>
Tag : **Easy**<br>
Lock: **Normal**

You are given a string `s` and an integer array `indices` of the **same length**. The string `s` will be shuffled such that the character at the `ith` position moves to `indices[i]` in the shuffled string.

Return _the shuffled string_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/07/09/q1.jpg)

```
Input: s = "codeleet", indices = [4,5,6,7,0,2,1,3]
Output: "leetcode"
Explanation: As shown, "codeleet" becomes "leetcode" after shuffling.
```

**Example 2:**

```
Input: s = "abc", indices = [0,1,2]
Output: "abc"
Explanation: After shuffling, each character remains in its position.
```

**Constraints:**

- `s.length == indices.length == n`
- `1 <= n <= 100`
- `s` consists of only lowercase English letters.
- `0 <= indices[i] < n`
- All values of `indices` are **unique**.

**Solution:**

- [x] [[String]]

## Detailed Intuition

The indices array is a permutation that tells us where each character should end up: the character currently at position i in s must be placed at position indices[i] in the shuffled string. That direct one-to-one mapping suggests the simplest and most robust approach: allocate a result buffer of the same length as s (for example a char[] in Java) and for every index i, copy s.charAt(i) into result[indices[i]]. After processing all positions, the result buffer already contains the shuffled string.

How to think about the solution (mental checklist):
- Recognize the indices array as a mapping (i -> indices[i]) rather than a sorting key. There's no need to sort — just place characters at their target positions.
- Choose a writable buffer with fixed length n. For performance and simplicity, a char array is ideal in languages like Java/C#; in Python use a list of characters and then join.
- Iterate once through s (0..n-1) and perform the placement. This is O(n) time and O(n) extra space for the buffer.
- After filling the buffer, convert it back to a string and return.

Edge cases and what to check:
- n = 1 (minimum input): simply place the sole character at indices[0] (which must be 0). Your loop still works and returns the correct single-character string.
- Identity mapping: indices = [0,1,2,...]. The algorithm leaves characters in place; the buffer becomes identical to the input.
- Already shuffled input: if s already matches the desired output, mapping still produces the same string — idempotent.
- Constraints guarantee a valid permutation: every indices[i] is in [0, n-1] and values are unique. Under these guarantees you don't need to check for collisions or out-of-bounds placements. If working outside those guarantees, add validation to detect duplicates or invalid indices.
- Large n within problem limits: the approach scales linearly and uses predictable O(n) extra memory. For languages with immutable strings, prefer a mutable buffer to avoid repeated concatenation.

Alternative (in-place, optional):
- If O(1) extra space is required, you can perform the permutation in-place by following cycles of the permutation defined by indices. For each position not yet fixed, walk the cycle, swapping characters into their target positions until the cycle is closed. This is more error-prone and requires careful bookkeeping (for example, marking visited indices) but runs in O(n) time with O(1) extra space for the swaps. Given the problem constraints and expected solutions, the simple buffer-copy approach is clearer and preferable.

Why this is correct:
- Each position i contributes exactly one character and each destination indices[i] is unique, so the final buffer receives exactly one character per destination index. No overwrites or conflicts occur because we write into an initially-empty buffer at each unique destination.


```java
    public String restoreString(String s, int[] indices) {
        
        int len = s.length();
        char[] res = new char[len];
        for (int i = 0; i < len; i++) {
            res[indices[i]] = s.charAt(i);
        }
        return new String(res);
    }
```
