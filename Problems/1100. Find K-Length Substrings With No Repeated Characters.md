Link: [1100. Find K-Length Substrings With No Repeated Characters](https://leetcode.com/problems/find-k-length-substrings-with-no-repeated-characters/) <br>
Tag : **Medium**<br>
Lock: **Premium**

Given a string `s` and an integer `k`, return _the number of substrings in_ `s` _of length_ `k` _with no repeated characters_.

**Example 1:**
```
Input: s = "havefunonleetcode", k = 5
Output: 6
Explanation: There are 6 substrings they are: 'havef','avefu','vefun','efuno','etcod','tcode'.
```

**Example 2:**
```
Input: s = "home", k = 5
Output: 0
Explanation: Notice k can be larger than the length of s. In this case, it is not possible to find any substring.
```

**Constraints:**
-   `1 <= s.length <= 104`
-   `s` consists of lowercase English letters.
-   `1 <= k <= 104`

## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **Sliding Window Concept:**
   - Fixed-size window of length k
   - Window must contain unique characters
   - Slide window through string
   - Count valid windows

2. **Key Insights:**
   - Use frequency array for character counting
   - Window size control is critical
   - Early termination when s.length < k
   - Optimize character frequency tracking

### ðŸ” Edge Cases to Consider
- String length less than k
- k equals 1 (all single chars)
- k equals string length
- String with all same characters
- String with alternating characters
- Maximum string length (10^4)
- k greater than string length
- Empty string

### ðŸŽ¯ Solution Approaches

1. **Sliding Window with Character Frequency**
   ```pseudo
   function findKLenSubstrings(s, k):
       if len(s) < k: return 0
       
       count = 0
       freq = new int[26]  # Character frequency
       left = right = 0
       
       while right < len(s):
           # Add right character
           freq[s[right] - 'a']++
           
           # Shrink window if duplicates
           while freq[s[right] - 'a'] > 1:
               freq[s[left] - 'a']--
               left++
           
           # Count valid window
           if right - left + 1 == k:
               count++
               freq[s[left] - 'a']--
               left++
           
           right++
       
       return count
   ```
   Time: O(n), Space: O(1)

### ðŸ“ˆ Visual Explanation
```
Example: s = "havefun", k = 3

Window movement:
[hav]efun  â†’ Valid (count=1)
h[ave]fun  â†’ Valid (count=2)
ha[vef]un  â†’ Valid (count=3)
hav[efu]n  â†’ Valid (count=4)
have[fun]  â†’ Valid (count=5)

Character frequency tracking:
Step 1: "hav" â†’ {h:1, a:1, v:1} âœ“
Step 2: "ave" â†’ {a:1, v:1, e:1} âœ“
Step 3: "vef" â†’ {v:1, e:1, f:1} âœ“
```

### ðŸ› ï¸ Implementation Tips
1. Use array instead of HashMap for O(1) lookup
2. Process right pointer before left
3. Handle window size carefully
4. Early return if string too short
5. Optimize frequency updates

### ðŸ“Š Complexity Analysis
- Time Complexity: O(n)
  - Single pass through string
  - Each character processed at most twice
- Space Complexity: O(1)
  - Fixed-size array for 26 lowercase letters
  - Independent of input size

### ðŸ”— Related Patterns
- Sliding Window
- Hash Table/Frequency Counter
- Two Pointers
- Similar Problems:
  - Longest Substring Without Repeating Characters
  - Permutation in String
  - Substring with Concatenation of All Words

### ðŸ“ Example Processing Flow
```
Input: s = "havefun", k = 3

Step-by-step window processing:
1. "hav" â†’ unique â†’ count = 1
2. "ave" â†’ unique â†’ count = 2
3. "vef" â†’ unique â†’ count = 3
4. "efu" â†’ unique â†’ count = 4
5. "fun" â†’ unique â†’ count = 5

Total count = 5 valid substrings
```

### âš ï¸ Common Mistakes to Avoid
1. Not handling k > string length
2. Incorrect window size management
3. Not resetting frequency counts properly
4. Off-by-one errors in window bounds
5. Inefficient character frequency tracking

```java
    public int numKLenSubstrNoRepeats(String s, int k) {
        if (s == null || s.length() < k) 
            return 0;
        
        Map<Character, Integer> freq = new HashMap<>();
        
        char[] source = s.toCharArray();
        int len = source.length,
            count = 0,
            start = 0,
            nonUniq = 0;
        for (int end = 0; end < len; end++) {
            char ch = source[end];
            freq.merge(ch, 1, Integer::sum);
            if (freq.get(ch) != 1) nonUniq++;
            
            while (end - start >= k) {
                ch = source[start];
                freq.merge(ch, -1, Integer::sum);
                if (freq.get(ch) > 0) nonUniq--;
                if (freq.get(ch) == 0) freq.remove(ch);
                start++;
            }
            if (end - start + 1 == k && nonUniq == 0)
                count++;
        }
        return count;
    }
```


