Link: [509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/description/) <br>
Tag : **Easy**<br>
Lock: **Normal**

The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,

F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.
Given n, calculate F(n).

 

Example 1:

```
Input: n = 2
Output: 1
Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.
```
Example 2:

```
Input: n = 3
Output: 2
Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.
```
Example 3:

```
Input: n = 4
Output: 3
Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.
```
 

Constraints:

0 <= n <= 30

**Solution:**

- [x] [[Dynamic Programming 1]]

## Detailed Intuition

Think of the Fibonacci definition as a recurrence: F(n) = F(n-1) + F(n-2). That equation tells you two things: the solution for n depends only on the two previous values, and you have two base values (F(0) and F(1)). Use that structure to decide between recursion, memoization, or an iterative DP approach.

Step-by-step thought process:

- Identify the subproblem: compute F(i) for i = 0..n. Each subproblem depends only on the two immediately smaller subproblems (i-1 and i-2).
- Choose an evaluation order: because F(i) depends on smaller indices, compute values in increasing order (bottom-up). This avoids repeated work that naive recursion would do.
- Store only what you need: since F(i) only requires the two previous values, you can either keep a full array of size n+1 (clear and easy) or reduce space to O(1) by keeping just two variables (prev and curr).
- Verify base cases: set F(0)=0 and F(1)=1 before starting the loop/recursion so the recurrence has correct seeds.

Concrete iterative (bottom-up) plan:
1. Handle trivial cases immediately: if n == 0 return 0; if n == 1 return 1.
2. Initialize two variables a = 0 (F(0)), b = 1 (F(1)).
3. Loop from i = 2 to n:
   - next = a + b
   - a = b
   - b = next
4. After the loop b holds F(n); return b.

Why this is correct:
- The loop mimics the recurrence and computes every intermediate F(i) exactly once. By carrying forward only the two required values we satisfy the dependency F(i) = F(i-1) + F(i-2) while using constant space.

Edge cases and how to think about them:
- n = 0 and n = 1: must return 0 and 1 respectively without entering the main loop. These are the base seeds of the recurrence.
- Small n values (2, 3, 4): use them as quick sanity checks — they validate the loop and the update order.
- Upper constraint boundary (here n <= 30): ensure your type (int) won't overflow for the problem constraints; for larger n you'd consider larger integer types or modular arithmetic if required.
- Negative input: the problem constraints exclude negatives; if you were writing a public API, validate and handle invalid inputs explicitly (e.g., throw or return an error) rather than producing undefined behavior.

Common pitfalls:
- Using naive recursion without memoization leads to exponential time due to repeated subproblems.
- Off-by-one errors in the loop range or returning the wrong variable (returning `a` instead of `b` after the loop).
- Forgetting to set base values before the loop.

Test cases to validate manually:
- n = 0 -> 0 (base)
- n = 1 -> 1 (base)
- n = 2 -> 1 (1+0)
- n = 3 -> 2 (1+1)
- n = 4 -> 3 (2+1)
- n = 30 -> 832040 (boundary check for given constraints)

Complexity summary:
- Time complexity: O(n) — each Fibonacci number from 2 to n is computed once.
- Space complexity: O(1) with the two-variable optimization, or O(n) if you explicitly store an array of size n+1.

How to think about the solution when you see similar problems:
- Ask: what are the subproblems and how do they depend on each other? If each subproblem depends on a small fixed number of previous subproblems (like k previous values), you can usually solve it with O(1) extra space by carrying just those k values.
- Decide between top-down (memoized recursion) and bottom-up (iterative DP) based on clarity and required constraints; bottom-up is often simpler and more space-efficient when dependencies are only on smaller indices.


```java
    private int[] res = new int[31];
    public int fib(int n) {
        
        res[1] = 1;
        if (n <= 1) return res[n];
        else if (n > 1 && res[n] != 0) return res[n];

        for (int i = 2; i < 31; i++)
            res[i] = res[i - 1] + res[i - 2];
        return res[n];
    }
```
