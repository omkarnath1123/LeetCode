Link: [1258. Synonymous Sentences](https://leetcode.com/problems/synonymous-sentences/) <br>
Tag : **Medium**<br>
Lock: **Premium**

You are given a list of equivalent string pairs `synonyms` where `synonyms[i] = [si, ti]` indicates that `si` and `ti` are equivalent strings. You are also given a sentence `text`.

Return _all possible synonymous sentences **sorted lexicographically**_.

**Example 1:**
```
Input: synonyms = [["happy","joy"],["sad","sorrow"],["joy","cheerful"]], text = "I am happy today but was sad yesterday"
Output: ["I am cheerful today but was sad yesterday","I am cheerful today but was sorrow yesterday","I am happy today but was sad yesterday","I am happy today but was sorrow yesterday","I am joy today but was sad yesterday","I am joy today but was sorrow yesterday"]
```

**Example 2:**
```
Input: synonyms = [["happy","joy"],["cheerful","glad"]], text = "I am happy today but was sad yesterday"
Output: ["I am happy today but was sad yesterday","I am joy today but was sad yesterday"]
```

**Constraints:**
-   `0 <= synonyms.length <= 10`
-   `synonyms[i].length == 2`
-   `1 <= si.length, ti.length <= 10`
-   `si != ti`
-   `text` consists of at most `10` words.
-   The words of `text` are separated by single spaces.


## Detailed Intuition

### üí° How to Think About the Solution

1. **Word Groups Concept:**
   - Words form synonym groups
   - Groups connected by transitive relations
   - Need to generate all combinations
   - Must maintain lexicographic order

2. **Key Insights:**
   - Use Union-Find for word groups
   - DFS for sentence generation
   - Sort synonyms for order
   - Track word replacements

### üîç Edge Cases to Consider
- No synonyms given
- Single word text
- All words have synonyms
- Cyclic synonyms
- Maximum synonyms (10)
- Maximum word length (10)
- Words not in synonym list
- Multiple word groups
- Transitive relationships
- Empty text

### üéØ Solution Approaches

1. **Union-Find with DFS Generation**
   ```pseudo
   function generateSentences(synonyms, text):
       # Build word groups using Union-Find
       uf = UnionFind()
       for [s, t] in synonyms:
           uf.union(s, t)
       
       # Create synonym groups
       groups = Map<String, TreeSet<String>>()
       for [s, t] in synonyms:
           root = uf.find(s)
           groups[root].add(s)
           groups[root].add(t)
       
       # Generate sentences
       words = text.split(" ")
       result = []
       
       function dfs(index, current):
           if index == words.length:
               result.add(join(current))
               return
           
           word = words[index]
           root = uf.find(word)
           
           if root in groups:
               for synonym in groups[root]:
                   current[index] = synonym
                   dfs(index + 1, current)
           else:
               current[index] = word
               dfs(index + 1, current)
       
       dfs(0, new String[words.length])
       sort(result)
       return result
   ```
   Time: O(S + W √ó K^N), Space: O(S + W)
   where S = total synonyms, W = words in text,
   K = max synonyms per word, N = words with synonyms

### üìà Visual Explanation
```
Example:
synonyms = [["happy","joy"],["joy","cheerful"]]
text = "I am happy today"

Word Groups:
{happy, joy, cheerful}

Sentence Generation Tree:
                 "I am _ today"
                /      |       \
    "I am happy" "I am joy" "I am cheerful"
         |           |           |
"I am happy today" ...etc...    ...
```

### üõ†Ô∏è Implementation Tips
1. Use TreeSet for ordered synonyms
2. Cache word groups
3. Build sentence incrementally
4. Sort final results
5. Handle word not in synonyms

### üìä Complexity Analysis
- Time Complexity: O(S + W √ó K^N)
  - S = process all synonyms
  - W = text words
  - K = max synonyms per word
  - N = words with synonyms
- Space Complexity: O(S + W)
  - Store synonym groups
  - Store generated sentences

### üîó Related Patterns
- Union Find
- DFS/Backtracking
- String Processing
- Similar Problems:
  - Word Ladder
  - Similar String Groups
  - Word Break II

### üìù Example Processing Flow
```
Input:
synonyms = [["happy","joy"],["joy","cheerful"]]
text = "I am happy today"

1. Build groups:
   happy -> {cheerful, happy, joy}

2. Process text:
   "I": no synonyms -> keep
   "am": no synonyms -> keep
   "happy": has synonyms -> try all
   "today": no synonyms -> keep

3. Generated sentences:
   "I am cheerful today"
   "I am happy today"
   "I am joy today"
```

### ‚ö†Ô∏è Common Mistakes to Avoid
1. Missing transitive relations
2. Wrong lexicographic order
3. Inefficient word lookup
4. Memory inefficient generation
5. Missing word combinations

```java
class Solution {
    class UnionFind {
        Map<String, String> parent = new HashMap<>();
        
        String find(String x) {
            if (!parent.containsKey(x)) {
                parent.put(x, x);
            }
            if (!parent.get(x).equals(x)) {
                parent.put(x, find(parent.get(x)));
            }
            return parent.get(x);
        }
        
        void union(String x, String y) {
            String px = find(x), py = find(y);
            if (px.compareTo(py) > 0) {
                parent.put(px, py);
            } else {
                parent.put(py, px);
            }
        }
    }
    
    public List<String> generateSentences(List<List<String>> synonyms, 
                                        String text) {
        // Build word groups
        UnionFind uf = new UnionFind();
        Map<String, TreeSet<String>> groups = new HashMap<>();
        
        for (List<String> pair : synonyms) {
            String w1 = pair.get(0), w2 = pair.get(1);
            uf.union(w1, w2);
        }
        
        for (List<String> pair : synonyms) {
            String root = uf.find(pair.get(0));
            groups.computeIfAbsent(root, k -> new TreeSet<>())
                 .add(pair.get(0));
            groups.computeIfAbsent(root, k -> new TreeSet<>())
                 .add(pair.get(1));
        }
        
        // Generate sentences
        String[] words = text.split(" ");
        List<String> result = new ArrayList<>();
        dfs(words, 0, new String[words.length], result, groups, uf);
        Collections.sort(result);
        return result;
    }
    
    private void dfs(String[] words, int index, String[] current,
                    List<String> result, Map<String, TreeSet<String>> groups,
                    UnionFind uf) {
        if (index == words.length) {
            result.add(String.join(" ", current));
            return;
        }
        
        String word = words[index];
        String root = uf.find(word);
        
        if (groups.containsKey(root)) {
            for (String synonym : groups.get(root)) {
                current[index] = synonym;
                dfs(words, index + 1, current, result, groups, uf);
            }
        } else {
            current[index] = word;
            dfs(words, index + 1, current, result, groups, uf);
        }
    }
}
   - Store all words in each group

2. **Sentence Generation**:
   - Process text word by word
   - For each word with synonyms:
     - Try all alternatives
     - Build new sentences

### Visual Guide:
```
Example: 
synonyms = [["happy","joy"],["sad","sorrow"],["joy","cheerful"]]
text = "I am happy today"

Word Groups:
Group 1: {happy, joy, cheerful}
Group 2: {sad, sorrow}

Sentence Building:
"I"     -> no synonyms
"am"    -> no synonyms
"happy" -> try [happy, joy, cheerful]
"today" -> no synonyms

Results:
"I am happy today"
"I am joy today"
"I am cheerful today"
```

### Edge Cases to Consider:
- No synonyms
- All words have synonyms
- Circular synonym relationships
- Single word sentences
- Maximum input size (10 words)

### Common Pitfalls:
1. Not handling transitive relationships
2. Wrong lexicographical ordering
3. Missing synonym combinations
4. Inefficient group tracking

### Optimization Techniques:
1. **Group Management**:
   - Use Union-Find with path compression
   - Pre-sort synonym groups
   - Cache word-to-group mappings

2. **Sentence Generation**:
   - Use StringBuilder
   - Generate incrementally
   - Sort words within groups once

### Time and Space Analysis:
- Time Complexity: O(n √ó m^k)
  - n = words in text
  - m = avg synonyms per word
  - k = words with synonyms
- Space Complexity: O(n √ó m)
  - Store all possible combinations

### Similar Problems:
- Word Ladder
- Similar String Groups
- Account Merge

### Implementation Tips:
1. Use efficient Union-Find
2. Pre-process synonym groups
3. Build sentences incrementally
4. Sort results early

### Useful Resources:
- [Union-Find Applications](https://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf)
- [String Processing Techniques](https://www.geeksforgeeks.org/string-data-structure/)
**Time Complexity** : O(n<sup>m</sup>)<br>
**Space Complexity** : O(n)

```java
    List<String> comb;
    public List<String> generateSentences(List<List<String>> synonyms, String text) {
        
        comb = new LinkedList<>();
        DisjointSet set = new DisjointSet();
        
        for (List<String> synonym : synonyms)
            for (int i = 0; i < synonym.size(); i++)
                set.union(synonym.get(0), synonym.get(i));
        
        String[] words = text.split(" ");
        backTrack(words, 0, new StringBuilder(), set, set.getSets());
        return comb;
    }
    private void backTrack(String[] words, int index, StringBuilder sb, DisjointSet set, Map<String, List<String>> synonyms) {
        if (index == words.length) {
            comb.add(sb.toString().substring(1));
        } else {
            int len = sb.length();
            String word = words[index];
            
            if (set.contains(word)) {
                String parent = set.find(word);
                List<String> synonym = synonyms.get(parent);
                for (String alter : synonym) {
                    sb.append(" ").append(alter);
                    backTrack(words, index + 1, sb, set, synonyms);
                    sb.setLength(len);
                }
            } else {
                sb.append(" ").append(word);
                backTrack(words, index + 1, sb, set, synonyms);
                sb.setLength(len);
            }
        }
    }
    class DisjointSet {
        class Node {
            String val;
            Node parent;
            int rank = 0;
            Node (String val) {
                this.val = val;
            }
        }
        Map<String, Node> map = new HashMap<>();
        private void makeSet(String val) {
            map.computeIfAbsent(val, item -> {
                Node node = new Node(val);
                node.parent = node;
                return node;
            });
        }
        public String find(String val) {
            makeSet(val);
            return findSet(map.get(val)).val;
        }
        private Node findSet(Node node) {
            if (node.parent == node)
                return node.parent;
            node.parent = findSet(node.parent);
            return node.parent;
        }
        public void union(String one, String two) {
            makeSet(one);
            makeSet(two);
            Node left = findSet(map.get(one)),
                 right = findSet(map.get(two));
            if (left == right) return;
            
            if (left.rank < right.rank)
                left.parent = right;
            else if (right.rank < left.rank)
                right.parent = left;
            else {
                left.parent = right;
                right.rank++;
            }
        }
        public Map<String, List<String>> getSets() {
            
            Map<String, List<String>> sets = new HashMap<>();
            for (String key : map.keySet())
                sets.computeIfAbsent(find(key), item -> new ArrayList<>()).add(key);
            
            for (Map.Entry<String, List<String>> entry : sets.entrySet())
                Collections.sort(entry.getValue());
            return sets;
        }
        public boolean contains(String val) {
            return map.containsKey(val);
        }
    }
```
