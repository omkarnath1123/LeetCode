Link: [1245.Â Tree Diameter](https://leetcode.com/problems/tree-diameter/) <br>
Tag : **Medium**<br>
Lock: **Premium**

TheÂ **diameter**Â of a tree isÂ **the number of edges**Â in the longest path in that tree.

There is an undirected tree ofÂ `n`Â nodes labeled fromÂ `0`Â toÂ `n - 1`. You are given a 2D arrayÂ `edges`Â whereÂ `edges.length == n - 1`Â andÂ `edges[i] = [ai, bi]`Â indicates that there is an undirected edge between nodesÂ `ai`Â andÂ `bi`Â in the tree.

ReturnÂ _theÂ **diameter**Â of the tree_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2022/01/19/tree1.jpg)
```
Input: edges = [[0,1],[0,2]]
Output: 2
Explanation: The longest path of the tree is the path 1 - 0 - 2.
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2022/01/19/tree2.jpg)
```
Input: edges = [[0,1],[1,2],[2,3],[1,4],[4,5]]
Output: 4
Explanation: The longest path of the tree is the path 3 - 2 - 1 - 4 - 5.
```

**Constraints:**
-   `n == edges.length + 1`
-   `1 <= n <= 104`
-   `0 <= ai, biÂ < n`
-   `aiÂ != bi`

## Detailed Intuition

### ğŸ’¡ How to Think About the Solution

1. **Tree Diameter Concept:**
   - Diameter is longest path between any two nodes
   - Path may or may not pass through root
   - Need to consider all possible "peak" nodes
   - Only edges count in path length

2. **Key Insights:**
   - Use DFS to explore paths
   - Each node needs two longest paths
   - Bottom-up calculation works best
   - Single traversal is sufficient

### ğŸ” Edge Cases to Consider
- Single edge tree
- Linear tree (path)
- Balanced tree
- Star topology
- Maximum nodes (10^4)
- All nodes form path
- Multiple equal diameters
- Leaf to leaf path
- Root to leaf path
- Deep unbalanced tree

### ğŸ¯ Solution Approaches

1. **DFS with Path Length Tracking**
   ```pseudo
   function treeDiameter(edges):
       # Build adjacency list
       graph = buildGraph(edges)
       diameter = 0
       
       function dfs(node, parent):
           # Find two longest paths from node
           longest = secondLongest = 0
           
           for neighbor in graph[node]:
               if neighbor == parent:
                   continue
               
               childPath = dfs(neighbor, node)
               if childPath > longest:
                   secondLongest = longest
                   longest = childPath
               else if childPath > secondLongest:
                   secondLongest = childPath
           
           # Update global diameter
           diameter = max(diameter, longest + secondLongest)
           
           return longest + 1
       
       dfs(0, -1)
       return diameter
   ```
   Time: O(n), Space: O(n)

### ğŸ“ˆ Visual Explanation
```
Example:
     0
   /   \
  1     2
 / \
4   5
 \
  3

DFS Processing:
Node 3: returns 1
Node 4: returns 2 (via 3)
Node 5: returns 1
Node 1: longest=2, secondLongest=1
Node 2: returns 1
Node 0: longest=3, secondLongest=1

Diameter = 4 (path: 3-4-1-0-2)
```

### ğŸ› ï¸ Implementation Tips
1. Build adjacency list first
2. Skip parent in traversal
3. Track two longest paths
4. Update diameter globally
5. Handle leaf nodes properly

### ğŸ“Š Complexity Analysis
- Time Complexity: O(n)
  - Single DFS traversal
  - Each edge visited twice
- Space Complexity: O(n)
  - Adjacency list storage
  - Recursion stack

### ğŸ”— Related Patterns
- Depth First Search
- Tree Traversal
- Path Finding
- Similar Problems:
  - Binary Tree Diameter
  - Network Delay Time
  - All Paths from Source to Target

### ğŸ“ Example Processing Flow
```
Input: edges = [[0,1],[1,2],[2,3],[1,4],[4,5]]

1. Build graph:
   0: [1]
   1: [0,2,4]
   2: [1,3]
   3: [2]
   4: [1,5]
   5: [4]

2. DFS from node 0:
   5 â†’ returns 1
   4 â†’ returns 2
   3 â†’ returns 1
   2 â†’ returns 2
   1 â†’ updates diameter = 4

Result: 4 (path: 3-2-1-4-5)
```

### âš ï¸ Common Mistakes to Avoid
1. Not skipping parent node
2. Wrong path length calculation
3. Missing diameter updates
4. Inefficient graph representation
5. Not handling disconnected cases

```java
class Solution {
    private List<List<Integer>> graph;
    private int diameter;
    
    public int treeDiameter(int[][] edges) {
        int n = edges.length + 1;
        graph = new ArrayList<>();
        diameter = 0;
        
        // Build graph
        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList<>());
        }
        for (int[] edge : edges) {
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }
        
        dfs(0, -1);
        return diameter;
    }
    
    private int dfs(int node, int parent) {
        int longest = 0, secondLongest = 0;
        
        for (int neighbor : graph.get(node)) {
            if (neighbor == parent) continue;
            
            int childPath = dfs(neighbor, node);
            if (childPath > longest) {
                secondLongest = longest;
                longest = childPath;
            } else if (childPath > secondLongest) {
                secondLongest = childPath;
            }
        }
        
        diameter = Math.max(diameter, longest + secondLongest);
        return longest + 1;
    }
}
   - Build adjacency list
   - Handle undirected edges
   - Choose any node as root

2. **DFS Strategy**:
   - Return longest path to leaf
   - Track top two path lengths
   - Update global diameter

### Visual Guide:
```
Example: edges = [[0,1],[1,2],[2,3],[1,4],[4,5]]

Tree Structure:
     0
     |
     1
    / \
   2   4
   |   |
   3   5

At node 1:
- Path to 3: length 2
- Path to 5: length 2
- Local diameter = 4 (3-2-1-4-5)
- Return max(2,2) + 1 = 3 to parent

DFS returns at each node:
3 â†’ 1
2 â†’ 2
1 â†’ 3
5 â†’ 1
4 â†’ 2
0 â†’ 1
```

### Edge Cases to Consider:
- Single node tree
- Linear tree (path)
- Balanced tree
- Star topology
- Maximum size (10^4 nodes)

### Common Pitfalls:
1. Not tracking both paths
2. Wrong diameter calculation
3. Missing leaf paths
4. Incorrect path length counting

### Optimization Techniques:
1. **Path Tracking**:
   - Only need top two lengths
   - Early termination possible
   - Avoid revisiting nodes

2. **Memory Usage**:
   - No need to store all paths
   - Constant extra space per node
   - Clear visited set after use

### Time and Space Analysis:
- Time Complexity: O(n)
  - Single tree traversal
  - Constant work per node
- Space Complexity: O(n)
  - Recursion stack
  - Adjacency list storage

### Similar Problems:
- Binary Tree Diameter
- Network Delay Time
- All Paths from Source to Target

### Implementation Tips:
1. Use global variable for diameter
2. Clear visited set properly
3. Handle undirected edges
4. Count edges, not nodes

### Useful Resources:
- [Tree Traversal Techniques](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)
- [Graph Theory Basics](https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/)

**Solution:**
- [x]  [[Depth First Search]] 

**Intuition** :
Given the above intuition, we could apply the DFS (Depth-First Search) strategy to obtain theÂ **longest**Â path that traverse each node.
During the DFS traversal, we would also update the diameter with the longest path that we obtain at each node.

-   First of all, we could convert the input edges into the adjacency list, which this time we would treat as Tree, rather than Graph. We assume the node with the index ofÂ `0`Â as the root node.
-   We then define a function namedÂ `dfs(curr, visited)`Â which returns the maximal distance starting from theÂ `curr`Â node to any of its descendant leaf nodes. TheÂ `visited`Â parameter is used to keep track of the nodes that we've visited so far.
-   Within the function ofÂ `dfs(curr, visited)`, we will obtain the top two maximal distances starting from theÂ `curr`Â node. With these top two distances, we can then update the globalÂ `diameter`Â that we've seen so far.
-   Once we traverse the entire tree once and only once, we will obtain theÂ `diameter`Â of the tree/graph.

```
n = nodes in the graph

**Time Complexity** : O(n)<br>
**Space Complexity** : O(n)

```java
    Map<Integer, Set<Integer>> tree;
    int diameter;
    
    public int treeDiameter(int[][] edges) {
        initilizeGraph(edges);
        diameter = 0;
        depthFirstSearch(0, new HashSet<>());
        return diameter;
    }
    private int depthFirstSearch(int source, Set<Integer> visited) {
        
        visited.add(source);
        int max = 0, secMax = 0;
        
        for (int child : tree.getOrDefault(source, new HashSet<>())) {
            if (visited.contains(child)) continue;
            int depth = depthFirstSearch(child, visited) + 1;
            
            if (depth > max) {
                secMax = max;
                max = depth;
            } else if (depth > secMax)
                secMax = depth;
        }
        diameter = Math.max(diameter, max + secMax);
        
        return max;
    }
    private void initilizeGraph(int[][] edges) {
        tree = new HashMap<>();
        for (int[] edge : edges) {
            tree.computeIfAbsent(edge[0], item -> new HashSet<>()).add(edge[1]);
            tree.computeIfAbsent(edge[1], item -> new HashSet<>()).add(edge[0]);
        }
    }
````
