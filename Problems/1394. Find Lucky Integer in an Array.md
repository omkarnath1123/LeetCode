Link: [1394. Find Lucky Integer in an Array](https://leetcode.com/problems/find-lucky-integer-in-an-array/description/?envType=daily-question&envId=2025-11-10) <br>
Tag : **Medium**<br>
Lock: **Normal**

Given the `root` of a binary tree, the depth of each node is **the shortest distance to the root**.

Return _the smallest subtree_ such that it contains **all the deepest nodes** in the original tree.

A node is called **the deepest** if it has the largest depth possible among any node in the entire tree.

The **subtree** of a node is a tree consisting of that node, plus the set of all descendants of that node.

**Example 1:**

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png)

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4]
Output: [2,7,4]
Explanation: We return the node with value 2, colored in yellow in the diagram.
The nodes coloured in blue are the deepest nodes of the tree.
Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.
```

**Example 2:**

```
Input: root = [1]
Output: [1]
Explanation: The root is the deepest node in the tree.
```

**Example 3:**

```
Input: root = [0,1,3,null,2]
Output: [2]
Explanation: The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.
```

**Constraints:**

- The number of nodes in the tree will be in the range `[1, 500]`.
- `0 <= Node.val <= 500`
- The values of the nodes in the tree are **unique**.

**Solution:**

- [x] [[Depth First Search]]

## Detailed Intuition

Think of the binary tree as a **hierarchy** starting from a root (top) and going downward through children.

- The **depth** of a node is how far it is from the root.
- The **deepest nodes** are those that are **farthest away from the root** (maximum depth).
- There may be:
    - **One deepest node** → that node alone forms the answer.
    - **Multiple deepest nodes** → we need the **smallest subtree** that contains _all_ of them.  
        ![fri.png](https://assets.leetcode.com/users/images/2112d1d7-b87b-41fa-91ab-240ecf651d30_1767925387.2343955.png)

**Time Complexity** : O(n)<br>
**Space Complexity** : O(n)

```java
    Map<TreeNode, TreeNode> parentNode;
    public TreeNode subtreeWithAllDeepest(TreeNode root) {
        
        int height = height(root);
        parentNode = new HashMap<>();
        traverse(root, null);
        ArrayDeque<TreeNode> deepestNodes = getDeepestNodes(root, height);
        return traceParent(deepestNodes);
    }
    private TreeNode traceParent(ArrayDeque<TreeNode> queue) {

        Set<TreeNode> visited = new HashSet<>();
        int size = queue.size();
        while (queue.size() > 1) {
            size--;
            TreeNode remove = queue.pollFirst();
            TreeNode parent = parentNode.get(remove);
            if (!visited.contains(parent)) {
                visited.add(parent);
                queue.offerLast(parent);
            }

            if (size == 0) {
                size = queue.size();
            }
        }
        return queue.pollFirst();
    }
    private ArrayDeque<TreeNode> getDeepestNodes(TreeNode node, int height) {

        ArrayDeque<TreeNode> queue = new ArrayDeque<>();
        queue.offerLast(node);
        int currHeight = 1, size = queue.size();

        while (currHeight < height) {
            size--;
            TreeNode remove = queue.pollFirst();
            if (remove.left != null) queue.offerLast(remove.left);
            if (remove.right != null) queue.offerLast(remove.right);

            if (size == 0) {
                size = queue.size();
                currHeight++;
            }
            if (currHeight == height) break;
        }
        return queue;
    }
    private void traverse(TreeNode node, TreeNode parent) {
        if (node == null) return;

        parentNode.put(node, parent);
        traverse(node.left, node);
        traverse(node.right, node);
    }
    private int height(TreeNode node) {
        if (node == null) return 0;
        return Math.max(height(node.left), height(node.right)) + 1;
    }
```

