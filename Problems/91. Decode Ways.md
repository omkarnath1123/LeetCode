Link: [91. Decode Ways](https://leetcode.com/problems/decode-ways/description/) <br>
Tag : **Medium**<br>
Lock: **Normal**

You have intercepted a secret message encoded as a string of numbers. The message is **decoded** via the following mapping:

`"1" -> 'A'   "2" -> 'B'   ...   "25" -> 'Y'   "26" -> 'Z'`

However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (`"2"` and `"5"` vs `"25"`).

For example, `"11106"` can be decoded into:

- `"AAJF"` with the grouping `(1, 1, 10, 6)`
- `"KJF"` with the grouping `(11, 10, 6)`
- The grouping `(1, 11, 06)` is invalid because `"06"` is not a valid code (only `"6"` is valid).

Note: there may be strings that are impossible to decode.  
  
Given a string s containing only digits, return the **number of ways** to **decode** it. If the entire string cannot be decoded in any valid way, return `0`.

The test cases are generated so that the answer fits in a **32-bit** integer.

**Example 1:**

```
Input: s = "12"

Output: 2

Explanation:

"12" could be decoded as "AB" (1 2) or "L" (12).
```

**Example 2:**

```
Input: s = "226"

Output: 3

Explanation:

"226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
```

**Example 3:**

```
Input: s = "06"

Output: 0

Explanation:

"06" cannot be mapped to "F" because of the leading zero ("6" is different from "06"). In this case, the string is not a valid encoding, so return 0.
```

**Constraints:**

- `1 <= s.length <= 100`
- `s` contains only digits and may contain leading zero(s).

**Solution:**

- [x] [[Dynamic Programming]] + [[Top-Down Solution]]

## Detailed Intuition

Below is a focused, step-by-step intuition you can use when approaching this problem. It explains the recurrence, how to think about choices at each position, common pitfalls (especially zeros), and several concrete edge cases you should test.

- Problem view (local choices): At every position in the string you have up to two choices: take the current digit as a single valid letter (if it's not '0') or take the current digit together with the previous digit as a two-digit letter (if the two-digit number is between 10 and 26 inclusive). The total number of decodings for a prefix depends only on the number of decodings for shorter prefixes — this is the essence of dynamic programming.

- Recurrence (bottom-up intuition): Let dp[i] be the number of ways to decode the prefix of length i (i.e., the first i characters). Use dp[0] = 1 as the base meaning "one way to decode an empty prefix". For position i (1-based length):
  - If the i-th character (s[i-1]) is not '0', then it can be used as a single digit: dp[i] += dp[i-1].
  - If the last two characters form a valid number between 10 and 26 (inclusive), then they can be used as a pair: dp[i] += dp[i-2].

  This yields the simple transitions:
  dp[0] = 1
  for i from 1 to n:
    dp[i] = 0
    if s[i-1] != '0': dp[i] += dp[i-1]
    if i >= 2 and 10 <= int(s[i-2:i]) <= 26: dp[i] += dp[i-2]

- Why dp[0] = 1? The base dp[0] = 1 makes the transitions work cleanly: when a valid two-digit number is at the start (like "12"), dp[2] should include dp[0], representing the single way to decode those two digits together.

- How to think about zeros: Zero cannot be decoded alone. It is only valid when it is the second char of a valid pair "10" or "20". Any '0' that is not part of one of those valid two-digit numbers makes the whole decoding impossible. Thus checks around zeros are what most implementations get wrong; always verify how you treat s[i-1] == '0' and two-digit checks.

- Top-down view (recursion + memo): You can view the same choices recursively: from index k, try to decode 1 digit (if valid) and recurse to k+1, and try to decode 2 digits (if valid) and recurse to k+2. Store results in a memo array keyed by index to avoid exponential work. The recurrence in recursion is identical to the dp transitions.

- Worked small example ("11106") using dp where dp[i] refers to prefix length i:
  s =  1 1 1 0 6
  idx: 1 2 3 4 5  (1-based for dp)
  dp[0] = 1 (empty)
  dp[1] = dp[0] ("1") = 1
  dp[2] = dp[1] ("1") + dp[0] ("11") = 1 + 1 = 2
  dp[3] = dp[2] ("1") + dp[1] ("11") = 2 + 1 = 3
  dp[4]: s[3] is '0' -> cannot use single digit. Check pair s[2:4] = "10" (valid) -> dp[4] = dp[2] = 2
  dp[5]: s[4] is '6' (non-zero) -> dp[5] += dp[4] = 2. Two-digit s[3:5] = "06" is invalid -> no dp[3] add. Final dp[5] = 2. That matches the two valid decodings: (1,1,10,6) and (11,10,6).

- Common edge cases to test and how to reason about them:
  1) Single '0' or string starting with '0' (e.g., "0", "06"): impossible -> 0. A leading zero can never be decoded.
  2) Valid two-digit with trailing zero ("10", "20"): valid and count as 1 decoding.
  3) Zero after something other than 1 or 2 ("30", "100", "301"): invalid because "30" is not allowed and lone zeros are invalid -> usually 0 for those inputs.
  4) Repeated ones/overlaps ("111", "226"): these test that you add both dp[i-1] and dp[i-2] appropriately.
  5) Long strings of valid digits (ensure you don't overflow; the problem guarantees 32-bit result fits). Use iterative dp or memoized recursion.
  6) Minimum and maximum lengths (n=1 and n up to 100): small base cases must be handled correctly.

- Implementation tips / pitfalls:
  - Always guard accesses when checking two-character substrings (ensure i >= 2 before using dp[i-2]).
  - When checking two-digit validity, prefer comparing numeric values (10 <= val <= 26) rather than string comparisons; also ensure the first char of the pair isn't '0'.
  - Using a dp array of length n+1 (dp[0..n]) is simpler and less error-prone than dp indexed by the original string indices.
  - You can optimize space to O(1) by keeping only the last two dp values (dp[i-1] and dp[i-2]) if you don't need the whole array for debugging.

- Complexity recap: Time O(n) as each position is processed once; Space O(n) for the dp array (or O(1) optimized).

**Java Code**

```java
    public int numDecodings(String source) {
        
        int length = source.length();
        int[] comb = new int[length];
        if (length == 1) return isValidDecode(source, 0, 0) ? 1 : 0;

        comb[0] = isValidDecode(source, 0, 0) ? 1 : 0;
        comb[1] = isValidDecode(source, 0, 1) ? 1 : 0;
        comb[1] = isValidDecode(source, 1, 1) ? comb[0] + comb[1] : comb[1];

        for (int i = 2; i < length; i++) {
            if (isValidDecode(source, i, i))
                comb[i] = comb[i] + comb[i - 1];
            if (isValidDecode(source, i - 1, i))
                comb[i] = comb[i] + comb[i - 2];
        }
        return comb[length - 1];
    }
    private boolean isValidDecode(String source, int start, int end) {
        if (source.charAt(start) == '0') return false;
        return Integer.parseInt(source.substring(start, end + 1)) <= 26;
    }
```
