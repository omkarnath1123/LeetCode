Link: [1182. Shortest Distance to Target Color](https://leetcode.com/problems/shortest-distance-to-target-color/) <br>
Tag : **Medium**<br>
Lock: **Premium**

You are given an array `colors`, in which there are three colors: `1`, `2` and `3`.

You are also given some queries. Each query consists of two integers `i` and `c`, return the shortest distance between the given index `i` and the target color `c`. If there is no solution return `-1`.

**Example 1:**
```
Input: colors = [1,1,2,1,3,2,2,3,3], queries = [[1,3],[2,2],[6,1]]
Output: [3,0,3]
Explanation: 
The nearest 3 from index 1 is at index 4 (3 steps away).
The nearest 2 from index 2 is at index 2 itself (0 steps away).
The nearest 1 from index 6 is at index 3 (3 steps away).
```

**Example 2:**
```
Input: colors = [1,2], queries = [[0,3]]
Output: [-1]
Explanation: There is no 3 in the array.
```

**Constraints:**
-   `1 <= colors.length <= 5*10^4`
-   `1 <= colors[i] <= 3`
-   `1 <= queries.length <= 5*10^4`
-   `queries[i].length == 2`
-   `0 <= queries[i][0] < colors.length`
-   `1 <= queries[i][1] <= 3`

## Detailed Intuition

### How to Think About the Solution:
1. Think of it as precomputing distances
2. Each position needs left and right info
3. Similar to nearest element queries
4. Can process all colors independently

### Key Insights:
1. Only need to track 3 colors
2. Can preprocess in two directions
3. Query time must be O(1)
4. Distance grows linearly

### Step-by-Step Approach:
1. **Preprocessing**:
   - Create left[] and right[] arrays
   - Process each color separately
   - Track nearest occurrences
   - Handle missing colors

2. **Query Processing**:
   - Check both directions
   - Take minimum valid distance
   - Handle edge cases

### Visual Guide:
```
Example: colors = [1,1,2,1,3,2,2,3,3]
Query: [1,3] (find nearest 3 from index 1)

Preprocessing for color 3:
Left distances:  [∞,∞,∞,∞,0,1,2,0,0]
Right distances: [4,3,2,1,0,2,1,0,0]
                  0 1 2 3 4 5 6 7 8

For query (1,3):
- Left: No 3 to left (∞)
- Right: 3 steps to index 4
Answer: 3
```

### Edge Cases to Consider:
- Color not present
- Query at array ends
- Single color arrays
- All colors same
- Maximum array length

### Common Pitfalls:
1. Not handling missing colors
2. Wrong distance calculation
3. Inefficient preprocessing
4. Not considering both directions

### Optimization Techniques:
1. **Distance Calculation**:
   - Process each color once
   - Use dynamic programming
   - Update distances linearly

2. **Query Optimization**:
   - O(1) lookup time
   - Precompute all distances
   - Use efficient data structures

### Time and Space Analysis:
- Time Complexity: 
  - Preprocessing: O(n) per color
  - Query: O(1)
- Space Complexity: O(n) 
  - Store distances for each color

### Similar Problems:
- Shortest Distance to Character
- Find K Closest Elements
- Paint House III

### Implementation Tips:
1. Initialize distances carefully
2. Handle missing colors properly
3. Update distances incrementally
4. Validate distance calculations

### Useful Resources:
- [Dynamic Programming Patterns](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns)
- [Array Preprocessing Techniques](https://www.geeksforgeeks.org/array-data-structure/)

**Solution:**
```java
    public List<Integer> shortestDistanceColor(int[] colors, int[][] queries) {
        
        int len = colors.length;
        long[][] store = new long[4][len];
        store[1][0] = store[2][0] = store[3][0] = Integer.MAX_VALUE;
        store[colors[0]][0] = 0;
        
        for (int i = 1; i < len; i++) {
            int val = colors[i];
            store[val][i] = 0;
            if (val != 1) store[1][i] = store[1][i - 1] + 1;
            if (val != 2) store[2][i] = store[2][i - 1] + 1;
            if (val != 3) store[3][i] = store[3][i - 1] + 1;
        }
        store[colors[len - 1]][len - 1] = 0;
        for (int i = len - 2; i >= 0; i--) {
            int val = colors[i];
            store[val][i] = 0;
            if (val != 1) store[1][i] = Math.min(store[1][i + 1] + 1, store[1][i]);
            if (val != 2) store[2][i] = Math.min(store[2][i + 1] + 1, store[2][i]);
            if (val != 3) store[3][i] = Math.min(store[3][i + 1] + 1, store[3][i]);
        }
        
        List<Integer> res = new LinkedList<>();
        for (int[] query : queries) {
            long pos = store[query[1]][query[0]];
            res.add(pos >= Integer.MAX_VALUE ? -1 : (int) pos);
        }
        return res;
    }
```
