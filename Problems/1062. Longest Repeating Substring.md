Link: [1062. Longest Repeating Substring](https://leetcode.com/problems/longest-repeating-substring/) <br>
Tag : **Medium**<br>
Lock: **Premium**

Given a string `s`, return _the length of the longest repeating substrings_. If no repeating substring exists, return `0`.

**Example 1:**
```
Input: s = "abcd"
Output: 0
Explanation: There is no repeating substring.
```

**Example 2:**
```
Input: s = "abbaba"
Output: 2
Explanation: The longest repeating substrings are "ab" and "ba", each of which occurs twice.
```

**Example 3:**
```
Input: s = "aabcaabdaab"
Output: 3
Explanation: The longest repeating substring is "aab", which occurs 3 times.
```

**Constraints:**
-   `1 <= s.length <= 2000`
-   `s` consists of lowercase English letters.

**Solution:**
- [x] [[Utils/Dynamic Programming]] + [[Bottom-Up Solution]]

## Detailed Intuition

### How to Think About the Solution:
1. Think of this as finding common substrings within the same string
2. For each position, we need to check if we can find the same substring elsewhere
3. We can use DP to build up from smaller substrings to larger ones

### Key Insights:
1. A substring can repeat multiple times (like "aab" in "aabcaabdaab")
2. Overlapping substrings don't count (in "aaa", "aa" appears twice but they overlap)
3. We only need the length of the longest repeating substring, not all occurrences

### Step-by-Step Approach:
1. **Dynamic Programming Setup**:
   - Use dp[i][j] to store length of common substring ending at i and j
   - If characters match at i and j, we can extend previous common substring
   - Track maximum length found so far

2. **Building the Solution**:
   - Compare each pair of positions in the string
   - When chars match, check if we can extend previous match
   - Update max length whenever we find a longer repeating substring

### Visual Guide:
```
Example: s = "abbaba"

Step-by-step for finding "ab":
a b b a b a
↑     ↑
matches (length 1)

a b b a b a
↑ ↑   ↑ ↑
matches (length 2)

Final dp table (showing matched lengths):
  a b b a b a
a 0 0 0 1 0 1
b 0 0 1 0 2 0
b 0 1 0 0 0 0
a 1 0 0 0 0 1
b 0 2 0 0 0 0
a 1 0 0 1 0 0
```

### Edge Cases to Consider:
- Single character string
- String with all same characters
- No repeating substrings
- Multiple repeating substrings of same length
- Overlapping potential matches

### Common Pitfalls:
1. Counting overlapping substrings
2. Not checking all possible starting positions
3. Only checking consecutive positions
4. Forgetting to update maximum length

### Optimization Techniques:
1. **Space Optimization**:
   - We can use rolling arrays since we only need previous row
   - Can optimize to O(n) space

2. **Early Termination**:
   - If we find a substring of length n/2, we can't do better

### Related Problems:
- Longest Common Substring
- Longest Duplicate Substring (Hard version)
- Repeated Substring Pattern

### Time and Space Analysis:
- Time Complexity: O(n²) - comparing all pairs of positions
- Space Complexity: O(n²) - DP table storage

### Useful Resources:
- [String Matching Algorithms](https://www.geeksforgeeks.org/string-matching-algorithms/)
- [Dynamic Programming on Strings](https://leetcode.com/discuss/general-discussion/651719/how-to-solve-dp-string-template-and-4-steps-to-be-followed)

```
n = is the length of workers

**Time Complexity** : O(n<sup>2</sup>)<br>
**Space Complexity** : O(n<sup>2</sup>)

```java
    public int longestRepeatingSubstring(String source) {
        
        int len = source.length(),
            maxLength = 0;
        int[][] store = new int[len + 1][len + 1];
        
        for (int i = 1; i <= len; i++)
            for (int j = 1; j <= len; j++)
                if (i != j && source.charAt(i - 1) == source.charAt(j - 1)) {
                    store[i][j] = store[i - 1][j - 1] + 1;
                    maxLength = Math.max(maxLength, store[i][j]);
                }
        return maxLength;
    }
```
