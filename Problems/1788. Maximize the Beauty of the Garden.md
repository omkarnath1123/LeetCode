Link: [1788. Maximize the Beauty of the Garden](https://leetcode.com/problems/maximize-the-beauty-of-the-garden/) <br>
Tag : **Hard**<br>
Lock: **Premium**

There is a garden of `n` flowers, and each flower has an integer beauty value. The flowers are arranged in a line. You are given an integer array `flowers` of size `n` and each `flowers[i]` represents the beauty of the `ith` flower.

A garden is **valid** if it meets these conditions:

-   The garden has at least two flowers.
-   The first and the last flower of the garden have the same beauty value.

As the appointed gardener, you have the ability to **remove** any (possibly none) flowers from the garden. You want to remove flowers in a way that makes the remaining garden **valid**. The beauty of the garden is the sum of the beauty of all the remaining flowers.

Return the maximum possible beauty of some **valid** garden after you have removed any (possibly none) flowers.

**Example 1:**
```
Input: flowers = [1,2,3,1,2]
Output: 8
Explanation: You can produce the valid garden [2,3,1,2] to have a total beauty of 2 + 3 + 1 + 2 = 8.
```

**Example 2:**
```
Input: flowers = [100,1,1,-3,1]
Output: 3
Explanation: You can produce the valid garden [1,1,1] to have a total beauty of 1 + 1 + 1 = 3.
```

**Example 3:**
```
Input: flowers = [-1,-2,0,-1]
Output: -2
Explanation: You can produce the valid garden [-1,-1] to have a total beauty of -1 + -1 = -2.
```

**Constraints:**
-   `2 <= flowers.length <= 105`
-   `-104 <= flowers[i] <= 104`
-   It is possible to create a valid garden by removing some (possibly none) flowers.

**Solution:**
- [x] [[Greedy]] + [[Prefix Sum]]

**Intuition** :
The only modification to the standard prefix sum-based approach that is used in questions such as Subarray Sum Equals K is that we don't add negative values to the rolling sum. This is because we can arbitrarily delete values ("remove flowers") from the subarray that exist between the first occurence of a given flower f and the current occurrence of f, in an attempt to maximize the score of the subarray. For example, for flowers = [2, 1, -3, 1], we can remove the flower with beauty -3 and attain a higher score from the subarray [1, -3, 1].

```
n = length of flowers
```
**Time Complexity** : O(n)<br>
**Space Complexity** : O(n)

```java
    public int maximumBeauty(int[] flowers) {
        
        int sum = 0, res = Integer.MIN_VALUE;
        Map<Integer, Integer> interval = new HashMap<>();
        
        for (int flower : flowers) {
            
            if (interval.containsKey(flower))
                res = Math.max(res, sum - interval.get(flower) + 2 * flower);
            
            if (flower > 0)
                sum += flower;
            
            interval.putIfAbsent(flower, sum);
        }
        return res;
    }
```
