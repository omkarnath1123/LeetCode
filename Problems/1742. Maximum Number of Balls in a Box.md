Link: [1742. Maximum Number of Balls in a Box](https://leetcode.com/problems/maximum-number-of-balls-in-a-box/description/) <br>
Tag : **Easy**<br>
Lock: **Normal**

You are working in a ball factory where you have `n` balls numbered from `lowLimit` up to `highLimit` **inclusive** (i.e., `n == highLimit - lowLimit + 1`), and an infinite number of boxes numbered from `1` to `infinity`.

Your job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball's number. For example, the ball number `321` will be put in the box number `3 + 2 + 1 = 6` and the ball number `10` will be put in the box number `1 + 0 = 1`.

Given two integers `lowLimit` and `highLimit`, return _the number of balls in the box with the most balls._

**Example 1:**

```
Input: lowLimit = 1, highLimit = 10
Output: 2
Explanation:
Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...
Ball Count:  2 1 1 1 1 1 1 1 1 0  0  ...
Box 1 has the most number of balls with 2 balls.
```

**Example 2:**

```
Input: lowLimit = 5, highLimit = 15
Output: 2
Explanation:
Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...
Ball Count:  1 1 1 1 2 2 1 1 1 0  0  ...
Boxes 5 and 6 have the most number of balls with 2 balls in each.
```

**Example 3:**

```
Input: lowLimit = 19, highLimit = 28
Output: 2
Explanation:
Box Number:  1 2 3 4 5 6 7 8 9 10 11 12 ...
Ball Count:  0 1 1 1 1 1 1 1 1 2  0  0  ...
Box 10 has the most number of balls with 2 balls.
```

**Constraints:**

- `1 <= lowLimit <= highLimit <= 105`

**Solution:**

- [x] [[Math]]

## Detailed Intuition

Think of each ball as being assigned to a "bucket" whose index is the sum of the digits of the ball's number. The problem reduces to counting how many numbers in the inclusive range [lowLimit, highLimit] share the same digit-sum and returning the largest such count.

Step-by-step thought process

- How to map a ball to a bucket: compute the sum of digits of the ball number (for example, 321 -> 3+2+1 = 6). That sum is the box (bucket) index.
- How to count efficiently: iterate every integer from lowLimit to highLimit, compute its digit sum, increment a counter for that bucket, and track the maximum count seen so far.
- Choosing the data structure: because constraints guarantee numbers are at most 10^5, the maximum digit sum is small (9 * number_of_digits). For 10^5 the maximum sum is 9*5 = 45, so a fixed-size array (size ~46 or a little larger) is enough and faster than a HashMap. A HashMap is fine too and clearer; an array is slightly faster and uses constant extra memory.
- Complexity: a single pass over the range yields O(n) time where n = highLimit - lowLimit + 1. Space is O(1) (bounded by a small constant for the bucket array) or O(log(maxNumber)) if you count the temporary digit-sum computation stack/variables.

Edge cases and how to reason about them

- lowLimit == highLimit: the range contains one ball; the answer should be 1 because exactly one ball goes in some bucket.
- Very small ranges (e.g., lowLimit=1, highLimit=1 or lowLimit=10, highLimit=10): confirm the digit-sum calculation handles single-digit and multi-digit numbers correctly (10 -> 1+0 = 1).
- Multiple buckets tying for max: the problem asks for the number of balls in the fullest box, not which box; if multiple boxes tie, return that highest count (e.g., several boxes may each have 2 balls — the answer is 2).
- Upper bound values and performance: with highLimit up to 100000, recomputing digit sums in the loop is fast enough. If the range were much larger, consider incremental digit-sum updates when incrementing the number (maintain the sum and adjust for carries) to avoid O(digits) work per number.
- Leading zeros / representation: integer arithmetic ignores leading zeros; computing digit sum by repeated div/mod is correct and unaffected by formatting.
- Negative numbers: constraints rule negatives out. If negatives were allowed, define whether digit-sum uses absolute value or includes sign — here we don't need to handle them.

Implementation tips and small optimizations

- Use an int[] buckets = new int[46] (or 50 to be safe) when you know the maximum digit sum; index by sum and increment.
- Maintain a running max: after incrementing a bucket, update max = Math.max(max, buckets[sum]). This avoids a second pass to find the maximum count.
- If you prefer readability over micro-optimizations, a HashMap<Integer,Integer> is straightforward and easy to understand and will perform well within the given limits.

Quick mental checklist while coding

- Correct digit-sum function (use % and /, or convert to string and sum chars — numeric is faster).
- Iterate inclusive range [lowLimit, highLimit].
- Update bucket counts and running maximum immediately.
- Return the running maximum (an integer >= 1 when the range is non-empty).

This section is intended to help you reason about the simplest correct approach first, then spot small optimizations (fixed-size bucket array, incremental digit-sum) if needed for larger inputs.

**Time Complexity** : O(n)<br>
**Space Complexity** : O(log(n))

```java
    public int countBalls(int lowLimit, int highLimit) {
        
        int maxBucket = 0;
        Map<Integer, Integer> bucket = new HashMap<>();
        for (int i = lowLimit; i <= highLimit; i++) {
            int bucketName = getBucket(i);
            bucket.merge(bucketName, 1, Integer::sum);
            maxBucket = Math.max(maxBucket, bucket.get(bucketName));
        }
        return maxBucket;
    }
    private int getBucket(int num) {
        int sum = 0;
        while (num != 0) {
            int reminder = num % 10;
            num = num / 10;
            sum = sum + reminder;
        }
        return sum;
    }
```
