Link: [2685. Count the Number of Complete Components](https://leetcode.com/problems/count-the-number-of-complete-components/) <br>
Tag : **Medium**<br>
Lock: **Normal**

You are given an integer `n`. There is an **undirected** graph with `n` vertices, numbered from `0` to `n - 1`. You are given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an **undirected** edge connecting vertices `ai` and `bi`.

Return _the number of **complete connected components** of the graph_.

A **connected component** is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.

A connected component is said to be **complete** if there exists an edge between every pair of its vertices.

**Example 1:**

**![](https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-31-23.png)**

```
Input: n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]
Output: 3
Explanation: From the picture above, one can see that all of the components of this graph are complete.
```

**Example 2:**

**![](https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-32-00.png)**

```
Input: n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]]
Output: 1
Explanation: The component containing vertices 0, 1, and 2 is complete since there is an edge between every pair of two vertices. On the other hand, the component containing vertices 3, 4, and 5 is not complete since there is no edge between vertices 4 and 5. Thus, the number of complete components in this graph is 1.
```

**Constraints:**

- `1 <= n <= 50`
- `0 <= edges.length <= n * (n - 1) / 2`
- `edges[i].length == 2`
- `0 <= ai, bi <= n - 1`
- `ai != bi`
- There are no repeated edges.

**Solution:**

- [x] [[Union-Find]]

**Intuition** :

1. **Initialize Union-Find data structure:** Each vertex starts as its own component.
2. **Process all edges:** For each edge (u, v), unite the components containing u and v.
3. **Group vertices by component:** After processing all edges, group vertices by their root node (component identifier).
4. **Count edges in each component:** For each edge, increment the edge counter for its corresponding component.
5. **Check completeness:** For each component, verify if the number of edges equals n*(n-1)/2, where n is the number of vertices in the component.
6. **Count complete components:** Sum the number of components that meet the completeness criterion.

```
n = no of nodes in graph

**Time Complexity** : `O(N + E * α(N))`, where:
    - `N` is the number of vertices
    - `E` is the number of edges
    - `α(N)` is the inverse Ackermann function (practically constant)  
        The Union-Find operations (find and union) take near-constant time per operation due to path compression and union by rank<br>
**Space Complexity** : O(n)

```java
        public int countCompleteComponents(int n, int[][] edges) {
        
        DisjointSet set = new DisjointSet();
        for (int[] edge : edges) {
            set.union(edge[0], edge[1]);
            set.union(edge[1], edge[0]);
        }
        Map<Integer, Integer> mapSizes = set.mapSizes(n);
        Map<Integer, Integer> edgeCount = new HashMap<>();
        for (int[] edge : edges) {
            edgeCount.merge(set.find(edge[0]), 1, Integer::sum);
        }
        int countComplete = 0;
        for (int head : mapSizes.keySet()) {
            int size = mapSizes.get(head);
            int edgesCount = size * (size - 1) / 2;
            if (edgesCount == edgeCount.getOrDefault(head, 0))
                countComplete++;
        }
        return countComplete;
    }
    class DisjointSet {
        Map<Integer, Node> nodes = new HashMap<>();

        private Node getNode(int val) {
            nodes.computeIfAbsent(val, item -> {
                Node node = new Node(val);
                node.parent = node;
                return node;
            });
            return nodes.get(val);
        }
        private Node findSet(Node node){
            if (node.parent == node) return node;
            node.parent = findSet(node.parent);
            return node.parent;
        } 
        public int find(int val) {
            Node node = getNode(val);
            return findSet(node).val;
        }
        public void union(int one, int two) {
            Node left = findSet(getNode(one)),
                 right = findSet(getNode(two));
            if (left == right) return;
            
            if (left.rank < right.rank)
                left.parent = right;
            else if (left.rank > right.rank)
                right.parent = left;
            else {
                left.parent = right;
                right.rank++;
            }
        }
        public Map<Integer, Integer> mapSizes(int n) {
            Map<Integer, Integer> mapsSize = new HashMap<>();
            for (int i = 0; i < n; i++) {
                mapsSize.merge(find(i), 1, Integer::sum);
            }
            return mapsSize;
        }
    }
    class Node {
        int val, rank = 1;
        Node parent;
        public Node(int val) {
            this.val = val;
        }
    }
```
