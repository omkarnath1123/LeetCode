Link: [1057. Campus Bikes](https://leetcode.com/problems/campus-bikes/) <br>
Tag : **Medium**<br>
Lock: **Premium**

On a campus represented on the X-Y plane, there are `n` workers and `m` bikes, with `n <= m`.

You are given an array `workers` of length `n` where `workers[i] = [xi, yi]` is the position of the `ith` worker. You are also given an array `bikes` of length `m` where `bikes[j] = [xj, yj]` is the position of the `jth` bike. All the given positions are **unique**.

Assign a bike to each worker. Among the available bikes and workers, we choose the `(workeri, bikej)` pair with the shortest **Manhattan distance** between each other and assign the bike to that worker.

If there are multiple `(workeri, bikej)` pairs with the same shortest **Manhattan distance**, we choose the pair with **the smallest worker index**. If there are multiple ways to do that, we choose the pair with **the smallest bike index**. Repeat this process until there are no available workers.

Return _an array_ `answer` _of length_ `n`_, where_ `answer[i]` _is the index (**0-indexed**) of the bike that the_ `ith` _worker is assigned to_.

The **Manhattan distance** between two points `p1` and `p2` is `Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/03/06/1261_example_1_v2.png)
```
Input: workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]]
Output: [1,0]
Explanation: Worker 1 grabs Bike 0 as they are closest (without ties), and Worker 0 is assigned Bike 1. So the output is [1, 0].
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2019/03/06/1261_example_2_v2.png)
```
Input: workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]]
Output: [0,2,1]
Explanation: Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share the same distance to Bike 2, thus Worker 1 is assigned to Bike 2, and Worker 2 will take Bike 1. So the output is [0,2,1].
```

**Constraints:**
-   `n == workers.length`
-   `m == bikes.length`
-   `1 <= n <= m <= 1000`
-   `workers[i].length == bikes[j].length == 2`
-   `0 <= xi, yi < 1000`
-   `0 <= xj, yj < 1000`
-   All worker and bike locations are **unique**.

## Detailed Intuition

### üí° How to Think About the Solution

1. **Multi-Criteria Matching Concept:**
   - Primary: Manhattan distance
   - Secondary: Worker index
   - Tertiary: Bike index
   - Process pairs in priority order

2. **Key Insights:**
   - Pre-calculate all distances
   - Sort by multiple criteria
   - Track assigned bikes/workers
   - Process in strictly defined order

### üîç Edge Cases to Consider
- Single worker and bike
- Equal distances
- Same worker to multiple bikes
- Same bike to multiple workers
- Maximum coordinates (1000)
- Maximum workers/bikes (1000)
- All points on same line
- All points at same location
- Diagonal arrangements
- Perfect matching exists

### üéØ Solution Approaches

1. **Bucket Sort with Priority Queue**
   ```pseudo
   function assignBikes(workers, bikes):
       n = workers.length
       m = bikes.length
       
       # Group by distance
       buckets = Array[2000]  # max distance is 2000
       for i in 0..n-1:
           for j in 0..m-1:
               dist = manhattan(workers[i], bikes[j])
               buckets[dist].add((i, j))
       
       # Process in order
       result = new int[n]
       Arrays.fill(result, -1)
       used_bikes = new boolean[m]
       assigned = 0
       
       for dist in 0..1999:
           # Sort pairs by worker then bike
           sort buckets[dist] by (worker, bike)
           
           for (worker, bike) in buckets[dist]:
               if result[worker] == -1 and 
                  !used_bikes[bike]:
                   result[worker] = bike
                   used_bikes[bike] = true
                   assigned++
                   if assigned == n:
                       return result
       
       return result
   ```
   Time: O(nm log nm), Space: O(nm)

### üìà Visual Explanation
```
Example: workers=[[0,0],[2,1]], bikes=[[1,2],[3,3]]

Distance Matrix:
W\B   B0(1,2)  B1(3,3)
W0    3        6
W1    4        3

Sort by (distance, worker, bike):
(3, W0, B0)
(3, W1, B1)
(4, W1, B0)
(6, W0, B1)

Processing:
1. Take (3, W0, B0): W0‚ÜíB0
2. Take (3, W1, B1): W1‚ÜíB1
Result: [0,1]
```

### üõ†Ô∏è Implementation Tips
1. Use bucket sort for distances
2. Sort within distance groups
3. Track assignments efficiently
4. Pre-calculate distances
5. Use appropriate data structures

### üìä Complexity Analysis
- Time Complexity: O(nm log nm)
  - Calculate all distances: O(nm)
  - Sort pairs: O(nm log nm)
- Space Complexity: O(nm)
  - Store all worker-bike pairs
  - Bucket storage

### üîó Related Patterns
- Bucket Sort
- Priority Processing
- Multi-criteria Sorting
- Similar Problems:
  - Campus Bikes II
  - Minimum Cost to Hire K Workers
  - Task Assignment

### üìù Example Processing Flow
```
Input: workers=[[0,0],[1,1]], bikes=[[1,0],[2,2]]

1. Calculate distances:
   W0->B0: 1
   W0->B1: 4
   W1->B0: 2
   W1->B1: 2

2. Group by distance:
   d=1: [(W0,B0)]
   d=2: [(W1,B0), (W1,B1)]
   d=4: [(W0,B1)]

3. Process groups:
   - Assign W0->B0 (distance 1)
   - Assign W1->B1 (distance 2)

Result: [0,1]
```

### ‚ö†Ô∏è Common Mistakes to Avoid
1. Wrong distance calculation
2. Incorrect priority ordering
3. Missing assignment checks
4. Inefficient pair storage
5. Wrong tiebreaking rules

```java
class Solution {
    public int[] assignBikes(int[][] workers, int[][] bikes) {
        int n = workers.length;
        int m = bikes.length;
        
        // Create distance buckets
        List<int[]>[] buckets = new List[2001];
        for (int i = 0; i < 2001; i++) {
            buckets[i] = new ArrayList<>();
        }
        
        // Calculate all distances
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int dist = manhattan(workers[i], bikes[j]);
                buckets[dist].add(new int[]{i, j});
            }
        }
        
        // Process assignments
        int[] result = new int[n];
        Arrays.fill(result, -1);
        boolean[] usedBikes = new boolean[m];
        int assigned = 0;
        
        // Process each distance bucket
        for (int d = 0; d < 2001 && assigned < n; d++) {
            // Sort by worker, then bike index
            Collections.sort(buckets[d], 
                (a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);
            
            for (int[] pair : buckets[d]) {
                int worker = pair[0], bike = pair[1];
                if (result[worker] == -1 && !usedBikes[bike]) {
                    result[worker] = bike;
                    usedBikes[bike] = true;
                    assigned++;
                }
            }
        }
        
        return result;
    }
    
    private int manhattan(int[] p1, int[] p2) {
        return Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]);
    }
}
3. Can use bucket sort optimization
4. Must handle assignment conflicts

### Key Insights:
1. Distance buckets create natural ordering
2. Within same distance, worker index matters
3. Worker-bike pairs form unique assignments
4. Can process assignments incrementally

### Step-by-Step Approach:
1. **Distance Calculation**:
   - Compute all worker-bike distances
   - Group pairs by Manhattan distance
   - Maintain ordering priorities
   - Use bucket sort for efficiency

2. **Assignment Processing**:
   - Process pairs by increasing distance
   - Handle same-distance cases by worker index
   - Track assigned bikes and workers
   - Build result array incrementally

### Visual Guide:
```
Example: workers=[[0,0],[2,1]], bikes=[[1,2],[3,3]]

Distance Matrix:
W\B  [1,2]  [3,3]
[0,0]   3     6
[2,1]   2     3

Sorted Pairs (dist, worker, bike):
(2, 1, 0)  - Worker 1 to Bike 0
(3, 0, 1)  - Worker 0 to Bike 1

Result: [1,0]
```

### Edge Cases to Consider:
- Equal distances
- All same distances
- Single worker/bike
- Maximum grid size
- Overlapping positions

### Common Pitfalls:
1. Wrong distance calculation
2. Incorrect priority handling
3. Missing assignments
4. Inefficient pair processing

### Optimization Techniques:
1. **Distance Processing**:
   - Use bucket sort
   - Avoid unnecessary sorting
   - Process in distance order

2. **Assignment Management**:
   - Track taken bikes efficiently
   - Handle conflicts early
   - Use boolean array for availability

### Time and Space Analysis:
- Time Complexity: O(N√óM)
  - N workers, M bikes
  - Constant space bucket sort
- Space Complexity: O(N√óM)
  - Store all possible pairs
  - Distance buckets

### Similar Problems:
- Optimal Account Balancing
- Meeting Rooms II
- Task Assignment

### Implementation Tips:
1. Use bucket sort for distances
2. Track assignments efficiently
3. Handle priority order correctly
4. Validate final assignments

### Useful Resources:
- [Manhattan Distance](https://xlinux.nist.gov/dads/HTML/manhattanDistance.html)
- [Bucket Sort Applications](https://www.geeksforgeeks.org/bucket-sort-2/)

**Solution:**

```java
    public int[] assignBikes(int[][] workers, int[][] bikes) {
        
        List<Pair>[] bucket = new List[2001];
        for (int i = 0; i < 2001; i++)
            bucket[i] = new LinkedList<>();
        
        int bikeCount = bikes.length,
            workerCount = workers.length;
        for (int i = 0; i < bikeCount; i++)
            for (int j = 0; j < workerCount; j++) {
                int dist = Math.abs(bikes[i][0] - workers[j][0]) + 
                           Math.abs(bikes[i][1] - workers[j][1]);
                bucket[dist].add(new Pair(j, i));
            }
        
        Set<Integer> visitedBiker = new HashSet<>(),
                     visitedWorker = new HashSet<>();
        int[] assign = new int[workerCount];
        for (List<Pair> list : bucket) {
            Collections.sort(list);
            
            for (Pair pair : list) {
                if (visitedBiker.contains(pair.bike) || 
                    visitedWorker.contains(pair.worker)) continue;
                visitedBiker.add(pair.bike);
                visitedWorker.add(pair.worker);
                assign[pair.worker] = pair.bike;
            }
        }
        return assign;
    }
    class Pair implements Comparable<Pair> {
        int worker, bike;
        Pair (int worker, int bike) {
            this.worker = worker;
            this.bike = bike;
        }
        @Override
        public int compareTo(Pair that) {
            if (this.worker != that.worker)
                return Integer.compare(this.worker, that.worker);
            else
                return Integer.compare(this.bike, that.bike);
        }
    }
```
