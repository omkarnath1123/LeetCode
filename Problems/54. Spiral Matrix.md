Link: [54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/description/) <br>
Tag : **Medium**<br>Lock: **Normal**

Given an `m x n` `matrix`, return _all elements of the_ `matrix` _in spiral order_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

```
Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```

**Constraints:**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 10`
- `-100 <= matrix[i][j] <= 100`

**Solution:**

- [x] [[Array]]

## Detailed Intuition

Think of the traversal as "peeling" the matrix one layer (or ring) at a time, like an onion. Maintain four boundaries that define the current outer layer: `top`, `bottom`, `left`, and `right`. At every iteration you do exactly four directional moves (when valid):

1. Traverse the top row from `left` to `right` (then `top++`).
2. Traverse the right column from `top` to `bottom` (then `right--`).
3. Traverse the bottom row from `right` to `left` (then `bottom--`).
4. Traverse the left column from `bottom` to `top` (then `left++`).

After these moves the outer layer is removed and the boundaries have shrunk to the next inner layer. Repeat while the submatrix defined by the boundaries is valid.

Key invariants and tips for reasoning:

- Invariant: at the start of each loop the remaining elements to visit are exactly those inside the rectangle [top..bottom] x [left..right].
- Termination: stop when `top > bottom` or `left > right` (no elements remain).
- Avoid double-visiting: when the remaining submatrix collapses to a single row or a single column, some of the four moves would re-visit elements. Guard these moves by either checking the boundaries before performing the 3rd and 4th traversals (e.g., `if (top <= bottom)` and `if (left <= right)`) or by keeping a count of collected elements and stopping when you've collected `m * n` elements.
- The provided code uses both the `while (top <= bottom && left <= right)` loop condition and an element-count guard (`res.size() < len * bre`) inside the directional loops to be safe in all shapes of matrix.

Edge cases to consider (and how to think about them):

- Single row (m = 1): Only the top-row traversal is valid. If you don't guard subsequent moves you may traverse the same row again in reverse when treating it as the bottom row. Use `top <= bottom` checks or a size/count guard.
- Single column (n = 1): Only the right-column traversal (after top) is valid. Without guards you can re-visit the same column.
- 1x1 matrix: Trivial; your loop should add the single element and stop immediately.
- Rectangular matrices (m != n): When rows < cols or rows > cols you must ensure the third and fourth moves don't run for the collapsed dimension. The boundary checks handle this.
- Empty matrix: The problem constraints guarantee at least 1x1, but robust code can handle `matrix.length == 0` or `matrix[0].length == 0` by returning an empty list early.

Complexity and guarantees:

- Time: O(m * n) — every element is visited exactly once.
- Space: O(1) extra space (ignoring the output list) — only a few integer variables for boundaries and counters.

Small walkthrough (3x4 example) to build intuition:

Matrix:
[ [1,  2,  3,  4],
  [5,  6,  7,  8],
  [9, 10, 11, 12] ]

Order by steps:
- Top row (left->right): 1,2,3,4  (top becomes 1)
- Right col (top->bottom): 8,12  (right becomes 2)
- Bottom row (right->left): 11,10,9  (bottom becomes 1)
- Left col (bottom->top): 5  (left becomes 1)
Now the remaining submatrix is [[6,7]] (top==bottom and left<=right), repeat to get 6,7.

How to implement safely (summary):
- Keep the four boundaries and update them after each directional pass.
- Use boundary checks (`top <= bottom`, `left <= right`) before the 3rd and 4th passes or a size/count guard inside loops to avoid duplicates.
- Return the collected list when its size reaches `m * n` (defensive) or when boundaries become invalid.

```java
    public List<Integer> spiralOrder(int[][] matrix) {
        
        int len = matrix.length,
            bre = matrix[0].length,
            top = 0,
            left = 0,
            bottom = len - 1,
            right = bre - 1;
        List<Integer> res = new LinkedList<>();

        while (top <= bottom && left <= right) {

            for (int i = left; i <= right && res.size() < len * bre; i++) {
                res.add(matrix[top][i]);
            }
            top++;

            for (int i = top; i <= bottom && res.size() < len * bre; i++) {
                res.add(matrix[i][right]);
            }
            right--;

            for (int i = right; i >= left && res.size() < len * bre; i--) {
                res.add(matrix[bottom][i]);
            }
            bottom--;

            for (int i = bottom; i >= top && res.size() < len * bre; i--) {
                res.add(matrix[i][left]);
            }
            left++;
        }
        return res;
    }
```
