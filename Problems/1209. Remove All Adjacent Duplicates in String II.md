Link: [1209.Â Remove All Adjacent Duplicates in String II](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/) <br>
Tag : **Medium**<br>
Lock: **Normal**

You are given a stringÂ `s`Â and an integerÂ `k`, aÂ `k`Â **duplicate removal**Â consists of choosingÂ `k`Â adjacent and equal letters fromÂ `s`Â and removing them, causing the left and the right side of the deleted substring to concatenate together.

We repeatedly makeÂ `k`Â **duplicate removals**Â onÂ `s`Â until we no longer can.

Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.

**Example 1:**
```
Input: s = "abcd", k = 2
Output: "abcd"
Explanation: There's nothing to delete.
```

**Example 2:**
```
Input: s = "deeedbbcccbdaa", k = 3
Output: "aa"
Explanation: 
First delete "eee" and "ccc", get "ddbbbdaa"
Then delete "bbb", get "dddaa"
Finally delete "ddd", get "aa"
```

**Example 3:**
```
Input: s = "pbbcggttciiippooaais", k = 2
Output: "ps"
```

**Constraints:**
-   `1 <= s.length <= 105`
-   `2 <= k <= 104`
-   `s`Â only contains lower case English letters.

**Solution:**
- [x] [[Stack]]

## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **Sequential Processing Concept:**
   - Think of the string as a stream of characters
   - Each character either:
     a) Starts a new sequence
     b) Extends current sequence
     c) Completes a k-sequence that needs removal

2. **Key Insights:**
   - Need to track both character and its count
   - After removing k characters, previous sequences might combine
   - Stack perfectly handles this "nested removal" behavior
   - Only need to check k consecutive same characters

### ðŸ” Edge Cases to Consider
- String with no duplicates
- String with multiple overlapping k-sequences
- String where removal creates new k-sequences
- Single character repeated many times
- Maximum string length (10^5)
- k equals string length
- k equals 2 (minimum value)

### ðŸŽ¯ Solution Approaches

1. **Stack with Character Count**
   ```pseudo
   function removeDuplicates(s, k):
       stack = [] # pairs of [char, count]
       for char in s:
           if stack and stack[-1][0] == char:
               stack[-1][1] += 1
               if stack[-1][1] == k:
                   stack.pop()
           else:
               stack.append([char, 1])
       return "".join(char * count for char, count in stack)
   ```
   Time: O(n), Space: O(n)

### ðŸ“ˆ Visual Explanation
```
Example: s = "deeedbbcccbdaa", k = 3

Step-by-step process:
d  â†’ stack: [d:1]
e  â†’ stack: [d:1, e:1]
e  â†’ stack: [d:1, e:2]
e  â†’ stack: [d:1, e:3] â†’ Remove 'eee' â†’ [d:1]
d  â†’ stack: [d:1, d:1]
b  â†’ stack: [d:2, b:1]
b  â†’ stack: [d:2, b:2]
c  â†’ stack: [d:2, b:2, c:1]
c  â†’ stack: [d:2, b:2, c:2]
c  â†’ stack: [d:2, b:2, c:3] â†’ Remove 'ccc' â†’ [d:2, b:2]
...
```

### ðŸ› ï¸ Implementation Tips
1. Use stack to store [character, count] pairs
2. Check stack top before pushing new character
3. Remove exactly k characters when count reaches k
4. Build final string by repeating characters
5. Consider using StringBuilder for string concatenation

### ðŸ“Š Complexity Analysis
- Time Complexity: O(n)
  - Each character is processed once
  - String building at the end is O(n)
- Space Complexity: O(n)
  - Stack stores at most n/k character-count pairs

### ðŸ”— Related Patterns
- Stack Operations
- String Manipulation
- Similar Problems:
  - Remove All Adjacent Duplicates in String
  - Valid Parentheses
  - Remove Duplicate Letters

### ðŸ“ Example Processing Flow
```
Input: "deeedbbcccbdaa", k = 3

1. Initial: "deeedbbcccbdaa"
2. Remove "eee": "ddbbcccbdaa"
3. Remove "ccc": "ddbbbdaa"
4. Remove "bbb": "dddaa"
5. Remove "ddd": "aa"
Final: "aa"

Each step potentially creates new k-sequences!
```

### âš ï¸ Common Mistakes to Avoid
1. Forgetting to check stack before pushing
2. Not handling the case when removal creates new sequences
3. Inefficient string concatenation in loops
4. Not considering that multiple removals might be needed
5. Assuming sequential scanning is enough (need stack)
2. Only need to check top of stack
3. Removals can cascade
4. Order of processing matters

### Step-by-Step Approach:
1. **Stack Management**:
   - Push new chars with count 1
   - Increment count for matches
   - Remove when count reaches k

2. **Removal Process**:
   - When count = k, pop stack
   - Check new top of stack
   - May trigger cascade of removals

### Visual Guide:
```
Example: s = "deeedbbcccbdaa", k = 3

Stack progression:
d(1)
d(1),e(1)
d(1),e(2)
d(1),e(3) -> d(1)       // remove eee
d(1),b(1)
d(1),b(2)
d(1),b(2),c(1)
d(1),b(2),c(2)
d(1),b(2),c(3) -> d(1),b(2)    // remove ccc
d(1),b(3) -> d(1)      // remove bbb
d(2)
d(3) ->                // remove ddd
a(1)
a(2)

Final: "aa"
```

### Edge Cases to Consider:
- Empty string
- String length < k
- All same characters
- No possible removals
- Multiple cascading removals

### Common Pitfalls:
1. Not handling cascading removals
2. Wrong count tracking
3. Stack underflow
4. Memory inefficiency

### Optimization Techniques:
1. **Stack Optimization**:
   - Use dummy bottom element
   - Combine char and count storage
   - Early termination checks

2. **Memory Management**:
   - Reuse string builder
   - Minimize object creation
   - Efficient string concatenation

### Time and Space Analysis:
- Time Complexity: O(n)
  - Single pass through string
  - Each char pushed/popped at most once
- Space Complexity: O(n)
  - Stack storage for chars and counts

### Similar Problems:
- Remove All Adjacent Duplicates In String
- Valid Parentheses
- Remove Duplicate Letters

### Implementation Tips:
1. Use pair/tuple for stack elements
2. Handle stack empty cases
3. Process removals immediately
4. Track counts efficiently

### Useful Resources:
- [Stack Data Structure](https://www.geeksforgeeks.org/stack-data-structure/)
- [String Processing Techniques](https://www.geeksforgeeks.org/string-data-structure/)
**Time Complexity** : O(n)<br>
**Space Complexity** : O(n)

```java
    public String removeDuplicates(String s, int k) {
        
        Deque<Element> stack = new LinkedList<>();
        
        for (char ch : s.toCharArray()) {
            if (stack.isEmpty()) {
                stack.offerLast(new Element(ch, 1));
            } else {
                Element top = stack.peekLast();
                if (top.val == ch) {
                    top.count++;
                    if (top.count == k) stack.pollLast();
                } else {
                    stack.offerLast(new Element(ch, 1));
                }
            }
        }
        StringBuilder sb = new StringBuilder();
        while (!stack.isEmpty()) {
            Element top = stack.pollFirst();
            for (int i = 0; i < top.count; i++) sb.append(top.val);
        }
        return sb.toString();
    }
    class Element {
        char val;
        int count;
        Element(char val, int count) {
            this.val = val;
            this.count = count;
        }
    }
```
