Link: [1101. The Earliest Moment When Everyone Become Friends](https://leetcode.com/problems/the-earliest-moment-when-everyone-become-friends/) <br>
Tag : **Medium**<br>
Lock: **Premium**

There are n people in a social group labeled from `0` to `n - 1`. You are given an array `logs` where `logs[i] = [timestampi, xi, yi]` indicates that `xi` and `yi` will be friends at the time `timestampi`.

Friendship is **symmetric**. That means if `a` is friends with `b`, then `b` is friends with `a`. Also, person `a` is acquainted with a person `b` if `a` is friends with `b`, or `a` is a friend of someone acquainted with `b`.

Return _the earliest time for which every person became acquainted with every other person_. If there is no such earliest time, return `-1`.

**Example 1:**
```
Input: logs = [[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],[20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]], n = 6
Output: 20190301
Explanation: 
The first event occurs at timestamp = 20190101 and after 0 and 1 become friends we have the following friendship groups [0,1], [2], [3], [4], [5].
The second event occurs at timestamp = 20190104 and after 3 and 4 become friends we have the following friendship groups [0,1], [2], [3,4], [5].
The third event occurs at timestamp = 20190107 and after 2 and 3 become friends we have the following friendship groups [0,1], [2,3,4], [5].
The fourth event occurs at timestamp = 20190211 and after 1 and 5 become friends we have the following friendship groups [0,1,5], [2,3,4].
The fifth event occurs at timestamp = 20190224 and as 2 and 4 are already friends anything happens.
The sixth event occurs at timestamp = 20190301 and after 0 and 3 become friends we have that all become friends.
```

**Example 2:**
```
Input: logs = [[0,2,0],[1,0,1],[3,0,3],[4,1,2],[7,3,1]], n = 4
Output: 3
```

**Constraints:**
-   `2 <= n <= 100`
-   `1 <= logs.length <= 104`
-   `logs[i].length == 3`
-   `0 <= timestampi <= 109`
-   `0 <= xi, yi <= n - 1`
-   `xi != yi`
-   All the values `timestampi` are **unique**.
-   All the pairs `(xi, yi)` occur at most one time in the input.


**Solution:**

- [x] [[Union-Find]]

## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **Network Formation Concept:**
   - Each person is a node in a social network
   - Friendships are undirected edges with timestamps
   - Groups are connected components in the graph
   - Need all nodes in one connected component

2. **Key Insights:**
   - Union-Find data structure perfectly models this
   - Process events in chronological order
   - Track number of distinct groups
   - Stop when all nodes are in same group

### ðŸ” Edge Cases to Consider
- Minimum group size (n=2)
- Maximum group size (n=100)
- Already connected pairs
- Disconnected components
- All events happening at same timestamp
- Events with maximum timestamp (10^9)
- Single group formation at last event
- Never forming a single group

### ðŸŽ¯ Solution Approaches

1. **Union-Find with Path Compression**
   ```pseudo
   class UnionFind:
       init(n):
           parent = [i for i in range(n)]
           rank = [0] * n
           components = n
       
       find(x):
           if parent[x] != x:
               parent[x] = find(parent[x])
           return parent[x]
       
       union(x, y):
           px, py = find(x), find(y)
           if px == py: return false
           if rank[px] < rank[py]:
               px, py = py, px
           parent[py] = px
           if rank[px] == rank[py]:
               rank[px] += 1
           components -= 1
           return true

   function earliestAcq(logs, n):
       uf = UnionFind(n)
       sort logs by timestamp
       for time, x, y in logs:
           if uf.union(x, y):
               if uf.components == 1:
                   return time
       return -1
   ```
   Time: O(N log N + NÎ±(N)), Space: O(N)

### ðŸ“ˆ Visual Explanation
```
Example with n=6:
[Initial]: [0] [1] [2] [3] [4] [5]
                â†“
[20190101]: [0-1] [2] [3] [4] [5]
                â†“
[20190104]: [0-1] [2] [3-4] [5]
                â†“
[20190107]: [0-1] [2-3-4] [5]
                â†“
[20190211]: [0-1-5] [2-3-4]
                â†“
[20190301]: [0-1-5-2-3-4] â† All Connected!
```

### ðŸ› ï¸ Implementation Tips
1. Sort logs by timestamp first
2. Use path compression in Union-Find
3. Track number of components
4. Use rank/size for union optimization
5. Handle timestamp comparisons carefully

### ðŸ“Š Complexity Analysis
- Time Complexity: O(N log N + MÎ±(N))
  - N log N for sorting logs
  - M operations with inverse Ackermann function
  - M is number of friendship logs
- Space Complexity: O(N)
  - Union-Find data structure storage
  - Sorting space complexity

### ðŸ”— Related Patterns
- Graph Connectivity
- Disjoint Set Union (DSU)
- Similar Problems:
  - Number of Connected Components
  - Graph Valid Tree
  - Number of Provinces

### ðŸ“ Example Processing Flow
```
Input: n=6, logs = [[20190101,0,1], [20190104,3,4],...]

1. Sort logs by timestamp
2. Initialize 6 separate groups
3. Process each friendship:
   - Union(0,1): 5 groups
   - Union(3,4): 4 groups
   - Union(2,3): 3 groups
   ...
4. Return when components = 1
```

### âš ï¸ Common Mistakes to Avoid
1. Not sorting logs by timestamp
2. Forgetting path compression
3. Not tracking component count
4. Missing symmetry of friendship
5. Incorrect timestamp comparisons

### Key Insights:
1. We need to process friendships in chronological order
2. Union-Find is perfect for tracking connected components
3. Problem is solved when we have only one component

### Step-by-Step Approach:
1. **Initial Setup**:
   - Sort all logs by timestamp
   - Initialize Union-Find with n people
   - Track number of components

2. **Processing Friendships**:
   - For each friendship event (in time order):
     - Union the two people
     - If components reduce to 1, we found our answer
     - If already friends (same component), skip

### Visual Guide:
```
Example with n=6:
[0,1] at t=20190101:
0----1  2  3  4  5
(5 components)

[3,4] at t=20190104:
0----1  2  3----4  5
(4 components)

[2,3] at t=20190107:
0----1  2----3----4  5
      \___________/
(3 components)

Final state at t=20190301:
0----1----2----3----4----5
      \________________/
(All connected = 1 component)
```

### Edge Cases to Consider:
- Already connected pairs
- Disconnected groups
- All people already friends
- Only two people
- Maximum possible timestamps

### Common Pitfalls:
1. Not sorting logs by timestamp first
2. Not handling already connected pairs
3. Not tracking component count efficiently
4. Not considering symmetric friendship property

### Optimization Techniques:
1. **Path Compression**:
   - Keep Union-Find tree flat
   - Makes operations nearly O(1)

2. **Union by Rank/Size**:
   - Balance trees during union
   - Prevents skewed structures

### Time and Space Analysis:
- Time Complexity: O(N log N) for sorting + O(M Ã— Î±(N)) for M unions
- Space Complexity: O(N) for Union-Find structure

### Similar Problems:
- Number of Connected Components in Graph
- Friend Circles
- Redundant Connection

### Useful Resources:
- [Union-Find Data Structure](https://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf)
- [Graph Connectivity Algorithms](https://www.geeksforgeeks.org/connectivity-in-a-graph/)
    -   Each log adds more connections among the individuals. A connection is _useful_ if the two individuals are separated (disjoint), or _redundant_ if the two individuals are connected already via other individuals.
    -   Initially, we treat each individual as a separate group. The number of groups decreases along with the _useful_ merging operations. The moment when the number of groups is reduced to one is the _earliest_ moment when everyone becomes connected (friends).


```
n = is the number of people
m = is the number of logs

**Time Complexity** : O(n + m * log(m))<br>
**Space Complexity** : O(n + m)

```java
    public int earliestAcq(int[][] logs, int n) {
        
        Arrays.sort(logs, (int[] one, int[] two) -> Integer.compare(one[0], two[0]));
        DisjointSet set = new DisjointSet(n);
        
        for (int[] log : logs) {
            set.union(log[1], log[2]);
            if (set.isOne()) return log[0];
        }
        return -1;
    }
    class DisjointSet {
        class Node {
            int val, rank = 0;
            Node parent;
            Node (int val) {
                this.val = val;
            }
        }
        int nodes;
        int sets = 0;
        Map<Integer, Node> map = new HashMap<>();
        DisjointSet(int nodes) {
            this.nodes = nodes;
        }
        
        private void makeSet(int val) {
            map.computeIfAbsent(val, item -> {
                Node node = new Node(val);
                node.parent = node;
                sets++;
                return node;
            });
        }
        public int find(int val) {
            makeSet(val);
            return findSet(map.get(val)).val;
        }
        private Node findSet(Node node) {
            if (node.parent == node)
                return node;
            node.parent = findSet(node.parent);
            return node.parent;
        }
        public void union(int one, int two) {
            makeSet(one);
            makeSet(two);
            Node left = findSet(map.get(one)),
                 right = findSet(map.get(two));
            if (left == right) return;
            
            if (left.rank < right.rank)
                left.parent = right;
            else if (right.rank < left.rank)
                right.parent = left;
            else {
                left.parent = right;
                right.rank++;
            }
            sets--;
        }
        public boolean isOne() {
            return map.size() == nodes && sets == 1;
        }
    }
```
