Link: [2531. Make Number of Distinct Characters Equal](https://leetcode.com/problems/make-number-of-distinct-characters-equal/)<br>
Tag : **Medium**<br>
Lock: **Normal**

You are given two **0-indexed** strings `word1` and `word2`.

A **move** consists of choosing two indices `i` and `j` such that `0 <= i < word1.length` and `0 <= j < word2.length` and swapping `word1[i]` with `word2[j]`.

Return `true` _if it is possible to get the number of distinct characters in_ `word1` _and_ `word2` _to be equal with **exactly one** move._ Return `false` _otherwise_.

**Example 1:**

```
Input: word1 = "ac", word2 = "b"
Output: false
Explanation: Any pair of swaps would yield two distinct characters in the first string, and one in the second string.
```

**Example 2:**

```
Input: word1 = "abcc", word2 = "aab"
Output: true
Explanation: We swap index 2 of the first string with index 0 of the second string. The resulting strings are word1 = "abac" and word2 = "cab", which both have 3 distinct characters.
```

**Example 3:**

```
Input: word1 = "abcde", word2 = "fghij"
Output: true
Explanation: Both resulting strings will have 5 distinct characters, regardless of which indices we swap.
```

**Constraints:**

- `1 <= word1.length, word2.length <= 105`
- `word1` and `word2` consist of only lowercase English letters.

**Solution:**

- [x] [[Hash Table]]

**Intuition** :

1. Create two maps to store frequency of characters of the strings.
    
2. Try swapping all possible pairs of alphabets between word1 and word2.
    
    How do we try swapping all possible pairs of alphabets between word1 and word2?  
    2.1 Create two for loops iterating c1: 'a' to 'z', c2: 'a' to 'z'  
    2.2 When char c1 is in word1 and char c2 is in word2  
    2.3 Remove c1 and put c2 in word1's map  
    2.4 Remove c2 and put c1 in word2's map
    
3. Now check the sizes of maps. If the maps' sizes are same means both words now have equal distinct characters. So, return true
    
4. If map sizes are not same then reset the maps back.
    
    How do we reset the maps?  
    4.1 Remove c2 and put back c1 in word1's map (opposite of 2.3)  
    4.2 Remove c1 and put back c2 in word2's map (opposite of 2.4)

```
n = length of one
m = length of two
```
**Time Complexity** : O(n+m)<br>
**Space Complexity** : O(1)

```java
    public boolean isItPossible(String one, String two) {
        
        Map<Character, Integer> freqOne = new HashMap<>(),
                                freqTwo = new HashMap<>();
        
        for (char ch : one.toCharArray()) freqOne.merge(ch, 1, Integer::sum);
        for (char ch : two.toCharArray()) freqTwo.merge(ch, 1, Integer::sum);
        return isOneDistinct(freqOne, freqTwo);
    }
    private boolean isOneDistinct(Map<Character, Integer> freqOne, Map<Character, Integer> freqTwo) {

        for (char charOne = 'a'; charOne <= 'z'; charOne++) {
            for (char charTwo = 'a'; charTwo <= 'z'; charTwo++) {

                if (!freqOne.containsKey(charOne) || !freqTwo.containsKey(charTwo))
                    continue;

                freqOne.merge(charTwo, 1, Integer::sum);
                freqTwo.merge(charTwo, -1, Integer::sum);
                freqTwo.remove(charTwo, 0);

                freqTwo.merge(charOne, 1, Integer::sum);
                freqOne.merge(charOne, -1, Integer::sum);
                freqOne.remove(charOne, 0);

                if (freqOne.size() == freqTwo.size()) return true;

                freqOne.merge(charOne, 1, Integer::sum);
                freqTwo.merge(charOne, -1, Integer::sum);
                freqTwo.remove(charOne, 0);

                freqTwo.merge(charTwo, 1, Integer::sum);
                freqOne.merge(charTwo, -1, Integer::sum);
                freqOne.remove(charTwo, 0);
            }
        }
        return false;
    }
```

