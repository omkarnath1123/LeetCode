Link: [1055. Shortest Way to Form String](https://leetcode.com/problems/shortest-way-to-form-string/) <br>
Tag : **Medium**<br>
Lock: **Premium**

A **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `"ace"` is a subsequence of `"abcde"` while `"aec"` is not).

Given two strings `source` and `target`, return _the minimum number of **subsequences** of_ `source` _such that their concatenation equals_ `target`. If the task is impossible, return `-1`.

**Example 1:**
```
Input: source = "abc", target = "abcbc"
Output: 2
Explanation: The target "abcbc" can be formed by "abc" and "bc", which are subsequences of source "abc".
```

**Example 2:**
```
Input: source = "abc", target = "acdbc"
Output: -1
Explanation: The target string cannot be constructed from the subsequences of source string due to the character "d" in target string.
```

**Example 3:**
```
Input: source = "xyz", target = "xzyxz"
Output: 3
Explanation: The target string can be constructed as follows "xz" + "y" + "xz".
```

**Constraints:**
-   `1 <= source.length, target.length <= 1000`
-   `source` and `target` consist of lowercase English letters.

**Solution:**
- [x] [[Greedy]] + [[Binary Search]]

## Detailed Intuition

### How to Think About the Solution:
1. Think of it as building target from source substrings
2. Each substring must be a subsequence of source
3. Want to minimize number of subsequences used
4. Need efficient way to find next character match

### Key Insights:
1. Greedy approach is optimal
2. Use each source character as far as possible
3. Can't form target if it has chars not in source
4. Position tracking is crucial

### Step-by-Step Approach:
1. **Preprocessing**:
   - Build character position maps for source
   - Check if all target chars exist in source

2. **Greedy Construction**:
   - Try to use maximum subsequence each time
   - Reset to start of source when needed
   - Count number of source copies used

### Visual Guide:
```
Example: source = "abc", target = "abcbc"

First subsequence:
source: abc
target: abcbc
match:  abc--  (used characters)

Second subsequence:
source: abc
target: abcbc
match:  ---bc  (remaining characters)

Result = 2 subsequences
```

### Edge Cases to Consider:
- Single character strings
- All same characters
- No common characters
- Target longer than source
- Target is source repeated

### Common Pitfalls:
1. Not checking impossible cases first
2. Inefficient character lookup
3. Wrong subsequence counting
4. Not handling repeated characters

### Optimization Techniques:
1. **Character Position Tracking**:
   - Use array/map for O(1) lookup
   - Store next occurrence positions

2. **Binary Search Enhancement**:
   - Find next character position quickly
   - Avoid linear scanning

### Advanced Solution:
```
For each position i in target:
1. Find next occurrence of target[i] in source
2. If not found after current position:
   - Reset to start of source
   - Increment subsequence count
3. If still not found, impossible
```

### Time and Space Analysis:
- Time Complexity: O(m × log n) where:
  - m = target length
  - n = source length
  - log n from binary search
- Space Complexity: O(n)

### Similar Problems:
- Is Subsequence
- Number of Matching Subsequences
- Distinct Subsequences

### Useful Resources:
- [Binary Search Techniques](https://leetcode.com/discuss/general-discussion/786126/python-powerful-ultimate-binary-search-template)
- [Greedy Algorithms](https://www.geeksforgeeks.org/greedy-algorithms/)

Match characters in source and target by moving indices `i` and `j`. Every time we run out of characters in the source (`j == s.size()`), we increase the number of subsequences and reset the source index (`j = 0`).
Since the number of subsequences cannot be larger than the target, we can use this fact to exist and return `-1` when a character is missing in the source.

```
n = length of source
m = length of target

**Time Complexity** : O(m log(n))<br>
**Space Complexity** : O(n)

```java
    public int shortestWay(String source, String target) {
        
        int len = source.length();
        Map<Character, List<Integer>> indexes = new HashMap<>();
        for (int i = 0; i < len; i++)
            indexes.computeIfAbsent(source.charAt(i), item -> new ArrayList<>()).add(i);
        
        int index = -1, 
            times = 1,
            lenTarget = target.length();
        
        for (int i = 0; i < lenTarget; i++) {
            char ch = target.charAt(i);
            if (!indexes.containsKey(ch))
                return -1;
            
            List<Integer> list = indexes.get(ch);
            int pos = Collections.binarySearch(list, index);
            if (pos < 0) pos = ~pos;
            else pos++;
            
            if (pos == list.size()) {
                i--;
                times++;
                index = -1;
            } else {
                index = list.get(pos);
            }
        }
        return times;
    }
```
