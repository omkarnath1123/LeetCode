Link: [104.Â Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) <br>
Tag : **Easy**<br>
Lock: **Normal**

Given theÂ `root`Â of a binary tree, returnÂ _its maximum depth_.

A binary tree'sÂ **maximum depth**Â is the number of nodes along the longest path from the root node down to the farthest leaf node.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: 3
```

**Example 2:**

```
Input: root = [1,null,2]
Output: 2
```

**Constraints:**

- The number of nodes in the tree is in the rangeÂ `[0, 104]`.
- `-100 <= Node.val <= 100`

**Solution:**

- [x] [[Backtracking]]

## Detailed Intuition

### ðŸ’¡ How to Think About the Solution

1. **Tree Height Concept:**
   - Think of the problem as finding the longest root-to-leaf path
   - Each level adds 1 to the depth
   - The maximum depth is the longest possible path

2. **Key Insights:**
   - Empty nodes (null) have height 0
   - A leaf node has height 1
   - Each parent's height is 1 + max(left_height, right_height)
   - Problem exhibits optimal substructure (perfect for recursion)

### ðŸ” Edge Cases to Consider
- Empty tree (null root)
- Single node tree
- Skewed tree (only left/right children)
- Perfect binary tree
- Unbalanced tree with significant height difference
- Maximum tree size (10^4 nodes)

### ðŸŽ¯ Solution Approaches

1. **Recursive DFS (Top-down)**
   ```pseudo
   maxDepth(node):
       if node is null:
           return 0
       return 1 + max(maxDepth(node.left), maxDepth(node.right))
   ```
   Time: O(n), Space: O(h) where h is height

2. **Iterative BFS (Level-order)**
   ```pseudo
   maxDepth(root):
       if not root:
           return 0
       depth = 0
       queue = [root]
       while queue:
           depth += 1
           for _ in range(len(queue)):
               node = queue.pop(0)
               if node.left:  queue.append(node.left)
               if node.right: queue.append(node.right)
       return depth
   ```
   Time: O(n), Space: O(w) where w is max width

3. **Iterative DFS (Stack)**
   ```pseudo
   maxDepth(root):
       if not root:
           return 0
       stack = [(root, 1)]
       max_depth = 0
       while stack:
           node, depth = stack.pop()
           max_depth = max(max_depth, depth)
           if node.right: stack.append((node.right, depth + 1))
           if node.left:  stack.append((node.left, depth + 1))
       return max_depth
   ```

### ðŸ“ˆ Visual Explanation
```
Example Tree:
       3            Level 1
      / \
     9   20         Level 2
        /  \
       15   7       Level 3

Step-by-step depth calculation:
1. Start at root (3)
2. Compare depths:
   - Left subtree (9): depth 1
   - Right subtree (20 â†’ 15,7): depth 2
3. Final depth = 1 + max(1, 2) = 3
```

### ðŸ› ï¸ Implementation Tips
1. Handle null checks at the beginning
2. For BFS, use a queue to track levels
3. For recursive DFS, be mindful of stack space
4. Consider using global variable for top-down approach
5. Use level-order traversal for better space complexity in wide trees

### ðŸ“Š Complexity Analysis
- Time Complexity: O(n) for all approaches
- Space Complexity:
  - Recursive: O(h) - worst case O(n) for skewed tree
  - BFS: O(w) - worst case O(n/2) for last level of perfect tree
  - Iterative DFS: O(h)

### ðŸ”— Related Patterns
- Tree DFS
- Tree BFS
- Level-order Traversal
- Similar Problems:
  - Minimum Depth of Binary Tree
  - Balanced Binary Tree
  - Diameter of Binary Tree

### ðŸŽ¨ Tree Visualization
![Binary Tree Example](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)
*The image shows a binary tree with maximum depth of 3, illustrating how to count levels from root to deepest leaf.*
    / \
   9   20      Level 2
      /  \
     15   7    Level 3

Step-by-step calculation:
- At leaf nodes (9, 15, 7): return 1
- At node 20: max(height(15), height(7)) + 1 = 2
- At root 3: max(height(9), height(20)) + 1 = 3
```

### Edge Cases to Consider:
- Empty tree (null root)
- Single node tree
- Skewed tree (all nodes to one side)
- Balanced vs unbalanced trees
- Very large trees (see constraints)

### Common Pitfalls:
1. Forgetting to handle null nodes
2. Confusing depth with height
3. Not considering the recursive stack space in space complexity

### Alternative Approaches:
1. **Recursive DFS (current solution)**
   - Time: O(n)
   - Space: O(h) where h is height (recursive stack)

2. **Iterative BFS**
   - Using queue, level by level
   - Time: O(n)
   - Space: O(w) where w is max width

3. **Iterative DFS**
   - Using stack
   - Time: O(n)
   - Space: O(h)

### Useful Resources:
- [Binary Tree Traversal Visualization](https://visualgo.net/en/bst)
- [Understanding Recursion in Trees](https://leetcode.com/explore/learn/card/recursion-i/)

```java
    public int maxDepth(TreeNode root) {
        if (Objects.isNull(root)) return 0;
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
```
