Link: [342. Power of Four](https://leetcode.com/problems/power-of-four/)<br>
Tag : **Easy**<br>
Lock: **Normal**

Given an integer `n`, return _`true` if it is a power of four. Otherwise, return `false`_.

An integer `n` is a power of four, if there exists an integer `x` such that `n == 4x`.

**Example 1:**

```
Input: n = 16
Output: true
```

**Example 2:**

```
Input: n = 5
Output: false
```

**Example 3:**

```
Input: n = 1
Output: true
```

**Constraints:**

- `-231 <= n <= 231 - 1`

**Follow up:** Could you solve it without loops/recursion?

**Solution:**

- [x] [[Bit Manipulation]]

**Intuition** :

To determine if n is a Power of 4, simply check if:

- n is Positive integer, and is a Power of Two:

n & (n−1)=0​(1)

This formula is already well explained in [POWER OF TWO](https://leetcode.com/problems/power-of-two/solutions/7059233/one-simple-trick-beats-100-by-la_castill-6lvh/) solution.

- the only difference here, is we need to check if

n % 3=1​(2)

Notice, we did not explicitly check for n≤0, that is because,

- eq. (1) will ensure negative numbers will be false, and
- eq. (2) will ensure n=0 will be false.

```
n = length of integer in bytes
```
**Time Complexity** : O(n)<br>
**Space Complexity** : O(1)

```java
    public boolean isPowerOfFour(int n) {
        
        String byteString = Integer.toBinaryString(n);

        int oneCount = 0, index = 0;
        int len = byteString.length();
        for (int i = len - 1, iter = 0;
             i >= 0;
             i--, iter++) {
            if (byteString.charAt(i) == '1') {
                oneCount++;
                index = iter;
            }
        }
        if (oneCount != 1) return false;
        return index == 0 || index % 2 == 0;
    }
```
