Link: [1598. Crawler Log Folder](https://leetcode.com/problems/crawler-log-folder/description/) <br>
Tag : **Easy**<br>
Lock: **Normal**

The Leetcode file system keeps a log each time some user performs a change folder operation.

The operations are described below:

"../" : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder).
"./" : Remain in the same folder.
"x/" : Move to the child folder named x (This folder is guaranteed to always exist).
You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step.

The file system starts in the main folder, then the operations in logs are performed.

Return the minimum number of operations needed to go back to the main folder after the change folder operations.

 

Example 1:



```
Input: logs = ["d1/","d2/","../","d21/","./"]
Output: 2
Explanation: Use this change folder operation "../" 2 times and go back to the main folder.
```
Example 2:



```
Input: logs = ["d1/","d2/","./","d3/","../","d31/"]
Output: 3
```
Example 3:

```
Input: logs = ["d1/","../","../","../"]
Output: 0
```
 

Constraints:

1 <= logs.length <= 103
2 <= logs[i].length <= 10
logs[i] contains lowercase English letters, digits, '.', and '/'.
logs[i] follows the format described in the statement.
Folder names consist of lowercase English letters and digits.

**Solution:**

- [x] [[Array]]

## Detailed Intuition

The simplest way to think about this problem is to simulate the current folder depth as an integer counter (distance from the main/root folder). Each log entry is one of three actions:

- "../": move up to the parent folder — decrease the depth by 1 but never below 0.
- "./": stay in the same folder — no change to the depth.
- "x/": move into a child folder named x — increase the depth by 1.

This simulation maintains a simple invariant: after processing the first i operations, the counter equals the current depth (number of steps from the main folder). At the end, the counter is exactly the minimum number of "../" operations needed to return to the main folder.

How to think about the solution step-by-step:

1. Initialize depth = 0 (we start at the main folder).
2. For each log entry:
   - If it equals "../", set depth = max(depth - 1, 0). The max prevents going above the root.
   - Else if it equals "./", do nothing.
   - Else treat it as a child folder and increment depth by 1.
3. Return depth.

Why an integer counter is enough (no need for a stack): we never need the actual folder names, only how many levels we are below the root. The only operation that requires memory is going up one level, and that can be captured by decrementing the counter. Using a stack of names is functionally correct but unnecessary and uses more space.

Edge cases and things to watch for:

- Repeated "../" when already at the root: ensure depth never becomes negative. Use max(depth - 1, 0) or check depth > 0 before decrementing.
- Entries like "..x/" or "x../" or folder names that contain dots: these are valid child folder names (not the parent action) and should be treated as increments. Only the exact strings "../" and "./" are special.
- Many consecutive "./" entries: they should be ignored and not affect the count.
- Large number of operations: algorithm is linear in the number of logs and uses O(1) extra space, so it scales up to the given limits easily.
- Minimal and maximal lengths of log strings are already constrained by the problem; you don't need extra validation in typical solutions.

Variants and alternatives:

- Stack-based simulation: push folder names on "x/" and pop on "../". This mirrors a real filesystem but is heavier (O(n) extra space in the worst case) and unnecessary when only the final distance to root is required.
- Counting only: the provided integer-depth approach is concise and optimal in both time and space.

Intuition summary: simulate depth with a single integer, treat only exact "../" and "./" as special, never let depth go below 0, and increment for any other folder entry — the final depth is the answer.

```java
    public int minOperations(String[] logs) {
        
        int depth = 0;
        for (String log : logs)
            if (log.equals("../")) depth = Math.max(depth - 1, 0);
            else if (log.equals("./")) continue;
            else depth++;
        return depth;
    }
```
